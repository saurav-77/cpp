{
    "simple_segment_tree_myself": {
        "prefix": "simple_segment_tree_myself",
        "body": [
            "template <typename tree_type, typename F>",
            "class seg_tree {",
            "\tvector<tree_type> tree;",
            "\tF op;",
            "\ttree_type identity;",
            "\tint n;",
            "\ttemplate <typename given_type>",
            "\tvoid build(int id, int l, int r, vector<given_type> &given) {",
            "\t\tif (l == r) {",
            "\t\t\ttree[id] = given[l];",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tbuild(lc, l, mid, given);",
            "\t\tbuild(rc, mid + 1, r, given);",
            "\t\ttree[id] = op(tree[lc], tree[rc]);",
            "\t}",
            "\ttree_type query(int id, int l, int r, int ql, int qr) {",
            "\t\tif (l > qr || r < ql) {",
            "\t\t\treturn identity;",
            "\t\t}",
            "\t\tif (l >= ql && r <= qr) {",
            "\t\t\treturn tree[id];",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\ttree_type lhs = query(lc, l, mid, ql, qr);",
            "\t\ttree_type rhs = query(rc, mid + 1, r, ql, qr);",
            "\t\treturn op(lhs, rhs);",
            "\t}",
            "\tvoid set(int id, int l, int r, int ind, tree_type value) {",
            "\t\tif (l == r && l == ind) {",
            "\t\t\ttree[id] = value;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tif (ind <= mid)",
            "\t\t\tset(lc, l, mid, ind, value);",
            "\t\telse",
            "\t\t\tset(rc, mid + 1, r, ind, value);",
            "\t\ttree[id] = op(tree[lc], tree[rc]);",
            "\t}",
            "",
            "\tvoid add(int id, int l, int r, int ind, tree_type value) {",
            "\t\tif (l == r && l == ind) {",
            "\t\t\ttree[id] += value;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tif (ind <= mid)",
            "\t\t\tadd(lc, l, mid, ind, value);",
            "\t\telse",
            "\t\t\tadd(rc, mid + 1, r, ind, value);",
            "\t\ttree[id] = op(tree[lc], tree[rc]);",
            "\t}",
            "",
            "\ttree_type get(int id, int l, int r, int ind) {",
            "\t\tif (l == r && l == ind) {",
            "\t\t\treturn tree[id];",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tif (ind <= mid) {",
            "\t\t\treturn get(lc, l, mid, ind);",
            "\t\t}",
            "\t\treturn get(rc, mid + 1, r, ind);",
            "\t}",
            "",
            "   public:",
            "\ttemplate <typename given_type>",
            "\tseg_tree(vector<given_type> &g, F operation, tree_type identity_element) : op(operation), identity(identity_element) {",
            "\t\tthis->n = g.size();",
            "\t\ttree.resize(4 * n);",
            "\t\tbuild(1, 0, n - 1, g);",
            "\t}",
            "\t// [l, r] 0-indexed",
            "\ttree_type query(int ql, int qr) {",
            "\t\tassert(ql >= 0 && qr <= n - 1 && ql <= qr);",
            "\t\treturn query(1, 0, n - 1, ql, qr);",
            "\t}",
            "\tvoid add(int ind, tree_type delta) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\tadd(1, 0, n - 1, ind, delta);",
            "\t}",
            "\tvoid set(int ind, tree_type val) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\tset(1, 0, n - 1, ind, val);",
            "\t}",
            "\ttree_type get(int ind) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\treturn get(1, 0, n - 1, ind);",
            "\t}",
            "\ttree_type prefix_query(int r) { return query(0, r); }",
            "\ttree_type suffix_query(int l) { return query(l, n - 1); }",
            "\ttree_type operator[](int ind) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\treturn get(ind);",
            "\t}",
            "\ttree_type query_all() { return tree[1]; }",
            "};"
        ]
    },
    "ncr_give_in_power_form": {
        "prefix": "ncr_give_in_power_form",
        "body": [
            "template <class Int>",
            "Int extgcd(Int a, Int b, Int &x, Int &y) {",
            "\tInt d = a;",
            "\tif (b != 0) {",
            "\t\td = extgcd(b, a % b, y, x), y -= (a / b) * x;",
            "\t} else {",
            "\t\tx = 1, y = 0;",
            "\t}",
            "\treturn d;",
            "}",
            "template <class Int>",
            "Int mod_inverse(Int a, Int m) {",
            "\tInt x, y;",
            "\textgcd<Int>(a, m, x, y);",
            "\tx %= m;",
            "\treturn x + (x < 0) * m;",
            "}",
            "",
            "template <class Int>  std::pair<Int, Int> inv_gcd(Int a, Int b) {",
            "\ta %= b;",
            "\tif (a < 0) a += b;",
            "\tif (a == 0) return {b, 0};",
            "\tInt s = b, t = a, m0 = 0, m1 = 1;",
            "\twhile (t) {",
            "\t\tInt u = s / t;",
            "\t\ts -= t * u, m0 -= m1 * u;",
            "\t\tauto tmp = s;",
            "\t\ts = t, t = tmp, tmp = m0, m0 = m1, m1 = tmp;",
            "\t}",
            "\tif (m0 < 0) m0 += b / s;",
            "\treturn {s, m0};",
            "}",
            "",
            "template <class Int>",
            "std::pair<Int, Int> crt(const std::vector<Int> &r, const std::vector<Int> &m) {",
            "\tassert(r.size() == m.size());",
            "\tint n = int(r.size());",
            "\tInt r0 = 0, m0 = 1;",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tassert(1 <= m[i]);",
            "\t\tInt r1 = r[i] % m[i], m1 = m[i];",
            "\t\tif (r1 < 0) r1 += m1;",
            "\t\tif (m0 < m1) {",
            "\t\t\tstd::swap(r0, r1);",
            "\t\t\tstd::swap(m0, m1);",
            "\t\t}",
            "\t\tif (m0 % m1 == 0) {",
            "\t\t\tif (r0 % m1 != r1) return {0, 0};",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tInt g, im;",
            "\t\tstd::tie(g, im) = inv_gcd<Int>(m0, m1);",
            "",
            "\t\tInt u1 = m1 / g;",
            "\t\tif ((r1 - r0) % g) return {0, 0};",
            "",
            "\t\tInt x = (r1 - r0) / g % u1 * im % u1;",
            "\t\tr0 += x * m0;",
            "\t\tm0 *= u1;",
            "\t\tif (r0 < 0) r0 += m0;",
            "\t}",
            "\treturn {r0, m0};",
            "}",
            "",
            "template <class Int>",
            "std::pair<Int, Int> linear_congruence(const std::vector<Int> &A, const std::vector<Int> &B, const std::vector<Int> &M) {",
            "\tInt r = 0, m = 1;",
            "\tassert(A.size() == M.size());",
            "\tassert(B.size() == M.size());",
            "\tfor (int i = 0; i < (int)A.size(); i++) {",
            "\t\tassert(M[i] > 0);",
            "\t\tconst Int ai = A[i] % M[i];",
            "\t\tInt a = ai * m, b = B[i] - ai * r, d = std::__gcd(M[i], a);",
            "\t\tif (b % d != 0) {",
            "\t\t\treturn std::make_pair(0, 0);  ",
            "\t\t}",
            "\t\tInt t = b / d * mod_inverse<Int>(a / d, M[i] / d) % (M[i] / d);",
            "\t\tr += m * t;",
            "\t\tm *= M[i] / d;",
            "\t}",
            "\treturn std::make_pair((r < 0 ? r + m : r), m);",
            "}",
            "",
            "template <class Int = int, class Long = long long>",
            "Int pow_mod(Int x, long long n, Int md) {",
            "\tstatic_assert(sizeof(Int) * 2 <= sizeof(Long), \"Watch out for overflow\");",
            "\tif (md == 1) return 0;",
            "\tInt ans = 1;",
            "\twhile (n > 0) {",
            "\t\tif (n & 1) ans = (Long)ans * x % md;",
            "\t\tx = (Long)x * x % md;",
            "\t\tn >>= 1;",
            "\t}",
            "\treturn ans;",
            "}",
            "struct combination_prime_pow {",
            "\tint p, q, m;",
            "\tstd::vector<int> fac, invfac, ppow;",
            "",
            "\tlong long _ej(long long n) const {",
            "\t\tlong long ret = 0;",
            "\t\twhile (n) ret += n, n /= p;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tcombination_prime_pow(int p_, int q_) : p(p_), q(q_), m(1), ppow{1} {",
            "\t\tfor (int t = 0; t < q; ++t) m *= p, ppow.push_back(m);",
            "\t\tfac.assign(m, 1);",
            "\t\tinvfac.assign(m, 1);",
            "\t\tfor (int i = 1; i < m; ++i) fac[i] = (long long)fac[i - 1] * (i % p ? i : 1) % m;",
            "\t\tinvfac[m - 1] = fac[m - 1]; ",
            "\t\tassert(1LL * fac.back() * invfac.back() % m == 1);",
            "\t\tfor (int i = m - 1; i; --i) invfac[i - 1] = (long long)invfac[i] * (i % p ? i : 1) % m;",
            "\t}",
            "",
            "\tint nCr(long long n, long long r) const {",
            "\t\tif (r < 0 or n < r) return 0;",
            "\t\tif (p == 2 and q == 1) return !((~n) & r);  ",
            "\t\tlong long k = n - r;",
            "\t\tlong long e0 = _ej(n / p) - _ej(r / p) - _ej(k / p);",
            "\t\tif (e0 >= q) return 0;",
            "",
            "\t\tlong long ret = ppow[e0];",
            "\t\tif (q == 1) {  ",
            "\t\t\twhile (n) {",
            "\t\t\t\tret = __int128(ret) * fac[n % p] * invfac[r % p] * invfac[k % p] % p;",
            "\t\t\t\tn /= p, r /= p, k /= p;",
            "\t\t\t}",
            "\t\t\treturn (int)ret;",
            "\t\t} else {",
            "\t\t\tif ((p > 2 or q < 3) and (_ej(n / m) - _ej(r / m) - _ej(k / m)) & 1) ret = m - ret;",
            "\t\t\twhile (n) {",
            "\t\t\t\tret = __int128(ret) * fac[n % m] * invfac[r % m] * invfac[k % m] % m;",
            "\t\t\t\tn /= p, r /= p, k /= p;",
            "\t\t\t}",
            "\t\t\treturn (int)ret;",
            "\t\t}",
            "\t}",
            "};",
            "",
            "// nCr mod m",
            "// Complexity: O(m) space worst (construction), O(log(n) log(m)) (per query)",
            "// Input: pairs of (prime, degree), such as vector<pair<int, int>> and map<int, int>",
            "struct combination {",
            "\tstd::vector<combination_prime_pow> cpps;",
            "\tstd::vector<int> ms;",
            "",
            "\ttemplate <class Map>",
            "\tcombination(const Map &p2deg) {",
            "\t\tfor (auto f : p2deg) {",
            "\t\t\tcpps.push_back(combination_prime_pow(f.first, f.second));",
            "\t\t\tms.push_back(cpps.back().m);",
            "\t\t}",
            "\t}",
            "",
            "\tint operator()(long long n, long long r) const {",
            "\t\tif (r < 0 or n < r) return 0;",
            "\t\tstd::vector<int> rs;",
            "\t\tfor (const auto &cpp : cpps) rs.push_back(cpp.nCr(n, r));",
            "\t\treturn crt(rs, ms).first;",
            "\t}",
            "};"
        ]
    },
    "lll_ulll_io": {
        "prefix": "lll_ulll_io",
        "body": [
            "ostream &operator<<(ostream &os, const __uint128_t &x) {",
            "\tconstexpr uint64_t d19 = 10'000'000'000'000'000'000U;",
            "\tif (x > d19) {",
            "\t\tos << uint64_t(x / d19) << setfill('0') << setw(19) << uint64_t(x % d19);",
            "\t} else {",
            "\t\tos << uint64_t(x);",
            "\t}",
            "\treturn os;",
            "}",
            "ostream &operator<<(ostream &os, const __int128_t &x) {",
            "\tif (x >= 0) {",
            "\t\tos << __uint128_t(x);",
            "\t} else {",
            "\t\tos << '-' << __uint128_t(-x);",
            "\t}",
            "\treturn os;",
            "}",
            "",
            "__uint128_t _stou128(const std::string &s) {",
            "\t__uint128_t ret = 0;",
            "\tfor (char c : s)",
            "\t\tif ('0' <= c and c <= '9') ret = 10 * ret + c - '0';",
            "\treturn ret;",
            "}",
            "__int128_t _stoi128(const std::string &s) { return (s[0] == '-' ? -1 : +1) * _stou128(s); }",
            "",
            "std::istream &operator>>(std::istream &is, __int128_t &x) {",
            "\tstd::string s;",
            "\treturn is >> s, x = _stoi128(s), is;",
            "}",
            "std::istream &operator>>(std::istream &is, __uint128_t &x) {",
            "\tstd::string s;",
            "\treturn is >> s, x = _stou128(s), is;",
            "}"
        ]
    },
    "euler_phi": {
        "prefix": "euler_phi",
        "body": [
            "template <typename Int>",
            "Int euler_phi(Int n) {",
            "\tInt ret = n;",
            "\tif (n % 2 == 0) {",
            "\t\tret /= 2;",
            "\t\tdo {",
            "\t\t\tn /= 2;",
            "\t\t} while (n % 2 == 0);",
            "\t}",
            "\tif (n % 3 == 0) {",
            "\t\tret = ret / 3 * 2;",
            "\t\tdo {",
            "\t\t\tn /= 3;",
            "\t\t} while (n % 3 == 0);",
            "\t}",
            "\tfor (Int i = 5; i * i <= n; i += 4) {",
            "\t\tif (n % i == 0) {",
            "\t\t\tret = ret / i * (i - 1);",
            "\t\t\tdo {",
            "\t\t\t\tn /= i;",
            "\t\t\t} while (n % i == 0);",
            "\t\t}",
            "\t\ti += 2;",
            "\t\tif (n % i == 0) {",
            "\t\t\tret = ret / i * (i - 1);",
            "\t\t\tdo {",
            "\t\t\t\tn /= i;",
            "\t\t\t} while (n % i == 0);",
            "\t\t}",
            "\t}",
            "\tif (n != 1) ret = ret / n * (n - 1);",
            "\treturn ret;",
            "}"
        ]
    },
    "euler_phi_table": {
        "prefix": "euler_phi_table",
        "body": [
            "template <typename T>",
            "std::vector<T> euler_phi_table(T N) {",
            "\tstd::vector<T> ret(N + 1);",
            "\tstd::iota(ret.begin(), ret.end(), 0);",
            "\tfor (T p = 2; p <= N; p++) {",
            "\t\tif (ret[p] == p) {",
            "\t\t\tret[p] = p - 1;",
            "\t\t\tfor (T i = p * 2; i <= N; i += p) ret[i] = ret[i] / p * (p - 1);",
            "\t\t}",
            "\t}",
            "\treturn ret;",
            "}"
        ]
    },
    "ben": {
        "prefix": "ben",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "using uint = uint32_t;",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using lll = __int128_t;",
            "using ulll = __uint128_t;",
            "",
            "inline namespace IO {",
            "#define SFINAE(x, ...)\t\t\t \\",
            "\ttemplate <class, class = void> \\",
            "\tstruct x : std::false_type {}; \\",
            "\ttemplate <class T>\t\t\t \\",
            "\tstruct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "",
            "\tostream &operator<<(ostream &os, const __uint128_t &x) {",
            "\t\tconstexpr uint64_t d19 = 10'000'000'000'000'000'000U;",
            "\t\tif (x > d19) {",
            "\t\t\tos << uint64_t(x / d19) << setfill('0') << setw(19) << uint64_t(x % d19);",
            "\t\t} else {",
            "\t\t\tos << uint64_t(x);",
            "\t\t}",
            "\t\treturn os;",
            "\t}",
            "\tostream &operator<<(ostream &os, const __int128_t &x) {",
            "\t\tif (x >= 0) {",
            "\t\t\tos << __uint128_t(x);",
            "\t\t} else {",
            "\t\t\tos << '-' << __uint128_t(-x);",
            "\t\t}",
            "\t\treturn os;",
            "\t}",
            "",
            "\t__uint128_t _stou128(const std::string &s) {",
            "\t\t__uint128_t ret = 0;",
            "\t\tfor (char c : s)",
            "\t\t\tif ('0' <= c and c <= '9')",
            "\t\t\t\tret = 10 * ret + c - '0';",
            "\t\treturn ret;",
            "\t}",
            "\t__int128_t _stoi128(const std::string &s) { return (s[0] == '-' ? -1 : +1) * _stou128(s); }",
            "",
            "\tstd::istream &operator>>(std::istream &is, __int128_t &x) {",
            "\t\tstd::string s;",
            "\t\treturn is >> s, x = _stoi128(s), is;",
            "\t}",
            "\tstd::istream &operator>>(std::istream &is, __uint128_t &x) {",
            "\t\tstd::string s;",
            "\t\treturn is >> s, x = _stou128(s), is;",
            "\t}",
            "",
            "\tSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));",
            "\tSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));",
            "\tSFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "\tSFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "\ttemplate <auto &is>",
            "\tstruct Reader {",
            "\t\ttemplate <class T>",
            "\t\tvoid Impl(T &t) {",
            "\t\t\tif constexpr (DefaultI<T>::value)",
            "\t\t\t\tis >> t;",
            "\t\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\t\tfor (auto &x : t)",
            "\t\t\t\t\tImpl(x);",
            "\t\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);",
            "\t\t\t} else",
            "\t\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for read\");",
            "\t\t}",
            "\t\ttemplate <class... Ts>",
            "\t\tvoid read(Ts &...ts) {",
            "\t\t\t((Impl(ts)), ...);",
            "\t\t}",
            "\t};",
            "",
            "\ttemplate <class... Ts>",
            "\tvoid re(Ts &...ts) {",
            "\t\tReader<cin>{}.read(ts...);",
            "\t}",
            "",
            "\ttemplate <auto &os, bool debug, bool print_nd>",
            "\tstruct Writer {",
            "\t\tstring comma() const { return debug ? \",\" : \"\"; }",
            "\t\ttemplate <class T>",
            "\t\tconstexpr char Space(const T &) const {",
            "\t\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n' : ' ';",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid Impl(T const &t) const {",
            "\t\t\tif constexpr (DefaultO<T>::value)",
            "\t\t\t\tos << t;",
            "\t\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\t\tif (debug)",
            "\t\t\t\t\tos << '{';",
            "\t\t\t\tint i = 0;",
            "\t\t\t\tfor (auto &&x : t)",
            "\t\t\t\t\t((i++) ? (os << comma() << Space(x), Impl(x)) : Impl(x));",
            "\t\t\t\tif (debug)",
            "\t\t\t\t\tos << '}';",
            "\t\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\t\tif (debug)",
            "\t\t\t\t\tos << '(';",
            "\t\t\t\tstd::apply(",
            "\t\t\t\t\t[this](auto const &...args) {",
            "\t\t\t\t\t\tint i = 0;",
            "\t\t\t\t\t\t(((i++) ? (os << comma() << \" \", Impl(args)) : Impl(args)), ...);",
            "\t\t\t\t\t},",
            "\t\t\t\t\tt);",
            "\t\t\t\tif (debug)",
            "\t\t\t\t\tos << ')';",
            "\t\t\t} else",
            "\t\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for print\");",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid ImplWrapper(T const &t) const {",
            "\t\t\tif (debug)",
            "\t\t\t\tos << \"\\033[0;31m\";",
            "\t\t\tImpl(t);",
            "\t\t\tif (debug)",
            "\t\t\t\tos << \"\\033[0m\";",
            "\t\t}",
            "\t\ttemplate <class... Ts>",
            "\t\tvoid print(Ts const &...ts) const {",
            "\t\t\t((Impl(ts)), ...);",
            "\t\t}",
            "\t\ttemplate <class F, class... Ts>",
            "\t\tvoid print_with_sep(const std::string &sep, F const &f, Ts const &...ts) const {",
            "\t\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';",
            "\t\t}",
            "\t\tvoid print_with_sep(const std::string &) const { os << '\\n'; }",
            "\t};",
            "",
            "\ttemplate <class... Ts>",
            "\tvoid pr(Ts const &...ts) {",
            "\t\tWriter<cout, false, true>{}.print(ts...);",
            "\t}",
            "\ttemplate <class... Ts>",
            "\tvoid ps(Ts const &...ts) {",
            "\t\tWriter<cout, false, true>{}.print_with_sep(\" \", ts...);",
            "\t}",
            "} // namespace IO",
            "",
            "inline namespace Debug {",
            "\ttemplate <typename... Args>",
            "\tvoid err(Args... args) {",
            "\t\tWriter<cerr, true, false>{}.print_with_sep(\" | \", args...);",
            "\t}",
            "\ttemplate <typename... Args>",
            "\tvoid errn(Args... args) {",
            "\t\tWriter<cerr, true, true>{}.print_with_sep(\" | \", args...);",
            "\t}",
            "",
            "\tvoid err_prefix(string func, int line, string args) {",
            "\t\tcerr << \"\\033[0;31m\\u001b[1mDEBUG\\033[0m\"",
            "\t\t\t << \" | \"",
            "\t\t\t << \"\\u001b[34m\" << func << \"\\033[0m\"",
            "\t\t\t << \":\"",
            "\t\t\t << \"\\u001b[34m\" << line << \"\\033[0m\"",
            "\t\t\t << \" - \"",
            "\t\t\t << \"[\" << args << \"] = \";",
            "\t}",
            "} // namespace Debug",
            "",
            "#ifdef CDEBUG",
            "#define clg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)",
            "#else",
            "#define clg(...)",
            "#endif",
            "",
            "void solve();",
            "",
            "int32_t main() {",
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}",
            "",
            "/****************************************************************************************************************************************************/",
            "",
            "void solve() {",
            "\t$0",
            "}"
        ]
    },
    "crt_find_x": {
        "prefix": "crt_find_x",
        "body": [
            "int64_t inv_mod(int64_t a, int64_t m) {",
            "\tint64_t g = m, r = a, x = 0, y = 1;",
            "",
            "\twhile (r != 0) {",
            "\t\tint64_t q = g / r;",
            "\t\tg %= r;",
            "\t\tswap(g, r);",
            "\t\tx -= q * y;",
            "\t\tswap(x, y);",
            "\t}",
            "",
            "\tassert(g == 1);",
            "\tassert(y == m || y == -m);",
            "\treturn x < 0 ? x + m : x;",
            "}",
            "",
            "// Returns a number that is a1 mod m1 and a2 mod m2. Assumes m1 and m2 are relatively prime.",
            "int64_t chinese_remainder_theorem(int64_t a1, int64_t m1, int64_t a2, int64_t m2) {",
            "\tif (m1 < m2) return chinese_remainder_theorem(a2, m2, a1, m1);",
            "",
            "\t// assert(__gcd(m1, m2) == 1);",
            "\tassert(m1 >= m2);",
            "\tint64_t k = (a2 - a1) % m2 * inv_mod(m1, m2) % m2;",
            "\tint64_t result = a1 + k * m1;",
            "",
            "\tif (result < 0) result += m1 * m2;",
            "",
            "\tassert(0 <= result && result < m1 * m2);",
            "\tassert(result % m1 == a1 && result % m2 == a2);",
            "\treturn result;",
            "}",
            "",
            "template <typename T>",
            "int64_t chinese_remainder_theorem(const vector<T> &a, const vector<T> &m) {",
            "\tassert(a.size() == m.size());",
            "\tint64_t result = a.front();",
            "\tint64_t mod = m.front();",
            "",
            "\tfor (int i = 1; i < int(m.size()); i++) {",
            "\t\tresult = chinese_remainder_theorem(result, mod, a[i], m[i]);",
            "\t\tmod *= m[i];",
            "\t}",
            "",
            "\treturn result;",
            "}"
        ]
    },
    "ncr_with_any_mod_but_run_sieve()_first": {
        "prefix": "ncr_with_any_mod_but_run_sieve()_first",
        "body": [
            "const int N = 1e6 + 9;",
            "using ll = long long;",
            "",
            "int power(long long n, long long k, const int mod) {",
            "\tint ans = 1 % mod;",
            "\tn %= mod;",
            "\tif (n < 0) n += mod;",
            "\twhile (k) {",
            "\t\tif (k & 1) ans = (long long)ans * n % mod;",
            "\t\tn = (long long)n * n % mod;",
            "\t\tk >>= 1;",
            "\t}",
            "\treturn ans;",
            "}",
            "ll extended_euclid(ll a, ll b, ll &x, ll &y) {",
            "\tif (b == 0) {",
            "\t\tx = 1;",
            "\t\ty = 0;",
            "\t\treturn a;",
            "\t}",
            "\tll x1, y1;",
            "\tll d = extended_euclid(b, a % b, x1, y1);",
            "\tx = y1;",
            "\ty = x1 - y1 * (a / b);",
            "\treturn d;",
            "}",
            "ll inverse(ll a, ll m) {",
            "\tll x, y;",
            "\tll g = extended_euclid(a, m, x, y);",
            "\tif (g != 1) return -1;",
            "\treturn (x % m + m) % m;",
            "}",
            "// O(mod) * log(n)",
            "int factmod(ll n, int p, const int mod) {",
            "\tvector<int> f(mod + 1);",
            "\tf[0] = 1 % mod;",
            "\tfor (int i = 1; i <= mod; i++) {",
            "\t\tif (i % p)",
            "\t\t\tf[i] = 1LL * f[i - 1] * i % mod;",
            "\t\telse",
            "\t\t\tf[i] = f[i - 1];",
            "\t}",
            "\tint ans = 1 % mod;",
            "\twhile (n > 1) {",
            "\t\tans = 1LL * ans * f[n % mod] % mod;",
            "\t\tans = 1LL * ans * power(f[mod], n / mod, mod) % mod;",
            "\t\tn /= p;",
            "\t}",
            "\treturn ans;",
            "}",
            "ll multiplicity(ll n, int p) {",
            "\tll ans = 0;",
            "\twhile (n) {",
            "\t\tn /= p;",
            "\t\tans += n;",
            "\t}",
            "\treturn ans;",
            "}",
            "// C(n, r) modulo p^k",
            "// O(p^k log n)",
            "int ncr(ll n, ll r, int p, int k) {",
            "\tif (n < r or r < 0) return 0;",
            "\tint mod = 1;",
            "\tfor (int i = 0; i < k; i++) {",
            "\t\tmod *= p;",
            "\t}",
            "\tll t = multiplicity(n, p) - multiplicity(r, p) - multiplicity(n - r, p);",
            "\tif (t >= k) return 0;",
            "\tint ans =",
            "\t\t1LL * factmod(n, p, mod) * inverse(factmod(r, p, mod), mod) % mod * inverse(factmod(n - r, p, mod), mod) % mod;",
            "\tans = 1LL * ans * power(p, t, mod) % mod;",
            "\treturn ans;",
            "}",
            "pair<ll, ll> CRT(ll a1, ll m1, ll a2, ll m2) {",
            "\tll p, q;",
            "\tll g = extended_euclid(m1, m2, p, q);",
            "\tif (a1 % g != a2 % g) return make_pair(0, -1);",
            "\tll m = m1 / g * m2;",
            "\tp = (p % m + m) % m;",
            "\tq = (q % m + m) % m;",
            "\treturn make_pair((p * a2 % m * (m1 / g) % m + q * a1 % m * (m2 / g) % m) % m, m);",
            "}",
            "int spf[N];",
            "vector<int> primes;",
            "void sieve() {",
            "\tfor (int i = 2; i < N; i++) {",
            "\t\tif (spf[i] == 0) spf[i] = i, primes.push_back(i);",
            "\t\tint sz = primes.size();",
            "\t\tfor (int j = 0; j < sz && i * primes[j] < N && primes[j] <= spf[i]; j++) {",
            "\t\t\tspf[i * primes[j]] = primes[j];",
            "\t\t}",
            "\t}",
            "}",
            "// O(m log(n) log(m))",
            "int ncr(ll n, ll r, int m) {",
            "\tif (n < r or r < 0) return 0;",
            "\tpair<ll, ll> ans({0, 1});",
            "\twhile (m > 1) {",
            "\t\tint p = spf[m], k = 0, cur = 1;",
            "\t\twhile (m % p == 0) {",
            "\t\t\tm /= p;",
            "\t\t\tcur *= p;",
            "\t\t\t++k;",
            "\t\t}",
            "\t\tans = CRT(ans.first, ans.second, ncr(n, r, p, k), cur);",
            "\t}",
            "\treturn ans.first;",
            "}"
        ]
    },
    "lucas_for_fixed_prime_mod": {
        "prefix": "lucas_for_fixed_prime_mod",
        "body": [
            "using ll = long long;",
            "",
            "template <const int32_t MOD>",
            "struct modint {",
            "\tint32_t value;",
            "\tmodint() = default;",
            "\tmodint(int32_t value_) : value(value_) {}",
            "\tinline modint<MOD> operator+(modint<MOD> other) const {",
            "\t\tint32_t c = this->value + other.value;",
            "\t\treturn modint<MOD>(c >= MOD ? c - MOD : c);",
            "\t}",
            "\tinline modint<MOD> operator-(modint<MOD> other) const {",
            "\t\tint32_t c = this->value - other.value;",
            "\t\treturn modint<MOD>(c < 0 ? c + MOD : c);",
            "\t}",
            "\tinline modint<MOD> operator*(modint<MOD> other) const {",
            "\t\tint32_t c = (int64_t)this->value * other.value % MOD;",
            "\t\treturn modint<MOD>(c < 0 ? c + MOD : c);",
            "\t}",
            "\tinline modint<MOD> &operator+=(modint<MOD> other) {",
            "\t\tthis->value += other.value;",
            "\t\tif (this->value >= MOD) this->value -= MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tinline modint<MOD> &operator-=(modint<MOD> other) {",
            "\t\tthis->value -= other.value;",
            "\t\tif (this->value < 0) this->value += MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tinline modint<MOD> &operator*=(modint<MOD> other) {",
            "\t\tthis->value = (int64_t)this->value * other.value % MOD;",
            "\t\tif (this->value < 0) this->value += MOD;",
            "\t\treturn *this;",
            "\t}",
            "\tinline modint<MOD> operator-() const { return modint<MOD>(this->value ? MOD - this->value : 0); }",
            "\tmodint<MOD> pow(uint64_t k) const {",
            "\t\tmodint<MOD> x = *this, y = 1;",
            "\t\tfor (; k; k >>= 1) {",
            "\t\t\tif (k & 1) y *= x;",
            "\t\t\tx *= x;",
            "\t\t}",
            "\t\treturn y;",
            "\t}",
            "\tmodint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime",
            "\tinline modint<MOD> operator/(modint<MOD> other) const { return *this * other.inv(); }",
            "\tinline modint<MOD> operator/=(modint<MOD> other) { return *this *= other.inv(); }",
            "\tinline bool operator==(modint<MOD> other) const { return value == other.value; }",
            "\tinline bool operator!=(modint<MOD> other) const { return value != other.value; }",
            "\tinline bool operator<(modint<MOD> other) const { return value < other.value; }",
            "\tinline bool operator>(modint<MOD> other) const { return value > other.value; }",
            "};",
            "template <int32_t MOD>",
            "modint<MOD> operator*(int32_t value, modint<MOD> n) {",
            "\treturn modint<MOD>(value) * n;",
            "}",
            "template <int32_t MOD>",
            "modint<MOD> operator*(int64_t value, modint<MOD> n) {",
            "\treturn modint<MOD>(value % MOD) * n;",
            "}",
            "template <int32_t MOD>",
            "istream &operator>>(istream &in, modint<MOD> &n) {",
            "\treturn in >> n.value;",
            "}",
            "template <int32_t MOD>",
            "ostream &operator<<(ostream &out, modint<MOD> n) {",
            "\treturn out << n.value;",
            "}",
            "",
            "const int N = 1e6 + 3, mod = 1e6 + 3;",
            "using mint = modint<mod>;",
            "",
            "struct combi {",
            "\tint n;",
            "\tvector<mint> facts, finvs, invs;",
            "\tcombi(int _n) : n(_n), facts(_n), finvs(_n), invs(_n) {",
            "\t\tfacts[0] = finvs[0] = 1;",
            "\t\tinvs[1] = 1;",
            "\t\tfor (int i = 2; i < n; i++) invs[i] = invs[mod % i] * (-mod / i);",
            "\t\tfor (int i = 1; i < n; i++) {",
            "\t\t\tfacts[i] = facts[i - 1] * i;",
            "\t\t\tfinvs[i] = finvs[i - 1] * invs[i];",
            "\t\t}",
            "\t}",
            "\tinline mint fact(int n) { return facts[n]; }",
            "\tinline mint finv(int n) { return finvs[n]; }",
            "\tinline mint inv(int n) { return invs[n]; }",
            "\tinline mint ncr(int n, int k) { return n < k or k < 0 ? 0 : facts[n] * finvs[k] * finvs[n - k]; }",
            "};",
            "combi C(N);",
            "",
            "// returns nCr modulo mod where mod is a prime",
            "// Complexity: log(n)",
            "mint lucas(ll n, ll r) {",
            "\tif (r > n) return 0;",
            "\tif (n < mod) return C.ncr(n, r);",
            "\treturn lucas(n / mod, r / mod) * lucas(n % mod, r % mod);",
            "}"
        ]
    },
    "binary_trie_intrin": {
        "prefix": "binary_trie_intrin",
        "body": [
            "#ifdef _MSC_VER",
            "#include <intrin.h>",
            "#else",
            "#include <x86intrin.h>",
            "#endif",
            "",
            "template <typename T, uint32_t bit_num, typename SizeType = int32_t, std::enable_if_t<std::is_integral_v<T>, std::nullptr_t> = nullptr>",
            "struct binary_trie {",
            "\tusing size_type = SizeType;",
            "\tusing internal_size_type = std::make_unsigned_t<size_type>;",
            "",
            "\tusing value_type = T;",
            "\tusing unsigned_value_type = std::make_unsigned_t<value_type>;",
            "",
            "\tstatic constexpr uint32_t ary = 4;",
            "\tstatic constexpr uint32_t log_ary = 2;",
            "",
            "\tstatic_assert(bit_num <= std::numeric_limits<unsigned_value_type>::digits);",
            "\tstatic_assert(bit_num <= 64);",
            "",
            "\tstruct Node;",
            "\tusing node_type = Node;",
            "\tusing node_pointer_type = node_type *;",
            "",
            "\tstruct Node {",
            "\t\tunsigned_value_type val;",
            "\t\tuint32_t len;",
            "\t\tinternal_size_type siz;",
            "\t\tnode_pointer_type ch[ary]{};",
            "",
            "\t\tNode(const unsigned_value_type &val, uint32_t len, internal_size_type siz) : val(val), len(len), siz(siz) {}",
            "\t\t~Node() {",
            "\t\t\tfor (uint32_t i = 0; i < ary; ++i)",
            "\t\t\t\tdelete ch[i];",
            "\t\t}",
            "",
            "\t\tstatic node_pointer_type new_node(const unsigned_value_type &val, uint32_t len, internal_size_type siz) {",
            "\t\t\treturn new node_type(val, len, siz);",
            "\t\t}",
            "\t};",
            "",
            "\tbinary_trie() = default;",
            "\t~binary_trie() {",
            "\t\tdelete _root;",
            "\t}",
            "",
            "\t// number of elements in the set",
            "\tint size() const {",
            "\t\treturn _root->siz;",
            "\t}",
            "\t// true iff size() == 0",
            "\tbool empty() const {",
            "\t\treturn _root->siz == 0;",
            "\t}",
            "\tvoid clear() {",
            "\t\tdelete _root;",
            "\t\t_root = node_type::new_node(0, 0, 0);",
            "\t}",
            "",
            "\t// returns true iff insertion is succeeded.",
            "\tbool insert_if_absent(unsigned_value_type val) {",
            "\t\tbit_reverse(val);",
            "\t\treturn _insert_if_absent(_root, 0, val);",
            "\t}",
            "\tvoid insert(unsigned_value_type val, internal_size_type num = 1) {",
            "\t\tbit_reverse(val);",
            "\t\t_insert(_root, 0, val, num);",
            "\t}",
            "\t// returns the number of erased elements",
            "\tsize_type erase(unsigned_value_type val, internal_size_type num = 1) {",
            "\t\tif (num == 0)",
            "\t\t\treturn 0;",
            "\t\tbit_reverse(val);",
            "\t\t_erase(_root, num, 0, val);",
            "\t\treturn num;",
            "\t}",
            "",
            "\tsize_type count(unsigned_value_type val) const {",
            "\t\tbit_reverse(val);",
            "\t\tnode_pointer_type cur = _root;",
            "\t\tfor (uint32_t l = 0; l < bit_num;) {",
            "\t\t\tconst uint32_t ch_idx = val & (ary - 1);",
            "\t\t\tnode_pointer_type nxt = cur->ch[ch_idx];",
            "\t\t\tif (not nxt or cut_lower(val ^ nxt->val, nxt->len))",
            "\t\t\t\treturn 0;",
            "\t\t\tval >>= nxt->len;",
            "\t\t\tl += nxt->len;",
            "\t\t\tcur = nxt;",
            "\t\t}",
            "\t\treturn cur->siz;",
            "\t}",
            "\tbool contains(unsigned_value_type val) const { return count(val) != 0; }",
            "",
            "\t// min{ x ^ v | v in S }",
            "\tvalue_type xor_min(unsigned_value_type x) const {",
            "\t\treturn xor_kth_min(x, 0);",
            "\t}",
            "\t// max{ x ^ v | v in S }",
            "\tvalue_type xor_max(const unsigned_value_type &x) const {",
            "\t\treturn xor_min(~x);",
            "\t}",
            "",
            "\t// k-th smallest of { x ^ v | v in S } (0-indexed)",
            "\tvalue_type xor_kth_min(unsigned_value_type x, internal_size_type k) const {",
            "\t\tunsigned_value_type x_ = x;",
            "\t\tbit_reverse(x);",
            "\t\tunsigned_value_type res = 0;",
            "\t\tnode_pointer_type cur = _root;",
            "\t\tfor (uint32_t l = 0; l < bit_num;) {",
            "\t\t\tconst uint32_t ch_idx = x & (ary - 1);",
            "\t\t\tnode_pointer_type nxt = nullptr;",
            "\t\t\tfor (int x : _ord) {",
            "\t\t\t\tif (nxt = cur->ch[ch_idx ^ x]; nxt) {",
            "\t\t\t\t\tif (nxt->siz > k)",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\tk -= nxt->siz;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tres |= nxt->val << l;",
            "\t\t\tx >>= nxt->len;",
            "\t\t\tl += nxt->len;",
            "\t\t\tcur = nxt;",
            "\t\t}",
            "\t\tbit_reverse(res);",
            "\t\treturn x_ ^ res;",
            "\t}",
            "\t// k-th largest of { x ^ v | v in S } (0-indexed)",
            "\tvalue_type xor_kth_max(unsigned_value_type x, internal_size_type k) const {",
            "\t\treturn xor_kth_min(x, _root->siz - k - 1);",
            "\t}",
            "",
            "\t// #{ v in S | x ^ v < upper }",
            "\t__attribute__((target(\"bmi\")))",
            "\tsize_type",
            "\txor_count_lt(unsigned_value_type x, unsigned_value_type upper) const {",
            "\t\tif (upper >> bit_num)",
            "\t\t\treturn _root->siz;",
            "\t\tbit_reverse(x);",
            "\t\tbit_reverse(upper);",
            "\t\tinternal_size_type res = 0;",
            "\t\tnode_pointer_type cur = _root;",
            "\t\tfor (uint32_t l = 0; l < bit_num;) {",
            "\t\t\tconst uint32_t ch_idx = x & (ary - 1);",
            "\t\t\tconst uint32_t ch_idx_r = upper & (ary - 1);",
            "\t\t\tnode_pointer_type nxt = nullptr;",
            "\t\t\tfor (uint32_t x : _ord) {",
            "\t\t\t\tnxt = cur->ch[ch_idx ^ x];",
            "\t\t\t\tif (x == ch_idx_r)",
            "\t\t\t\t\tbreak;",
            "\t\t\t\tif (nxt)",
            "\t\t\t\t\tres += nxt->siz;",
            "\t\t\t}",
            "\t\t\tif (not nxt)",
            "\t\t\t\tbreak;",
            "\t\t\tconst uint32_t len = nxt->len;",
            "\t\t\tunsigned_value_type vlo = cut_lower(x, len) ^ nxt->val, ulo = cut_lower(upper, len);",
            "\t\t\tif (vlo != ulo) {",
            "\t\t\t\tuint32_t tz = len <= 32 ? _tzcnt_u32(vlo ^ ulo) : _tzcnt_u64(vlo ^ ulo);",
            "\t\t\t\treturn (ulo >> tz) & 1 ? res + nxt->siz : res;",
            "\t\t\t}",
            "\t\t\tx >>= len;",
            "\t\t\tupper >>= len;",
            "\t\t\tl += len;",
            "\t\t\tcur = nxt;",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\t// #{ v in S | x ^ v <= upper }",
            "\tsize_type xor_count_leq(unsigned_value_type x, unsigned_value_type upper) const {",
            "\t\tif (upper == std::numeric_limits<unsigned_value_type>::max())",
            "\t\t\treturn _root->siz;",
            "\t\treturn xor_count_lt(x, upper + 1);",
            "\t}",
            "\t// #{ v in S | x ^ v >= lower }",
            "\tsize_type xor_count_geq(unsigned_value_type x, unsigned_value_type lower) const {",
            "\t\treturn _root->siz - xor_count_lt(x, lower);",
            "\t}",
            "\t// #{ v in S | x ^ v > lower }",
            "\tsize_type xor_count_gt(unsigned_value_type x, unsigned_value_type lower) const {",
            "\t\treturn _root->siz - xor_count_leq(x, lower);",
            "\t}",
            "",
            "\t// max{ x ^ v | x ^ v < upper } or std::nullopt",
            "\tstd::optional<value_type> safe_xor_max_lt(unsigned_value_type x, unsigned_value_type upper) const {",
            "\t\tinternal_size_type cnt = xor_count_lt(x, upper);",
            "\t\tif (cnt == 0)",
            "\t\t\treturn std::nullopt;",
            "\t\treturn xor_kth_min(x, cnt - 1);",
            "\t}",
            "\t// max{ x ^ v | x ^ v <= upper } or std::nullopt",
            "\tstd::optional<value_type> safe_xor_max_leq(unsigned_value_type x, unsigned_value_type upper) const {",
            "\t\tinternal_size_type cnt = xor_count_leq(x, upper);",
            "\t\tif (cnt == 0)",
            "\t\t\treturn std::nullopt;",
            "\t\treturn xor_kth_min(x, cnt - 1);",
            "\t}",
            "\t// min{ x ^ v | x ^ v >= lower } or std::nullopt",
            "\tstd::optional<value_type> safe_xor_min_geq(unsigned_value_type x, unsigned_value_type lower) const {",
            "\t\tinternal_size_type cnt = xor_count_lt(x, lower);",
            "\t\tif (cnt == _root->siz)",
            "\t\t\treturn std::nullopt;",
            "\t\treturn xor_kth_min(x, cnt);",
            "\t}",
            "\t// min{ x ^ v | x ^ v > lower } or std::nullopt",
            "\tstd::optional<value_type> safe_xor_min_gt(unsigned_value_type x, unsigned_value_type lower) const {",
            "\t\tinternal_size_type cnt = xor_count_leq(x, lower);",
            "\t\tif (cnt == _root->siz)",
            "\t\t\treturn std::nullopt;",
            "\t\treturn xor_kth_min(x, cnt);",
            "\t}",
            "",
            "\t// max{ x ^ v | x ^ v < upper } or Runtime Error",
            "\tvalue_type xor_max_lt(unsigned_value_type x, unsigned_value_type upper) const { return *safe_xor_max_lt(x, upper); }",
            "\t// max{ x ^ v | x ^ v <= upper } or Runtime Error",
            "\tvalue_type xor_max_leq(unsigned_value_type x, unsigned_value_type upper) const { return *safe_xor_max_leq(x, upper); }",
            "\t// min{ x ^ v | x ^ v >= lower } or Runtime Error",
            "\tvalue_type xor_min_geq(unsigned_value_type x, unsigned_value_type lower) const { return *safe_xor_min_geq(x, lower); }",
            "\t// min{ x ^ v | x ^ v > lower } or Runtime Error",
            "\tvalue_type xor_min_gt(unsigned_value_type x, unsigned_value_type lower) const { return *safe_xor_min_gt(x, lower); }",
            "",
            "\t// 0-indexed",
            "\tvalue_type kth_min(internal_size_type k) const { return xor_kth_min(0, k); }",
            "\t// 0-indexed",
            "\tvalue_type kth_max(internal_size_type k) const { return xor_kth_max(0, k); }",
            "\t// #{ v in S | v < upper }",
            "\tsize_type count_lt(unsigned_value_type upper) const { return xor_count_lt(0, upper); }",
            "\t// #{ v in S | v <= upper }",
            "\tsize_type count_leq(unsigned_value_type upper) const { return xor_count_leq(0, upper); }",
            "\t// #{ v in S | v >= lower }",
            "\tsize_type count_geq(unsigned_value_type lower) const { return xor_count_geq(0, lower); }",
            "\t// #{ v in S | v > lower }",
            "\tsize_type count_gt(unsigned_value_type lower) const { return xor_count_gt(0, lower); }",
            "",
            "\t// max{ v | v < upper } or std::nullopt",
            "\tstd::optional<value_type> safe_max_lt(unsigned_value_type upper) const { return safe_xor_max_lt(0, upper); }",
            "\t// max{ v | v <= upper } or std::nullopt",
            "\tstd::optional<value_type> safe_max_leq(unsigned_value_type upper) const { return safe_xor_max_leq(0, upper); }",
            "\t// min{ v | v >= lower } or std::nullopt",
            "\tstd::optional<value_type> safe_min_geq(unsigned_value_type lower) const { return safe_xor_min_geq(0, lower); }",
            "\t// min{ v | v > lower } or std::nullopt",
            "\tstd::optional<value_type> safe_min_gt(unsigned_value_type lower) const { return safe_xor_min_gt(0, lower); }",
            "",
            "\t// max{ v | v < upper } or Runtime Error",
            "\tvalue_type max_lt(unsigned_value_type upper) const { return *safe_max_lt(upper); }",
            "\t// max{ v | v <= upper } or Runtime Error",
            "\tvalue_type max_leq(unsigned_value_type upper) const { return *safe_max_leq(upper); }",
            "\t// min{ v | v >= lower } or Runtime Error",
            "\tvalue_type min_geq(unsigned_value_type lower) const { return *safe_min_geq(lower); }",
            "\t// min{ v | v > lower } or Runtime Error",
            "\tvalue_type min_gt(unsigned_value_type lower) const { return *safe_min_gt(lower); }",
            "",
            "  private:",
            "\tstatic constexpr uint32_t _ord[4]{0, 2, 1, 3};",
            "\tstatic constexpr uint32_t _rev_ord[4]{3, 1, 2, 0};",
            "\tstatic constexpr uint32_t _inv_ord[4]{0, 2, 1, 3};",
            "",
            "\tnode_pointer_type _root = node_type::new_node(0, 0, 0);",
            "",
            "\tstatic constexpr unsigned_value_type cut_lower(const unsigned_value_type &val, uint32_t r) {",
            "\t\treturn val & ((unsigned_value_type(1) << r) - 1);",
            "\t}",
            "\tstatic constexpr uint32_t bit_reverse_u32(uint32_t x) {",
            "\t\tx = (((x & 0xaaaaaaaa) >> 1) | ((x & 0x55555555) << 1));",
            "\t\tx = (((x & 0xcccccccc) >> 2) | ((x & 0x33333333) << 2));",
            "\t\tx = (((x & 0xf0f0f0f0) >> 4) | ((x & 0x0f0f0f0f) << 4));",
            "\t\tx = (((x & 0xff00ff00) >> 8) | ((x & 0x00ff00ff) << 8));",
            "\t\treturn ((x >> 16) | (x << 16));",
            "\t}",
            "\tstatic constexpr uint64_t bit_reverse_u64(uint64_t x) {",
            "\t\tx = (((x & 0xaaaaaaaaaaaaaaaa) >> 1) | ((x & 0x5555555555555555) << 1));",
            "\t\tx = (((x & 0xcccccccccccccccc) >> 2) | ((x & 0x3333333333333333) << 2));",
            "\t\tx = (((x & 0xf0f0f0f0f0f0f0f0) >> 4) | ((x & 0x0f0f0f0f0f0f0f0f) << 4));",
            "\t\tx = (((x & 0xff00ff00ff00ff00) >> 8) | ((x & 0x00ff00ff00ff00ff) << 8));",
            "\t\tx = (((x & 0xffff0000ffff0000) >> 16) | ((x & 0x0000ffff0000ffff) << 16));",
            "\t\treturn ((x >> 32) | (x << 32));",
            "\t}",
            "\tstatic constexpr void bit_reverse(unsigned_value_type &x) {",
            "\t\tif constexpr (bit_num <= 32) {",
            "\t\t\tx = bit_reverse_u32(x) >> (32 - bit_num);",
            "\t\t} else {",
            "\t\t\tx = bit_reverse_u64(x) >> (64 - bit_num);",
            "\t\t}",
            "\t}",
            "",
            "\t__attribute__((target(\"bmi\"))) bool _insert_if_absent(node_pointer_type cur, uint32_t l, unsigned_value_type val) {",
            "\t\tif (l == bit_num)",
            "\t\t\treturn false;",
            "\t\tconst uint32_t idx = val & (ary - 1);",
            "\t\tnode_pointer_type nxt = cur->ch[idx];",
            "\t\tif (not nxt) {",
            "\t\t\tcur->ch[idx] = node_type::new_node(val, bit_num - l, 1);",
            "\t\t\t++cur->siz;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tunsigned_value_type x = val ^ nxt->val;",
            "\t\tuint32_t len = nxt->len, tz = len <= 32 ? _tzcnt_u32(x) : _tzcnt_u64(x);",
            "\t\ttz -= tz & (log_ary - 1);",
            "\t\tif (tz >= len) {",
            "\t\t\tbool inserted = _insert_if_absent(nxt, l + len, val >> len);",
            "\t\t\tcur->siz += inserted;",
            "\t\t\treturn inserted;",
            "\t\t}",
            "\t\tnode_pointer_type br = node_type::new_node(cut_lower(nxt->val, tz), tz, nxt->siz + 1);",
            "\t\tcur->ch[idx] = br;",
            "\t\tnxt->val >>= tz;",
            "\t\tnxt->len -= tz;",
            "\t\tval >>= tz;",
            "\t\tbr->ch[nxt->val & (ary - 1)] = nxt;",
            "\t\tbr->ch[val & (ary - 1)] = node_type::new_node(val, bit_num - l - tz, 1);",
            "\t\t++cur->siz;",
            "\t\treturn true;",
            "\t}",
            "",
            "\t__attribute__((target(\"bmi\"))) void _insert(node_pointer_type cur, uint32_t l, unsigned_value_type val, internal_size_type num) {",
            "\t\tcur->siz += num;",
            "\t\tif (l == bit_num)",
            "\t\t\treturn;",
            "\t\tconst uint32_t idx = val & (ary - 1);",
            "\t\tnode_pointer_type nxt = cur->ch[idx];",
            "\t\tif (not nxt) {",
            "\t\t\tcur->ch[idx] = node_type::new_node(val, bit_num - l, num);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tunsigned_value_type x = val ^ nxt->val;",
            "\t\tuint32_t len = nxt->len, tz = len <= 32 ? _tzcnt_u32(x) : _tzcnt_u64(x);",
            "\t\ttz -= tz & (log_ary - 1);",
            "\t\tif (tz >= len)",
            "\t\t\treturn _insert(nxt, l + len, val >> len, num);",
            "\t\tnode_pointer_type br = node_type::new_node(cut_lower(nxt->val, tz), tz, nxt->siz + num);",
            "\t\tcur->ch[idx] = br;",
            "\t\tnxt->val >>= tz;",
            "\t\tnxt->len -= tz;",
            "\t\tval >>= tz;",
            "\t\tbr->ch[nxt->val & (ary - 1)] = nxt;",
            "\t\tbr->ch[val & (ary - 1)] = node_type::new_node(val, bit_num - l - tz, num);",
            "\t}",
            "",
            "\tbool _erase(node_pointer_type cur, internal_size_type &num, uint32_t l, unsigned_value_type val) {",
            "\t\tif (l == bit_num) {",
            "\t\t\tif (cur->siz -= num = std::min(num, cur->siz); cur->siz)",
            "\t\t\t\treturn false;",
            "\t\t\tdelete cur;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tconst uint32_t idx = val & (ary - 1);",
            "\t\tnode_pointer_type nxt = cur->ch[idx];",
            "\t\tif (not nxt or cut_lower(val ^ nxt->val, nxt->len))",
            "\t\t\treturn num = 0, false;",
            "\t\tbool deleted = _erase(nxt, num, l + nxt->len, val >> nxt->len);",
            "\t\tcur->siz -= num;",
            "\t\tif (not deleted)",
            "\t\t\treturn false;",
            "\t\tcur->ch[idx] = nullptr;",
            "\t\tif (cur == _root)",
            "\t\t\treturn false;",
            "\t\tif (cur->siz == 0) {",
            "\t\t\tdelete cur;",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tuint32_t ch_cnt = 0;",
            "\t\tnode_pointer_type ch = nullptr;",
            "\t\tfor (uint32_t i = 0; i < ary; ++i)",
            "\t\t\tif (cur->ch[i]) {",
            "\t\t\t\t++ch_cnt, ch = cur->ch[i];",
            "\t\t\t}",
            "\t\tif (ch_cnt == 1) {",
            "\t\t\tcur->val |= ch->val << cur->len;",
            "\t\t\tcur->len += ch->len;",
            "\t\t\tfor (uint32_t i = 0; i < ary; ++i)",
            "\t\t\t\tcur->ch[i] = std::exchange(ch->ch[i], nullptr);",
            "\t\t\tdelete ch;",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "};"
        ]
    },
    "dynamic_mod_binomial_with_any_mod_nyaan": {
        "prefix": "dynamic_mod_binomial_with_any_mod_nyaan",
        "body": [
            "constexpr long long safe_mod(long long x, long long m) {",
            "\tx %= m;",
            "\tif (x < 0) x += m;",
            "\treturn x;",
            "}",
            "constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "\ta = safe_mod(a, b);",
            "\tif (a == 0) return {b, 0};",
            "\tlong long s = b, t = a;",
            "\tlong long m0 = 0, m1 = 1;",
            "\twhile (t) {",
            "\t\tlong long u = s / t;",
            "\t\ts -= t * u;",
            "\t\tm0 -= m1 * u;",
            "\t\tauto tmp = s;",
            "\t\ts = t;",
            "\t\tt = tmp;",
            "\t\ttmp = m0;",
            "\t\tm0 = m1;",
            "\t\tm1 = tmp;",
            "\t}",
            "\tif (m0 < 0) m0 += b / s;",
            "\treturn {s, m0};",
            "}",
            "",
            "// (rem, mod)",
            "std::pair<long long, long long> crt(const std::vector<long long>& r, const std::vector<long long>& m) {",
            "\tassert(r.size() == m.size());",
            "\tint n = int(r.size());",
            "\tlong long r0 = 0, m0 = 1;",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tassert(1 <= m[i]);",
            "\t\tlong long r1 = safe_mod(r[i], m[i]), m1 = m[i];",
            "\t\tif (m0 < m1) {",
            "\t\t\tstd::swap(r0, r1);",
            "\t\t\tstd::swap(m0, m1);",
            "\t\t}",
            "\t\tif (m0 % m1 == 0) {",
            "\t\t\tif (r0 % m1 != r1) return {0, 0};",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tlong long g, im;",
            "\t\tstd::tie(g, im) = inv_gcd(m0, m1);",
            "\t\tlong long u1 = (m1 / g);",
            "\t\tif ((r1 - r0) % g) return {0, 0};",
            "\t\tlong long x = (r1 - r0) / g % u1 * im % u1;",
            "\t\tr0 += x * m0;",
            "\t\tm0 *= u1;",
            "\t\tif (r0 < 0) r0 += m0;",
            "\t}",
            "\treturn {r0, m0};",
            "}",
            "",
            "struct brt {",
            "\tusing u32 = unsigned int;",
            "\tusing i64 = long long;",
            "\tusing u64 = unsigned long long;",
            "\tu32 m;",
            "\tu64 im;",
            "\tbrt() : m(), im() {}",
            "\tbrt(int n) : m(n), im(u64(-1) / m + 1) {}",
            "\tconstexpr inline i64 quo(u64 n) {",
            "\t\tu64 x = u64((__uint128_t(n) * im) >> 64);",
            "\t\tu32 r = n - x * m;",
            "\t\treturn m <= r ? x - 1 : x;",
            "\t}",
            "\tconstexpr inline i64 rem(u64 n) {",
            "\t\tu64 x = u64((__uint128_t(n) * im) >> 64);",
            "\t\tu32 r = n - x * m;",
            "\t\treturn m <= r ? r + m : r;",
            "\t}",
            "\tconstexpr inline pair<i64, int> quorem(u64 n) {",
            "\t\tu64 x = u64((__uint128_t(n) * im) >> 64);",
            "\t\tu32 r = n - x * m;",
            "\t\tif (m <= r) return {x - 1, r + m};",
            "\t\treturn {x, r};",
            "\t}",
            "\tconstexpr inline i64 pow(u64 n, i64 p) {",
            "\t\tu32 a = rem(n), r = m == 1 ? 0 : 1;",
            "\t\twhile (p) {",
            "\t\t\tif (p & 1) r = rem(u64(r) * a);",
            "\t\t\ta = rem(u64(a) * a);",
            "\t\t\tp >>= 1;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "};",
            "",
            "struct ppb {",
            "\tint p, q, M;",
            "\tvector<int> fac, ifac, inv;",
            "\tint delta;",
            "\tbrt bm, bp;",
            "",
            "\tppb(int _p, int _q) : p(_p), q(_q) {",
            "\t\tassert(1 < p && p <= ((1LL << 30) - 1));",
            "\t\tassert(_q > 0);",
            "\t\tlong long m = 1;",
            "\t\twhile (_q--) {",
            "\t\t\tm *= p;",
            "\t\t\tassert(m <= ((1LL << 30) - 1));",
            "\t\t}",
            "\t\tM = m;",
            "\t\tbm = brt(M), bp = brt(p);",
            "\t\tenumerate();",
            "\t\tdelta = (p == 2 && q >= 3) ? 1 : M - 1;",
            "\t}",
            "",
            "\tvoid enumerate() {",
            "\t\tint MX = min<int>(M, 20000000 + 10);",
            "\t\tfac.resize(MX);",
            "\t\tifac.resize(MX);",
            "\t\tinv.resize(MX);",
            "\t\tfac[0] = ifac[0] = inv[0] = 1;",
            "\t\tfac[1] = ifac[1] = inv[1] = 1;",
            "\t\tfor (int i = 2; i < MX; i++) {",
            "\t\t\tif (i % p == 0) {",
            "\t\t\t\tfac[i] = fac[i - 1];",
            "\t\t\t\tfac[i + 1] = bm.rem(1LL * fac[i - 1] * (i + 1));",
            "\t\t\t\ti++;",
            "\t\t\t} else {",
            "\t\t\t\tfac[i] = bm.rem(1LL * fac[i - 1] * i);",
            "\t\t\t}",
            "\t\t}",
            "\t\tifac[MX - 1] = bm.pow(fac[MX - 1], M / p * (p - 1) - 1);",
            "\t\tfor (int i = MX - 2; i > 1; --i) {",
            "\t\t\tif (i % p == 0) {",
            "\t\t\t\tifac[i] = bm.rem(1LL * ifac[i + 1] * (i + 1));",
            "\t\t\t\tifac[i - 1] = ifac[i];",
            "\t\t\t\ti--;",
            "\t\t\t} else {",
            "\t\t\t\tifac[i] = bm.rem(1LL * ifac[i + 1] * (i + 1));",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tlong long Lucas(long long n, long long m) {",
            "\t\tint res = 1;",
            "\t\twhile (n) {",
            "\t\t\tint n0, m0;",
            "\t\t\ttie(n, n0) = bp.quorem(n);",
            "\t\t\ttie(m, m0) = bp.quorem(m);",
            "\t\t\tif (n0 < m0) return 0;",
            "\t\t\tres = bm.rem(1LL * res * fac[n0]);",
            "\t\t\tint buf = bm.rem(1LL * ifac[n0 - m0] * ifac[m0]);",
            "\t\t\tres = bm.rem(1LL * res * buf);",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "",
            "\tlong long C(long long n, long long m) {",
            "\t\tif (n < m || n < 0 || m < 0) return 0;",
            "\t\tif (q == 1) return Lucas(n, m);",
            "\t\tlong long r = n - m;",
            "\t\tint e0 = 0, eq = 0, i = 0;",
            "\t\tint res = 1;",
            "\t\twhile (n) {",
            "\t\t\tres = bm.rem(1LL * res * fac[bm.rem(n)]);",
            "\t\t\tres = bm.rem(1LL * res * ifac[bm.rem(m)]);",
            "\t\t\tres = bm.rem(1LL * res * ifac[bm.rem(r)]);",
            "\t\t\tn = bp.quo(n);",
            "\t\t\tm = bp.quo(m);",
            "\t\t\tr = bp.quo(r);",
            "\t\t\tint eps = n - m - r;",
            "\t\t\te0 += eps;",
            "\t\t\tif (e0 >= q) return 0;",
            "\t\t\tif (++i >= q) eq += eps;",
            "\t\t}",
            "\t\tif (eq & 1) res = bm.rem(1LL * res * delta);",
            "\t\tres = bm.rem(1LL * res * bm.pow(p, e0));",
            "\t\treturn res;",
            "\t}",
            "};",
            "",
            "// (M <= 1e7 and max(N) <= 1e18) or (M < 2^30 and max(N) <= 2e7)",
            "struct dynamic_binomical {",
            "\tint mod;",
            "\tvector<int> M;",
            "\tvector<ppb> cs;",
            "",
            "\tdynamic_binomical(long long md) : mod(md) {",
            "\t\tassert(1 <= md);",
            "\t\tassert(md <= ((1LL << 30) - 1));",
            "\t\tfor (int i = 2; i * i <= md; i++) {",
            "\t\t\tif (md % i == 0) {",
            "\t\t\t\tint j = 0, k = 1;",
            "\t\t\t\twhile (md % i == 0) md /= i, j++, k *= i;",
            "\t\t\t\tM.push_back(k);",
            "\t\t\t\tcs.emplace_back(i, j);",
            "\t\t\t\tassert(M.back() == cs.back().M);",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (md != 1) {",
            "\t\t\tM.push_back(md);",
            "\t\t\tcs.emplace_back(md, 1);",
            "\t\t}",
            "\t\tassert(M.size() == cs.size());",
            "\t}",
            "",
            "\tlong long C(long long n, long long m) {",
            "\t\tif (mod == 1) return 0;",
            "\t\tvector<long long> rem, d;",
            "\t\tfor (int i = 0; i < (int)cs.size(); i++) {",
            "\t\t\trem.push_back(cs[i].C(n, m));",
            "\t\t\td.push_back(M[i]);",
            "\t\t}",
            "\t\treturn crt(rem, d).first;",
            "\t}",
            "};"
        ]
    },
    "lazy_segtree_usaco": {
        "prefix": "lazy_segtree_usaco",
        "body": [
            "template <class Info, class Tag>",
            "class LazySegtree {",
            "   private:",
            "\tconst int n;",
            "\tvector<Info> tree;",
            "\tvector<Tag> lazy;",
            "",
            "\tvoid build(int v, int l, int r, const vector<Info> &a) {",
            "\t\tif (l == r) {",
            "\t\t\ttree[v] = a[l];",
            "\t\t} else {",
            "\t\t\tint m = (l + r) / 2;",
            "\t\t\tbuild(2 * v, l, m, a);",
            "\t\t\tbuild(2 * v + 1, m + 1, r, a);",
            "\t\t\ttree[v] = tree[2 * v] + tree[2 * v + 1];",
            "\t\t}",
            "\t}",
            "",
            "\tvoid apply(int v, int l, int r, const Tag &x) {",
            "\t\ttree[v].apply(x, l, r);",
            "\t\tlazy[v].apply(x);",
            "\t}",
            "",
            "\tvoid push_down(int v, int l, int r) {",
            "\t\tint m = (l + r) / 2;",
            "\t\tapply(2 * v, l, m, lazy[v]);",
            "\t\tapply(2 * v + 1, m + 1, r, lazy[v]);",
            "\t\tlazy[v] = Tag();",
            "\t}",
            "",
            "\tvoid range_update(int v, int l, int r, int ql, int qr, const Tag &x) {",
            "\t\tif (qr < l || ql > r) {",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (ql <= l && r <= qr) {",
            "\t\t\tapply(v, l, r, x);",
            "\t\t} else {",
            "\t\t\tpush_down(v, l, r);",
            "\t\t\tint m = (l + r) / 2;",
            "\t\t\trange_update(2 * v, l, m, ql, qr, x);",
            "\t\t\trange_update(2 * v + 1, m + 1, r, ql, qr, x);",
            "\t\t\ttree[v] = tree[2 * v] + tree[2 * v + 1];",
            "\t\t}",
            "\t}",
            "",
            "\tInfo range_query(int v, int l, int r, int ql, int qr) {",
            "\t\tif (qr < l || ql > r) {",
            "\t\t\treturn Info();",
            "\t\t}",
            "\t\tif (l >= ql && r <= qr) {",
            "\t\t\treturn tree[v];",
            "\t\t}",
            "\t\tpush_down(v, l, r);",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn range_query(2 * v, l, m, ql, qr) + range_query(2 * v + 1, m + 1, r, ql, qr);",
            "\t}",
            "",
            "   public:",
            "\tLazySegtree() {}",
            "",
            "\tLazySegtree(int n) : n(n) {",
            "\t\ttree.assign(4 << __lg(n), Info());",
            "\t\tlazy.assign(4 << __lg(n), Tag());",
            "\t}",
            "",
            "\tLazySegtree(const vector<Info> &a) : n(a.size()) {",
            "\t\ttree.assign(4 << __lg(n), Info());",
            "\t\tlazy.assign(4 << __lg(n), Tag());",
            "\t\tbuild(1, 0, n - 1, a);",
            "\t}",
            "",
            "\t//[ql, qr]",
            "\tvoid range_update(int ql, int qr, const Tag &x) { range_update(1, 0, n - 1, ql, qr, x); }",
            "",
            "\t// [ql, qr]",
            "\tInfo range_query(int ql, int qr) { return range_query(1, 0, n - 1, ql, qr); }",
            "};",
            "",
            "enum QueryType { ADD, SET, NONE };",
            "",
            "struct Tag {",
            "\tQueryType type = NONE;",
            "\tll val = 0;",
            "\tvoid apply(const Tag &t) {",
            "\t\tif (t.type == ADD) {",
            "\t\t\tval += t.val;",
            "\t\t\tif (type != SET) {",
            "\t\t\t\ttype = ADD;",
            "\t\t\t}",
            "\t\t} else if (t.type == SET) {",
            "\t\t\ttype = SET;",
            "\t\t\tval = t.val;",
            "\t\t}",
            "\t}",
            "};",
            "",
            "struct Info {",
            "\tll sum = 0;",
            "\tvoid apply(const Tag &t, int l, int r) {",
            "\t\tif (t.type == SET) {",
            "\t\t\tsum = t.val * (r - l + 1);",
            "\t\t} else if (t.type == ADD) {",
            "\t\t\tsum += t.val * (r - l + 1);",
            "\t\t}",
            "\t}",
            "};",
            "",
            "Info operator+(const Info &a, const Info &b) { return {a.sum + b.sum}; }"
        ]
    },
    "seg_tree_atcoder": {
        "prefix": "seg_tree_atcoder",
        "body": [
            "template <class S, auto op, auto e>",
            "struct segtree {",
            "\tstatic_assert(std::is_convertible_v<decltype(op), std::function<S(S, S)>>,",
            "\t\t\t\t  \"op must work as S(S, S)\");",
            "\tstatic_assert(std::is_convertible_v<decltype(e), std::function<S()>>,",
            "\t\t\t\t  \"e must work as S()\");",
            "",
            "  public:",
            "\tsegtree() : segtree(0) {}",
            "\texplicit segtree(int n) : segtree(std::vector<S>(n, e())) {}",
            "\texplicit segtree(const std::vector<S> &v) : _n(int(v.size())) {",
            "\t\tsize = (int)std::bit_ceil((unsigned int)(_n));",
            "\t\tlog = std::countr_zero((unsigned int)size);",
            "\t\td = std::vector<S>(2 * size, e());",
            "\t\tfor (int i = 0; i < _n; i++)",
            "\t\t\td[size + i] = v[i];",
            "\t\tfor (int i = size - 1; i >= 1; i--) {",
            "\t\t\tupdate(i);",
            "\t\t}",
            "\t}",
            "",
            "\tvoid set(int p, S x) {",
            "\t\tassert(0 <= p && p < _n);",
            "\t\tp += size;",
            "\t\td[p] = x;",
            "\t\tfor (int i = 1; i <= log; i++)",
            "\t\t\tupdate(p >> i);",
            "\t}",
            "",
            "\tS get(int p) const {",
            "\t\tassert(0 <= p && p < _n);",
            "\t\treturn d[p + size];",
            "\t}",
            "\tS query(int l, int r) const {",
            "\t\tassert(0 <= l && l <= r && r <= _n);",
            "\t\tS sml = e(), smr = e();",
            "\t\tl += size;",
            "\t\tr += size;",
            "",
            "\t\twhile (l < r) {",
            "\t\t\tif (l & 1)",
            "\t\t\t\tsml = op(sml, d[l++]);",
            "\t\t\tif (r & 1)",
            "\t\t\t\tsmr = op(d[--r], smr);",
            "\t\t\tl >>= 1;",
            "\t\t\tr >>= 1;",
            "\t\t}",
            "\t\treturn op(sml, smr);",
            "\t}",
            "",
            "\tS query_all() const { return d[1]; }",
            "",
            "\ttemplate <bool (*f)(S)>",
            "\tint max_right(int l) const {",
            "\t\treturn max_right(l, [](S x) { return f(x); });",
            "\t}",
            "",
            "\ttemplate <class F>",
            "\tint max_right(int l, F f) const {",
            "\t\tassert(0 <= l && l <= _n);",
            "\t\tassert(f(e()));",
            "\t\tif (l == _n)",
            "\t\t\treturn _n;",
            "\t\tl += size;",
            "\t\tS sm = e();",
            "\t\tdo {",
            "\t\t\twhile (l % 2 == 0)",
            "\t\t\t\tl >>= 1;",
            "\t\t\tif (!f(op(sm, d[l]))) {",
            "\t\t\t\twhile (l < size) {",
            "\t\t\t\t\tl = (2 * l);",
            "\t\t\t\t\tif (f(op(sm, d[l]))) {",
            "\t\t\t\t\t\tsm = op(sm, d[l]);",
            "\t\t\t\t\t\tl++;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\treturn l - size;",
            "\t\t\t}",
            "\t\t\tsm = op(sm, d[l]);",
            "\t\t\tl++;",
            "\t\t} while ((l & -l) != l);",
            "\t\treturn _n;",
            "\t}",
            "",
            "\ttemplate <bool (*f)(S)>",
            "\tint min_left(int r) const {",
            "\t\treturn min_left(r, [](S x) { return f(x); });",
            "\t}",
            "\ttemplate <class F>",
            "\tint min_left(int r, F f) const {",
            "\t\tassert(0 <= r && r <= _n);",
            "\t\tassert(f(e()));",
            "\t\tif (r == 0)",
            "\t\t\treturn 0;",
            "\t\tr += size;",
            "\t\tS sm = e();",
            "\t\tdo {",
            "\t\t\tr--;",
            "\t\t\twhile (r > 1 && (r % 2))",
            "\t\t\t\tr >>= 1;",
            "\t\t\tif (!f(op(d[r], sm))) {",
            "\t\t\t\twhile (r < size) {",
            "\t\t\t\t\tr = (2 * r + 1);",
            "\t\t\t\t\tif (f(op(d[r], sm))) {",
            "\t\t\t\t\t\tsm = op(d[r], sm);",
            "\t\t\t\t\t\tr--;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\treturn r + 1 - size;",
            "\t\t\t}",
            "\t\t\tsm = op(d[r], sm);",
            "\t\t} while ((r & -r) != r);",
            "\t\treturn 0;",
            "\t}",
            "",
            "  private:",
            "\tint _n, size, log;",
            "\tstd::vector<S> d;",
            "",
            "\tvoid update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
            "};"
        ]
    },
    "diff_array": {
        "prefix": "diff_array",
        "body": [
            "template <typename T>",
            "class diff_array {",
            "  private:",
            "\tconst int sz;",
            "\tvector<T> tree;",
            "\tvector<T> lazy;",
            "",
            "\tvoid apply(int v, int len, T add) {",
            "\t\ttree[v] += add * len;",
            "\t\tlazy[v] += add;",
            "\t}",
            "",
            "\tvoid push_down(int v, int l, int r) {",
            "\t\tint m = (l + r) / 2;",
            "\t\tapply(2 * v, m - l + 1, lazy[v]);",
            "\t\tapply(2 * v + 1, r - m, lazy[v]);",
            "\t\tlazy[v] = 0;",
            "\t}",
            "",
            "\tvoid range_add(int v, int l, int r, int ql, int qr, int add) {",
            "\t\tif (qr < l || ql > r) {",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (ql <= l && r <= qr) {",
            "\t\t\tapply(v, r - l + 1, add);",
            "\t\t} else {",
            "\t\t\tpush_down(v, l, r);",
            "\t\t\tint m = (l + r) / 2;",
            "\t\t\trange_add(2 * v, l, m, ql, qr, add);",
            "\t\t\trange_add(2 * v + 1, m + 1, r, ql, qr, add);",
            "\t\t\ttree[v] = tree[2 * v] + tree[2 * v + 1];",
            "\t\t}",
            "\t}",
            "",
            "\tT range_sum(int v, int l, int r, int ql, int qr) {",
            "\t\tif (qr < l || ql > r) {",
            "\t\t\treturn 0;",
            "\t\t}",
            "\t\tif (ql <= l && r <= qr) {",
            "\t\t\treturn tree[v];",
            "\t\t}",
            "\t\tpush_down(v, l, r);",
            "\t\tint m = (l + r) / 2;",
            "\t\treturn range_sum(2 * v, l, m, ql, qr) + range_sum(2 * v + 1, m + 1, r, ql, qr);",
            "\t}",
            "",
            "  public:",
            "\tdiff_array(int n) : sz(n), tree(4 * n), lazy(4 * n) {}",
            "",
            "\tvoid range_add(int ql, int qr, int add) { range_add(1, 0, sz - 1, ql, qr, add); }",
            "",
            "\tT range_sum(int ql, int qr) { return range_sum(1, 0, sz - 1, ql, qr); }",
            "};"
        ]
    },
    "gen_ncr_table_modint_arbitrary": {
        "prefix": "gen_ncr_table_modint_arbitrary",
        "body": [
            "class modint {",
            "\tusing mint = modint;",
            "",
            "   public:",
            "\tstatic int& mod() {",
            "\t\tstatic int mod_ = 1;",
            "\t\treturn mod_;",
            "\t}",
            "",
            "\tstatic void set_mod(int mod_) {",
            "\t\tassert(mod_ > 0);",
            "\t\tmod() = mod_;",
            "\t}",
            "",
            "\tmodint(long long y = 0) : x(y >= 0 ? y % mod() : (y % mod() + mod()) % mod()) {}",
            "",
            "\tint val() const { return x; }",
            "",
            "\tmint& operator+=(const mint& r) {",
            "\t\tif ((x += r.x) >= mod()) x -= mod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator-=(const mint& r) {",
            "\t\tif ((x += mod() - r.x) >= mod()) x -= mod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator*=(const mint& r) {",
            "\t\tx = static_cast<int>(1LL * x * r.x % mod());",
            "\t\treturn *this;",
            "\t}",
            "\tmint& operator/=(const mint& r) { return *this *= r.inv(); }",
            "",
            "\tbool operator==(const mint& r) const { return x == r.x; }",
            "",
            "\tmint operator+() const { return *this; }",
            "\tmint operator-() const { return mint(-x); }",
            "",
            "\tfriend mint operator+(const mint& l, const mint& r) { return mint(l) += r; }",
            "\tfriend mint operator-(const mint& l, const mint& r) { return mint(l) -= r; }",
            "\tfriend mint operator*(const mint& l, const mint& r) { return mint(l) *= r; }",
            "\tfriend mint operator/(const mint& l, const mint& r) { return mint(l) /= r; }",
            "",
            "\tmint inv() const {",
            "\t\tint a = x, b = mod(), u = 1, v = 0;",
            "\t\twhile (b > 0) {",
            "\t\t\tint t = a / b;",
            "\t\t\tstd::swap(a -= t * b, b);",
            "\t\t\tstd::swap(u -= t * v, v);",
            "\t\t}",
            "\t\treturn mint(u);",
            "\t}",
            "",
            "\tmint pow(long long n) const {",
            "\t\tmint ret(1), mul(x);",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1) ret *= mul;",
            "\t\t\tmul *= mul;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tfriend std::ostream& operator<<(std::ostream& os, const mint& r) { return os << r.x; }",
            "",
            "\tfriend std::istream& operator>>(std::istream& is, mint& r) {",
            "\t\tlong long t;",
            "\t\tis >> t;",
            "\t\tr = mint(t);",
            "\t\treturn is;",
            "\t}",
            "",
            "   private:",
            "\tint x;",
            "};",
            "",
            "std::vector<bool> prime_table(int n) {",
            "\tstd::vector<bool> prime(n + 1, true);",
            "\tprime[0] = prime[1] = false;",
            "\tfor (int j = 4; j <= n; j += 2) prime[j] = false;",
            "\tfor (int i = 3; i * i <= n; i += 2) {",
            "\t\tif (!prime[i]) continue;",
            "\t\tfor (int j = i * i; j <= n; j += 2 * i) prime[j] = false;",
            "\t}",
            "\treturn prime;",
            "}",
            "",
            "template <typename mint>",
            "std::vector<mint> gen_ncr_modint(int n) {",
            "\tif (n == 0) return {1};",
            "\tconst int m = mint::mod();",
            "",
            "\tauto is_prime = prime_table(n);",
            "\tstd::vector<int> prime;",
            "\tfor (int i = 2; i <= n; ++i) {",
            "\t\tif (is_prime[i]) {",
            "\t\t\tprime.push_back(i);",
            "\t\t}",
            "\t}",
            "",
            "\tint l = 0;",
            "\tstd::vector<int> maxfact(n + 1, -1);",
            "\tstd::vector<int> ps;",
            "\tfor (int p : prime) {",
            "\t\tif (m % p == 0) {",
            "\t\t\tps.push_back(p);",
            "\t\t\tfor (int i = p; i <= n; i += p) {",
            "\t\t\t\tmaxfact[i] = l;",
            "\t\t\t}",
            "\t\t\t++l;",
            "\t\t}",
            "\t}",
            "",
            "\tstd::vector<std::vector<mint>> pow(l);",
            "\tfor (int i = 0; i < l; ++i) {",
            "\t\tpow[i].resize(n / (ps[i] - 1) + 1);",
            "\t\tpow[i][0] = 1;",
            "\t\tfor (int j = 1; j < (int)pow[i].size(); ++j) {",
            "\t\t\tpow[i][j] = pow[i][j - 1] * ps[i];",
            "\t\t}",
            "\t}",
            "",
            "\tstd::vector<mint> comb(n + 1);",
            "\tcomb[0] = 1;",
            "\tmint s = 1;",
            "\tstd::vector<int> t(l);",
            "\tfor (int k = 1; k <= n; ++k) {",
            "\t\tint den = k;",
            "\t\twhile (maxfact[den] != -1) {",
            "\t\t\t--t[maxfact[den]];",
            "\t\t\tden /= ps[maxfact[den]];",
            "\t\t}",
            "\t\tint num = n - k + 1;",
            "\t\twhile (maxfact[num] != -1) {",
            "\t\t\t++t[maxfact[num]];",
            "\t\t\tnum /= ps[maxfact[num]];",
            "\t\t}",
            "\t\ts = s / den * num;",
            "\t\tcomb[k] = s;",
            "\t\tfor (int i = 0; i < l; ++i) {",
            "\t\t\tcomb[k] *= pow[i][t[i]];",
            "\t\t}",
            "\t}",
            "",
            "\treturn comb;",
            "}"
        ]
    },
    "gen_random_number": {
        "prefix": "gen_random_number",
        "body": [
            "uint64_t random_address() {",
            "\tchar *p = new char;",
            "\tdelete p;",
            "\treturn uint64_t(p);",
            "}",
            "mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count() * (random_address() | 1));",
            "",
            "// Uniformly distributed real number in [a, b).",
            "double real_rng(double a = 0, double b = 1) {",
            "\tassert(a <= b);",
            "\treturn uniform_real_distribution<double>(a, b)(rng);",
            "}",
            "",
            "// Uniformly distributed integer in [a, b].",
            "int64_t unif_rng(int64_t a, int64_t b) {",
            "\tassert(a <= b);",
            "\treturn uniform_int_distribution<int64_t>(a, b)(rng);",
            "}"
        ]
    },
    "dynamic_modint_simple": {
        "prefix": "dynamic_modint_simple",
        "body": [
            "class modint {",
            "\tusing mint = modint;",
            "",
            "  public:",
            "\tstatic int &mod() {",
            "\t\tstatic int mod_ = 1;",
            "\t\treturn mod_;",
            "\t}",
            "",
            "\tstatic void set_mod(int mod_) {",
            "\t\tassert(mod_ > 0);",
            "\t\tmod() = mod_;",
            "\t}",
            "",
            "\tmodint(long long y = 0) : x(y >= 0 ? y % mod() : (y % mod() + mod()) % mod()) {}",
            "",
            "\tint val() const { return x; }",
            "",
            "\tmint &operator+=(const mint &r) {",
            "\t\tif ((x += r.x) >= mod())",
            "\t\t\tx -= mod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &r) {",
            "\t\tif ((x += mod() - r.x) >= mod())",
            "\t\t\tx -= mod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &r) {",
            "\t\tx = static_cast<int>(1LL * x * r.x % mod());",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &r) { return *this *= r.inv(); }",
            "",
            "\tbool operator==(const mint &r) const { return x == r.x; }",
            "",
            "\tmint operator+() const { return *this; }",
            "\tmint operator-() const { return mint(-x); }",
            "",
            "\tfriend mint operator+(const mint &l, const mint &r) { return mint(l) += r; }",
            "\tfriend mint operator-(const mint &l, const mint &r) { return mint(l) -= r; }",
            "\tfriend mint operator*(const mint &l, const mint &r) { return mint(l) *= r; }",
            "\tfriend mint operator/(const mint &l, const mint &r) { return mint(l) /= r; }",
            "",
            "\tmint inv() const {",
            "\t\tint a = x, b = mod(), u = 1, v = 0;",
            "\t\twhile (b > 0) {",
            "\t\t\tint t = a / b;",
            "\t\t\tstd::swap(a -= t * b, b);",
            "\t\t\tstd::swap(u -= t * v, v);",
            "\t\t}",
            "\t\treturn mint(u);",
            "\t}",
            "",
            "\tmint pow(long long n) const {",
            "\t\tmint ret(1), mul(x);",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1)",
            "\t\t\t\tret *= mul;",
            "\t\t\tmul *= mul;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tfriend std::ostream &operator<<(std::ostream &os, const mint &r) { return os << r.x; }",
            "",
            "\tfriend std::istream &operator>>(std::istream &is, mint &r) {",
            "\t\tlong long t;",
            "\t\tis >> t;",
            "\t\tr = mint(t);",
            "\t\treturn is;",
            "\t}",
            "",
            "  private:",
            "\tint x;",
            "};"
        ]
    },
    "atcoder_static_mint": {
        "prefix": "atcoder_static_mint",
        "body": [
            "namespace internal {",
            "\ttemplate <class T>",
            "\tusing is_signed_int128 =",
            "\t\ttypename std::conditional<std::is_same<T, __int128_t>::value || std::is_same<T, __int128>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int128 =",
            "\t\ttypename std::conditional<std::is_same<T, __uint128_t>::value || std::is_same<T, unsigned __int128>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_integral = typename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value ||",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t  is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_signed_int =",
            "\t\ttypename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) || is_signed_int128<T>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int =",
            "\t\ttypename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) || is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "\tconstexpr long long safe_mod(long long x, long long m) {",
            "\t\tx %= m;",
            "\t\tif (x < 0) x += m;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {",
            "\t\tif (m == 1) return 0;",
            "\t\tunsigned int _m = (unsigned int)(m);",
            "\t\tunsigned long long r = 1;",
            "\t\tunsigned long long y = safe_mod(x, m);",
            "\t\twhile (n) {",
            "\t\t\tif (n & 1) r = (r * y) % _m;",
            "\t\t\ty = (y * y) % _m;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "",
            "\tconstexpr bool is_prime_constexpr(int n) {",
            "\t\tif (n <= 1) return false;",
            "\t\tif (n == 2 || n == 7 || n == 61) return true;",
            "\t\tif (n % 2 == 0) return false;",
            "\t\tlong long d = n - 1;",
            "\t\twhile (d % 2 == 0) d /= 2;",
            "\t\tconstexpr long long bases[3] = {2, 7, 61};",
            "\t\tfor (long long a : bases) {",
            "\t\t\tlong long t = d;",
            "\t\t\tlong long y = pow_mod_constexpr(a, t, n);",
            "\t\t\twhile (t != n - 1 && y != 1 && y != n - 1) {",
            "\t\t\t\ty = y * y % n;",
            "\t\t\t\tt <<= 1;",
            "\t\t\t}",
            "\t\t\tif (y != n - 1 && t % 2 == 0) {",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\ttemplate <int n>",
            "\tconstexpr bool is_prime = is_prime_constexpr(n);",
            "\tconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "\t\ta = safe_mod(a, b);",
            "\t\tif (a == 0) return {b, 0};",
            "\t\tlong long s = b, t = a;",
            "\t\tlong long m0 = 0, m1 = 1;",
            "",
            "\t\twhile (t) {",
            "\t\t\tlong long u = s / t;",
            "\t\t\ts -= t * u;",
            "\t\t\tm0 -= m1 * u;",
            "\t\t\tauto tmp = s;",
            "\t\t\ts = t;",
            "\t\t\tt = tmp;",
            "\t\t\ttmp = m0;",
            "\t\t\tm0 = m1;",
            "\t\t\tm1 = tmp;",
            "\t\t}",
            "\t\tif (m0 < 0) m0 += b / s;",
            "\t\treturn {s, m0};",
            "\t}",
            "",
            "\tstruct modint_base {};",
            "\tstruct static_modint_base : modint_base {};",
            "",
            "}  // namespace internal",
            "",
            "template <int m, std::enable_if_t<(1 <= m)> * = nullptr>",
            "struct static_modint : internal::static_modint_base {",
            "\tusing mint = static_modint;",
            "",
            "   public:",
            "\tstatic constexpr int mod() { return m; }",
            "\tstatic mint raw(int v) {",
            "\t\tmint x;",
            "\t\tx._v = v;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tstatic_modint() : _v(0) {}",
            "\ttemplate <class T, internal::is_signed_int_t<T> * = nullptr>",
            "\tstatic_modint(T v) {",
            "\t\tlong long x = (long long)(v % (long long)(umod()));",
            "\t\tif (x < 0) x += umod();",
            "\t\t_v = (unsigned int)(x);",
            "\t}",
            "\ttemplate <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "\tstatic_modint(T v) {",
            "\t\t_v = (unsigned int)(v % umod());",
            "\t}",
            "",
            "\tunsigned int val() const { return _v; }",
            "",
            "\tmint &operator++() {",
            "\t\t_v++;",
            "\t\tif (_v == umod()) _v = 0;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator--() {",
            "\t\tif (_v == 0) _v = umod();",
            "\t\t_v--;",
            "\t\treturn *this;",
            "\t}",
            "\tmint operator++(int) {",
            "\t\tmint result = *this;",
            "\t\t++*this;",
            "\t\treturn result;",
            "\t}",
            "\tmint operator--(int) {",
            "\t\tmint result = *this;",
            "\t\t--*this;",
            "\t\treturn result;",
            "\t}",
            "",
            "\tmint &operator+=(const mint &rhs) {",
            "\t\t_v += rhs._v;",
            "\t\tif (_v >= umod()) _v -= umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &rhs) {",
            "\t\t_v -= rhs._v;",
            "\t\tif (_v >= umod()) _v += umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &rhs) {",
            "\t\tunsigned long long z = _v;",
            "\t\tz *= rhs._v;",
            "\t\t_v = (unsigned int)(z % umod());",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "\tmint operator+() const { return *this; }",
            "\tmint operator-() const { return mint() - *this; }",
            "",
            "\tmint pow(long long n) const {",
            "\t\tassert(0 <= n);",
            "\t\tmint x = *this, r = 1;",
            "\t\twhile (n) {",
            "\t\t\tif (n & 1) r *= x;",
            "\t\t\tx *= x;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "\tmint inv() const {",
            "\t\tif (prime) {",
            "\t\t\tassert(_v);",
            "\t\t\treturn pow(umod() - 2);",
            "\t\t} else {",
            "\t\t\tauto eg = internal::inv_gcd(_v, m);",
            "\t\t\tassert(eg.first == 1);",
            "\t\t\treturn eg.second;",
            "\t\t}",
            "\t}",
            "",
            "\tfriend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "\tfriend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "\tfriend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "\tfriend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "\tfriend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "\tfriend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "",
            "   private:",
            "\tunsigned int _v;",
            "\tstatic constexpr unsigned int umod() { return m; }",
            "\tstatic constexpr bool prime = internal::is_prime<m>;",
            "};",
            "template <int md>",
            "std::ostream &operator<<(std::ostream &os, const static_modint<md> &x) {",
            "\treturn os << x.val();",
            "}",
            "",
            "// using mint = static_modint<998244353>;",
            "using mint = static_modint<1000'000'007>;"
        ]
    },
    "atcoder_dynamic_modint": {
        "prefix": "atcoder_dynamic_modint",
        "body": [
            "namespace internal {",
            "\ttemplate <class T>",
            "\tusing is_signed_int128 =",
            "\t\ttypename std::conditional<std::is_same<T, __int128_t>::value || std::is_same<T, __int128>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int128 =",
            "\t\ttypename std::conditional<std::is_same<T, __uint128_t>::value || std::is_same<T, unsigned __int128>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_integral = typename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value ||",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t  is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_signed_int =",
            "\t\ttypename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) || is_signed_int128<T>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int =",
            "\t\ttypename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) || is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "\tconstexpr long long safe_mod(long long x, long long m) {",
            "\t\tx %= m;",
            "\t\tif (x < 0) x += m;",
            "\t\treturn x;",
            "\t}",
            "\tstruct barrett {",
            "\t\tunsigned int _m;",
            "\t\tunsigned long long im;",
            "\t\texplicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "\t\tunsigned int umod() const { return _m; }",
            "\t\tunsigned int mul(unsigned int a, unsigned int b) const {",
            "\t\t\tunsigned long long z = a;",
            "\t\t\tz *= b;",
            "\t\t\tunsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "\t\t\tunsigned long long y = x * _m;",
            "\t\t\treturn (unsigned int)(z - y + (z < y ? _m : 0));",
            "\t\t}",
            "\t};",
            "",
            "\tconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "\t\ta = safe_mod(a, b);",
            "\t\tif (a == 0) return {b, 0};",
            "\t\tlong long s = b, t = a;",
            "\t\tlong long m0 = 0, m1 = 1;",
            "",
            "\t\twhile (t) {",
            "\t\t\tlong long u = s / t;",
            "\t\t\ts -= t * u;",
            "\t\t\tm0 -= m1 * u;",
            "\t\t\tauto tmp = s;",
            "\t\t\ts = t;",
            "\t\t\tt = tmp;",
            "\t\t\ttmp = m0;",
            "\t\t\tm0 = m1;",
            "\t\t\tm1 = tmp;",
            "\t\t}",
            "\t\tif (m0 < 0) m0 += b / s;",
            "\t\treturn {s, m0};",
            "\t}",
            "",
            "\tstruct modint_base {};",
            "}  // namespace internal",
            "",
            "template <int id>",
            "struct dynamic_modint : internal::modint_base {",
            "\tusing mint = dynamic_modint;",
            "",
            "   public:",
            "\tstatic int mod() { return (int)(bt.umod()); }",
            "",
            "\tstatic void set_mod(int m) {",
            "\t\tassert(1 <= m);",
            "\t\tbt = internal::barrett(m);",
            "\t}",
            "",
            "\tstatic mint raw(int v) {",
            "\t\tmint x;",
            "\t\tx._v = v;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tdynamic_modint() : _v(0) {}",
            "",
            "\ttemplate <class T, internal::is_signed_int_t<T> * = nullptr>",
            "\tdynamic_modint(T v) {",
            "\t\tlong long x = (long long)(v % (long long)(mod()));",
            "\t\tif (x < 0) x += mod();",
            "\t\t_v = (unsigned int)(x);",
            "\t}",
            "",
            "\ttemplate <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "\tdynamic_modint(T v) {",
            "\t\t_v = (unsigned int)(v % mod());",
            "\t}",
            "",
            "\tunsigned int val() const { return _v; }",
            "",
            "\tmint &operator++() {",
            "\t\t_v++;",
            "\t\tif (_v == umod()) _v = 0;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator--() {",
            "\t\tif (_v == 0) _v = umod();",
            "\t\t_v--;",
            "\t\treturn *this;",
            "\t}",
            "\tmint operator++(int) {",
            "\t\tmint result = *this;",
            "\t\t++*this;",
            "\t\treturn result;",
            "\t}",
            "\tmint operator--(int) {",
            "\t\tmint result = *this;",
            "\t\t--*this;",
            "\t\treturn result;",
            "\t}",
            "",
            "\tmint &operator+=(const mint &rhs) {",
            "\t\t_v += rhs._v;",
            "\t\tif (_v >= umod()) _v -= umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &rhs) {",
            "\t\t_v += mod() - rhs._v;",
            "\t\tif (_v >= umod()) _v -= umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &rhs) {",
            "\t\t_v = bt.mul(_v, rhs._v);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "\tmint operator+() const { return *this; }",
            "\tmint operator-() const { return mint() - *this; }",
            "",
            "\tmint pow(long long n) const {",
            "\t\tassert(0 <= n);",
            "\t\tmint x = *this, r = 1;",
            "\t\twhile (n) {",
            "\t\t\tif (n & 1) r *= x;",
            "\t\t\tx *= x;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "\tmint inv() const {",
            "\t\tauto eg = internal::inv_gcd(_v, mod());",
            "\t\tassert(eg.first == 1);",
            "\t\treturn eg.second;",
            "\t}",
            "",
            "\tfriend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "\tfriend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "\tfriend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "\tfriend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "\tfriend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "\tfriend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "",
            "   private:",
            "\tunsigned int _v;",
            "\tstatic internal::barrett bt;",
            "\tstatic unsigned int umod() { return bt.umod(); }",
            "};",
            "template <int id>",
            "internal::barrett dynamic_modint<id>::bt(998244353);",
            "",
            "",
            "template <int id>",
            "std::ostream &operator<<(std::ostream &os, const dynamic_modint<id> &x) {",
            "\treturn os << x.val();",
            "}",
            "",
            "using modint = dynamic_modint<-1>;"
        ]
    },
    "dynamic_modint_64bit_mod_using_montogomery_nyaan": {
        "prefix": "dynamic_modint_64bit_mod_using_montogomery_nyaan",
        "body": [
            "template <typename Int, typename UInt, typename Long, typename ULong, int id>",
            "struct dynamic_modint_m {",
            "\tusing mint = dynamic_modint_m;",
            "",
            "\tinline static UInt mod;",
            "\tinline static UInt r;",
            "\tinline static UInt n2;",
            "\tstatic constexpr int bit_length = sizeof(UInt) * 8;",
            "",
            "\tstatic UInt get_r() {",
            "\t\tUInt ret = mod;",
            "\t\twhile (mod * ret != 1) ret *= UInt(2) - mod * ret;",
            "\t\treturn ret;",
            "\t}",
            "\tstatic void set_mod(UInt m) {",
            "\t\tassert(m < (UInt(1u) << (bit_length - 2)));",
            "\t\tassert((m & 1) == 1);",
            "\t\tmod = m, n2 = -ULong(m) % m, r = get_r();",
            "\t}",
            "\tUInt a;",
            "",
            "\tdynamic_modint_m() : a(0) {}",
            "\tdynamic_modint_m(const Long &b) : a(reduce(ULong(b % mod + mod) * n2)) {};",
            "",
            "\tstatic UInt reduce(const ULong &b) { return (b + ULong(UInt(b) * UInt(-r)) * mod) >> bit_length; }",
            "",
            "\tmint &operator+=(const mint &b) {",
            "\t\tif (Int(a += b.a - 2 * mod) < 0) a += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &b) {",
            "\t\tif (Int(a -= b.a) < 0) a += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &b) {",
            "\t\ta = reduce(ULong(a) * b.a);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &b) {",
            "\t\t*this *= b.inverse();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tmint operator+(const mint &b) const { return mint(*this) += b; }",
            "\tmint operator-(const mint &b) const { return mint(*this) -= b; }",
            "\tmint operator*(const mint &b) const { return mint(*this) *= b; }",
            "\tmint operator/(const mint &b) const { return mint(*this) /= b; }",
            "",
            "\tbool operator==(const mint &b) const { return (a >= mod ? a - mod : a) == (b.a >= mod ? b.a - mod : b.a); }",
            "\tbool operator!=(const mint &b) const { return (a >= mod ? a - mod : a) != (b.a >= mod ? b.a - mod : b.a); }",
            "\tmint operator-() const { return mint(0) - mint(*this); }",
            "\tmint operator+() const { return mint(*this); }",
            "",
            "\tmint pow(ULong n) const {",
            "\t\tmint ret(1), mul(*this);",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1) ret *= mul;",
            "\t\t\tmul *= mul, n >>= 1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tfriend ostream &operator<<(ostream &os, const mint &b) { return os << b.get(); }",
            "",
            "\tmint inverse() const {",
            "\t\tInt x = get(), y = get_mod(), u = 1, v = 0;",
            "\t\twhile (y > 0) {",
            "\t\t\tInt t = x / y;",
            "\t\t\tswap(x -= t * y, y);",
            "\t\t\tswap(u -= t * v, v);",
            "\t\t}",
            "\t\treturn mint{u};",
            "\t}",
            "",
            "\tUInt get() const {",
            "\t\tUInt ret = reduce(a);",
            "\t\treturn ret >= mod ? ret - mod : ret;",
            "\t}",
            "",
            "\tstatic UInt get_mod() { return mod; }",
            "};",
            "",
            "template <int id>",
            "using dynamic_modint64 = dynamic_modint_m<long long, unsigned long long, __int128_t, __uint128_t, id>;",
            "",
            "using modint = dynamic_modint64<-1>;"
        ]
    },
    "dynamic_modint_32bit_mod_using_montgomery_nyaan": {
        "prefix": "dynamic_modint_32bit_mod_using_montgomery_nyaan",
        "body": [
            "template <typename Int, typename UInt, typename Long, typename ULong, int id>",
            "struct dynamic_modint_m {",
            "\tusing mint = dynamic_modint_m;",
            "",
            "\tinline static UInt mod;",
            "\tinline static UInt r;",
            "\tinline static UInt n2;",
            "\tstatic constexpr int bit_length = sizeof(UInt) * 8;",
            "",
            "\tstatic UInt get_r() {",
            "\t\tUInt ret = mod;",
            "\t\twhile (mod * ret != 1) ret *= UInt(2) - mod * ret;",
            "\t\treturn ret;",
            "\t}",
            "\tstatic void set_mod(UInt m) {",
            "\t\tassert(m < (UInt(1u) << (bit_length - 2)));",
            "\t\tassert((m & 1) == 1);",
            "\t\tmod = m, n2 = -ULong(m) % m, r = get_r();",
            "\t}",
            "\tUInt a;",
            "",
            "\tdynamic_modint_m() : a(0) {}",
            "\tdynamic_modint_m(const Long &b) : a(reduce(ULong(b % mod + mod) * n2)) {};",
            "",
            "\tstatic UInt reduce(const ULong &b) { return (b + ULong(UInt(b) * UInt(-r)) * mod) >> bit_length; }",
            "",
            "\tmint &operator+=(const mint &b) {",
            "\t\tif (Int(a += b.a - 2 * mod) < 0) a += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &b) {",
            "\t\tif (Int(a -= b.a) < 0) a += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &b) {",
            "\t\ta = reduce(ULong(a) * b.a);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &b) {",
            "\t\t*this *= b.inverse();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tmint operator+(const mint &b) const { return mint(*this) += b; }",
            "\tmint operator-(const mint &b) const { return mint(*this) -= b; }",
            "\tmint operator*(const mint &b) const { return mint(*this) *= b; }",
            "\tmint operator/(const mint &b) const { return mint(*this) /= b; }",
            "",
            "\tbool operator==(const mint &b) const { return (a >= mod ? a - mod : a) == (b.a >= mod ? b.a - mod : b.a); }",
            "\tbool operator!=(const mint &b) const { return (a >= mod ? a - mod : a) != (b.a >= mod ? b.a - mod : b.a); }",
            "\tmint operator-() const { return mint(0) - mint(*this); }",
            "\tmint operator+() const { return mint(*this); }",
            "",
            "\tmint pow(ULong n) const {",
            "\t\tmint ret(1), mul(*this);",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1) ret *= mul;",
            "\t\t\tmul *= mul, n >>= 1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tfriend ostream &operator<<(ostream &os, const mint &b) { return os << b.get(); }",
            "",
            "\tmint inverse() const {",
            "\t\tInt x = get(), y = get_mod(), u = 1, v = 0;",
            "\t\twhile (y > 0) {",
            "\t\t\tInt t = x / y;",
            "\t\t\tswap(x -= t * y, y);",
            "\t\t\tswap(u -= t * v, v);",
            "\t\t}",
            "\t\treturn mint{u};",
            "\t}",
            "",
            "\tUInt get() const {",
            "\t\tUInt ret = reduce(a);",
            "\t\treturn ret >= mod ? ret - mod : ret;",
            "\t}",
            "",
            "\tstatic UInt get_mod() { return mod; }",
            "};",
            "",
            "template <int id>",
            "using dynamic_modint32 = dynamic_modint_m<int, unsigned int, long long, unsigned long long, id>;",
            "",
            "using modint = dynamic_modint32<-1>;"
        ]
    },
    "static_modint_simple": {
        "prefix": "static_modint_simple",
        "body": [
            "template <int m> class static_modint {",
            "\tusing mint = static_modint;",
            "\tstatic_assert(m > 0, \"Modulus must be positive\");",
            "",
            "  public:",
            "\tstatic constexpr int mod() { return m; }",
            "",
            "\tconstexpr static_modint(long long y = 0) : x(y >= 0 ? y % m : (y % m + m) % m) {}",
            "",
            "\tconstexpr int val() const { return x; }",
            "",
            "\tconstexpr mint &operator+=(const mint &r) {",
            "\t\tif ((x += r.x) >= m)",
            "\t\t\tx -= m;",
            "\t\treturn *this;",
            "\t}",
            "\tconstexpr mint &operator-=(const mint &r) {",
            "\t\tif ((x += m - r.x) >= m)",
            "\t\t\tx -= m;",
            "\t\treturn *this;",
            "\t}",
            "\tconstexpr mint &operator*=(const mint &r) {",
            "\t\tx = static_cast<int>(1LL * x * r.x % m);",
            "\t\treturn *this;",
            "\t}",
            "\tconstexpr mint &operator/=(const mint &r) { return *this *= r.inv(); }",
            "",
            "\tconstexpr bool operator==(const mint &r) const { return x == r.x; }",
            "",
            "\tconstexpr mint operator+() const { return *this; }",
            "\tconstexpr mint operator-() const { return mint(-x); }",
            "",
            "\tconstexpr friend mint operator+(const mint &l, const mint &r) { return mint(l) += r; }",
            "\tconstexpr friend mint operator-(const mint &l, const mint &r) { return mint(l) -= r; }",
            "\tconstexpr friend mint operator*(const mint &l, const mint &r) { return mint(l) *= r; }",
            "\tconstexpr friend mint operator/(const mint &l, const mint &r) { return mint(l) /= r; }",
            "",
            "\tconstexpr mint inv() const {",
            "\t\tint a = x, b = m, u = 1, v = 0;",
            "\t\twhile (b > 0) {",
            "\t\t\tint t = a / b;",
            "\t\t\tstd::swap(a -= t * b, b);",
            "\t\t\tstd::swap(u -= t * v, v);",
            "\t\t}",
            "\t\treturn mint(u);",
            "\t}",
            "",
            "\tconstexpr mint pow(unsigned long long n) const {",
            "\t\tmint ret(1), mul(x);",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1)",
            "\t\t\t\tret *= mul;",
            "\t\t\tmul *= mul;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tfriend std::ostream &operator<<(std::ostream &os, const mint &r) { return os << r.x; }",
            "",
            "  private:",
            "\tint x;",
            "};",
            "",
            "// using mint = static_modint<998'244'353>;",
            "using mint = static_modint<1'000'000'007>;"
        ]
    },
    "dynamic_modint_32bit_mod_but_128bit_constructor_support_using_barrett_suisen": {
        "prefix": "dynamic_modint_32bit_mod_but_128bit_constructor_support_using_barrett_suisen",
        "body": [
            "namespace internal::modint {",
            "\tconstexpr long long safe_mod(long long x, long long m) { return (x %= m) < 0 ? x + m : x; }",
            "\tconstexpr long long pow_mod(long long x, long long n, int m) {",
            "\t\tif (m == 1)",
            "\t\t\treturn 0;",
            "\t\tunsigned int um = m;",
            "\t\tunsigned long long r = 1, y = safe_mod(x, m);",
            "\t\tfor (; n; n >>= 1) {",
            "\t\t\tif (n & 1)",
            "\t\t\t\tr = (r * y) % um;",
            "\t\t\ty = (y * y) % um;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "",
            "\tconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "\t\ta = safe_mod(a, b);",
            "\t\tif (a == 0)",
            "\t\t\treturn {b, 0};",
            "\t\tlong long s = b, t = a, m0 = 0, m1 = 1, tmp = 0;",
            "\t\twhile (t) {",
            "\t\t\tlong long u = s / t;",
            "\t\t\ts -= t * u, m0 -= m1 * u;",
            "\t\t\ttmp = s, s = t, t = tmp;",
            "\t\t\ttmp = m0, m0 = m1, m1 = tmp;",
            "\t\t}",
            "\t\tif (m0 < 0)",
            "\t\t\tm0 += b / s;",
            "\t\treturn {s, m0};",
            "\t}",
            "",
            "\tstruct barrett_K128 {",
            "\t\tuint32_t M;",
            "\t\t__uint128_t L;",
            "\t\tuint64_t dL, uL;",
            "\t\tconstexpr barrett_K128(uint32_t Mm) : M(Mm), L(~__uint128_t(0) / Mm + 1), dL(L), uL(L >> 64) {}",
            "\t\tconstexpr uint32_t umod() const { return M; }",
            "\t\ttemplate <bool care_M1 = true> constexpr uint32_t rem(uint64_t c) const {",
            "\t\t\tif constexpr (care_M1)",
            "\t\t\t\tif (M == 1)",
            "\t\t\t\t\treturn 0;",
            "\t\t\t__uint128_t cu = __uint128_t(c) * uL;",
            "\t\t\tuint64_t cd = (__uint128_t(c) * dL) >> 64;",
            "\t\t\tuint32_t r = c - uint64_t(cu >> 64) * M;",
            "\t\t\treturn uint64_t(cu) > ~cd ? r - M : r;",
            "\t\t}",
            "\t\t// a*b mod M",
            "\t\tconstexpr uint32_t mul(uint32_t a, uint32_t b) const { return rem<false>(uint64_t(a) * b); }",
            "\t};",
            "} // namespace internal::modint",
            "",
            "template <int id> class dynamic_modint {",
            "\tusing mint = dynamic_modint;",
            "\tusing barrett = internal::modint::barrett_K128;",
            "",
            "\tstruct raw_construct {};",
            "\tconstexpr dynamic_modint(int v, raw_construct) : _v(v) {}",
            "",
            "  public:",
            "\tstatic int mod() { return bt.umod(); }",
            "\tstatic unsigned int umod() { return bt.umod(); }",
            "",
            "\tstatic void set_mod(int m) {",
            "\t\tassert(1 <= m);",
            "\t\tbt = barrett(m);",
            "\t}",
            "\tstatic mint raw(int v) { return dynamic_modint(v, raw_construct{}); }",
            "",
            "\tdynamic_modint() : _v(0) {}",
            "\ttemplate <class T, std::enable_if_t<std::conjunction_v<std::is_integral<T>, std::is_signed<T>>, std::nullptr_t> = nullptr>",
            "\tdynamic_modint(T v) {",
            "\t\tif (v < 0) {",
            "\t\t\tint x = v % mod();",
            "\t\t\tif (x < 0)",
            "\t\t\t\tx += mod();",
            "\t\t\t_v = x;",
            "\t\t} else",
            "\t\t\t_v = bt.rem(v);",
            "\t}",
            "\ttemplate <class T, std::enable_if_t<std::conjunction_v<std::is_integral<T>, std::is_unsigned<T>>, std::nullptr_t> = nullptr>",
            "\tdynamic_modint(T v) : _v(bt.rem(v)) {}",
            "",
            "\tdynamic_modint(__uint128_t v) : _v(v % umod()) {}",
            "\tdynamic_modint(__int128_t v) {",
            "\t\tint x = v % mod();",
            "\t\tif (x < 0)",
            "\t\t\tx += mod();",
            "\t\t_v = x;",
            "\t}",
            "",
            "\tunsigned int val() const { return _v; }",
            "",
            "\tmint &operator++() {",
            "\t\t++_v;",
            "\t\tif (_v == umod())",
            "\t\t\t_v = 0;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator--() {",
            "\t\tif (_v == 0)",
            "\t\t\t_v = umod();",
            "\t\t--_v;",
            "\t\treturn *this;",
            "\t}",
            "\tmint operator++(int) {",
            "\t\tmint x = *this;",
            "\t\t++*this;",
            "\t\treturn x;",
            "\t}",
            "\tmint operator--(int) {",
            "\t\tmint x = *this;",
            "\t\t--*this;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tmint &operator+=(const mint &rhs) {",
            "\t\t_v += rhs._v;",
            "\t\tif (_v >= umod())",
            "\t\t\t_v -= umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &rhs) {",
            "\t\t_v -= rhs._v;",
            "\t\tif (_v >= umod())",
            "\t\t\t_v += umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &rhs) {",
            "\t\t_v = bt.mul(_v, rhs._v);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &rhs) { return *this *= rhs.inv(); }",
            "",
            "\tmint pow(long long n) const {",
            "\t\tassert(0 <= n);",
            "\t\tmint x = *this, r = 1;",
            "\t\tfor (; n; n >>= 1) {",
            "\t\t\tif (n & 1)",
            "\t\t\t\tr *= x;",
            "\t\t\tx *= x;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "\tmint xpow(long long n) const { return n < 0 ? inv().pow(-n) : pow(n); }",
            "\tmint inv() const {",
            "\t\tconst auto [g, res] = internal::modint::inv_gcd(_v, mod());",
            "\t\tassert(g == 1);",
            "\t\treturn res;",
            "\t}",
            "",
            "\tfriend mint operator+(const mint &lhs, const mint &rhs) {",
            "\t\tmint res = lhs;",
            "\t\tres += rhs;",
            "\t\treturn res;",
            "\t}",
            "\tfriend mint operator-(const mint &lhs, const mint &rhs) {",
            "\t\tmint res = lhs;",
            "\t\tres -= rhs;",
            "\t\treturn res;",
            "\t}",
            "\tfriend mint operator*(const mint &lhs, const mint &rhs) {",
            "\t\tmint res = lhs;",
            "\t\tres *= rhs;",
            "\t\treturn res;",
            "\t}",
            "\tfriend mint operator/(const mint &lhs, const mint &rhs) {",
            "\t\tmint res = lhs;",
            "\t\tres /= rhs;",
            "\t\treturn res;",
            "\t}",
            "\tfriend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "\tfriend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "",
            "  private:",
            "\tunsigned int _v;",
            "\tstatic inline barrett bt{998244353};",
            "};",
            "",
            "using modint = dynamic_modint<-1>;"
        ]
    },
    "prps": {
        "prefix": "prps",
        "body": [
            "inline namespace Print {",
            "#define SFINAE(x, ...)\t\t\t \\",
            "\ttemplate <class, class = void> \\",
            "\tstruct x : std::false_type {}; \\",
            "\ttemplate <class T>\t\t\t \\",
            "\tstruct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "",
            "\tostream &operator<<(ostream &os, const __uint128_t &x) {",
            "\t\tconstexpr uint64_t d19 = 10'000'000'000'000'000'000U;",
            "\t\tif (x > d19) {",
            "\t\t\tos << uint64_t(x / d19) << setfill('0') << setw(19) << uint64_t(x % d19);",
            "\t\t} else {",
            "\t\t\tos << uint64_t(x);",
            "\t\t}",
            "\t\treturn os;",
            "\t}",
            "\tostream &operator<<(ostream &os, const __int128_t &x) {",
            "\t\tif (x >= 0) {",
            "\t\t\tos << __uint128_t(x);",
            "\t\t} else {",
            "\t\t\tos << '-' << __uint128_t(-x);",
            "\t\t}",
            "\t\treturn os;",
            "\t}",
            "",
            "\tSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));",
            "\tSFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "\tSFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "\ttemplate <auto &os, bool print_nd>",
            "\tstruct Writer {",
            "\t\ttemplate <class T>",
            "\t\tconstexpr char Space(const T &) const {",
            "\t\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n' : ' ';",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid Impl(T const &t) const {",
            "\t\t\tif constexpr (DefaultO<T>::value)",
            "\t\t\t\tos << t;",
            "\t\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\t\tint i = 0;",
            "\t\t\t\tfor (auto &&x : t) ((i++) ? (os << Space(x), Impl(x)) : Impl(x));",
            "\t\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\t\tstd::apply(",
            "\t\t\t\t\t[this](auto const &...args) {",
            "\t\t\t\t\t\tint i = 0;",
            "\t\t\t\t\t\t(((i++) ? (os << \" \", Impl(args)) : Impl(args)), ...);",
            "\t\t\t\t\t},",
            "\t\t\t\t\tt);",
            "\t\t\t} else",
            "\t\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for print\");",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid ImplWrapper(T const &t) const {",
            "\t\t\tImpl(t);",
            "\t\t}",
            "\t\ttemplate <class... Ts>",
            "\t\tvoid print(Ts const &...ts) const {",
            "\t\t\t((Impl(ts)), ...);",
            "\t\t}",
            "\t\ttemplate <class F, class... Ts>",
            "\t\tvoid print_with_sep(const std::string &sep, F const &f, Ts const &...ts) const {",
            "\t\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';",
            "\t\t}",
            "\t\tvoid print_with_sep(const std::string &) const { os << '\\n'; }",
            "\t};",
            "",
            "\ttemplate <class... Ts>",
            "\tvoid pr(Ts const &...ts) {",
            "\t\tWriter<cout, true>{}.print(ts...);",
            "\t}",
            "\ttemplate <class... Ts>",
            "\tvoid ps(Ts const &...ts) {",
            "\t\tWriter<cout, true>{}.print_with_sep(\" \", ts...);",
            "\t}",
            "}  // namespace Print"
        ]
    },
    "static_mint_montgomery": {
        "prefix": "static_mint_montgomery",
        "body": [
            "template <uint32_t mod> struct static_modint_m {",
            "\tusing mint = static_modint_m;",
            "\tusing i32 = int32_t;",
            "\tusing u32 = uint32_t;",
            "\tusing u64 = uint64_t;",
            "",
            "\tstatic constexpr u32 get_r() {",
            "\t\tu32 ret = mod;",
            "\t\tfor (i32 i = 0; i < 4; ++i)",
            "\t\t\tret *= 2 - mod * ret;",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tstatic constexpr u32 r = get_r();",
            "\tstatic constexpr u32 n2 = -u64(mod) % mod;",
            "\tstatic_assert(mod < (1 << 30), \"invalid, mod >= 2 ^ 30\");",
            "\tstatic_assert((mod & 1) == 1, \"invalid, mod % 2 == 0\");",
            "\tstatic_assert(r * mod == 1, \"invalid, r * mod != 1\");",
            "",
            "\tu32 a;",
            "",
            "\tconstexpr static_modint_m() : a(0) {}",
            "\tconstexpr static_modint_m(const int64_t &b) : a(reduce(u64(b % mod + mod) * n2)) {};",
            "",
            "\tstatic constexpr u32 reduce(const u64 &b) { return (b + u64(u32(b) * u32(-r)) * mod) >> 32; }",
            "",
            "\tconstexpr mint &operator+=(const mint &b) {",
            "\t\tif (i32(a += b.a - 2 * mod) < 0)",
            "\t\t\ta += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tconstexpr mint &operator-=(const mint &b) {",
            "\t\tif (i32(a -= b.a) < 0)",
            "\t\t\ta += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tconstexpr mint &operator*=(const mint &b) {",
            "\t\ta = reduce(u64(a) * b.a);",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tconstexpr mint &operator/=(const mint &b) {",
            "\t\t*this *= b.inverse();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tconstexpr mint operator+(const mint &b) const { return mint(*this) += b; }",
            "\tconstexpr mint operator-(const mint &b) const { return mint(*this) -= b; }",
            "\tconstexpr mint operator*(const mint &b) const { return mint(*this) *= b; }",
            "\tconstexpr mint operator/(const mint &b) const { return mint(*this) /= b; }",
            "\tconstexpr bool operator==(const mint &b) const { return (a >= mod ? a - mod : a) == (b.a >= mod ? b.a - mod : b.a); }",
            "\tconstexpr bool operator!=(const mint &b) const { return (a >= mod ? a - mod : a) != (b.a >= mod ? b.a - mod : b.a); }",
            "\tconstexpr mint operator-() const { return mint() - mint(*this); }",
            "\tconstexpr mint operator+() const { return mint(*this); }",
            "",
            "\tconstexpr mint pow(u64 n) const {",
            "\t\tmint ret(1), mul(*this);",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1)",
            "\t\t\t\tret *= mul;",
            "\t\t\tmul *= mul;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tconstexpr mint inverse() const {",
            "\t\tint x = get(), y = mod, u = 1, v = 0, t = 0, tmp = 0;",
            "\t\twhile (y > 0) {",
            "\t\t\tt = x / y;",
            "\t\t\tx -= t * y, u -= t * v;",
            "\t\t\ttmp = x, x = y, y = tmp;",
            "\t\t\ttmp = u, u = v, v = tmp;",
            "\t\t}",
            "\t\treturn mint{u};",
            "\t}",
            "",
            "\tfriend ostream &operator<<(ostream &os, const mint &b) { return os << b.get(); }",
            "",
            "\tconstexpr u32 get() const {",
            "\t\tu32 ret = reduce(a);",
            "\t\treturn ret >= mod ? ret - mod : ret;",
            "\t}",
            "",
            "\tstatic constexpr u32 get_mod() { return mod; }",
            "};",
            "",
            "using mint = static_modint_m<1'000'000'007>;",
            "// using mint = static_modint_m<998'244'353>;"
        ]
    },
    "re_ben": {
        "prefix": "re_ben",
        "body": [
            "inline namespace reader {",
            "#define SFINAE(x, ...)\t\t\t \\",
            "\ttemplate <class, class = void> \\",
            "\tstruct x : std::false_type {}; \\",
            "\ttemplate <class T>\t\t\t \\",
            "\tstruct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "\t__uint128_t _stou128(const std::string &s) {",
            "\t\t__uint128_t ret = 0;",
            "\t\tfor (char c : s)",
            "\t\t\tif ('0' <= c and c <= '9') ret = 10 * ret + c - '0';",
            "\t\treturn ret;",
            "\t}",
            "\t__int128_t _stoi128(const std::string &s) { return (s[0] == '-' ? -1 : +1) * _stou128(s); }",
            "",
            "\tstd::istream &operator>>(std::istream &is, __int128_t &x) {",
            "\t\tstd::string s;",
            "\t\treturn is >> s, x = _stoi128(s), is;",
            "\t}",
            "\tstd::istream &operator>>(std::istream &is, __uint128_t &x) {",
            "\t\tstd::string s;",
            "\t\treturn is >> s, x = _stou128(s), is;",
            "\t}",
            "",
            "\tSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));",
            "\tSFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "\tSFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "\ttemplate <auto &is>",
            "\tstruct Reader {",
            "\t\ttemplate <class T>",
            "\t\tvoid Impl(T &t) {",
            "\t\t\tif constexpr (DefaultI<T>::value)",
            "\t\t\t\tis >> t;",
            "\t\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\t\tfor (auto &x : t) Impl(x);",
            "\t\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);",
            "\t\t\t} else",
            "\t\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for read\");",
            "\t\t}",
            "\t\ttemplate <class... Ts>",
            "\t\tvoid read(Ts &...ts) {",
            "\t\t\t((Impl(ts)), ...);",
            "\t\t}",
            "\t};",
            "",
            "\ttemplate <class... Ts>",
            "\tvoid re(Ts &...ts) {",
            "\t\tReader<cin>{}.read(ts...);",
            "\t}",
            "",
            "}  // namespace reader"
        ]
    },
    "dynamic_modint_barrett_nyaan": {
        "prefix": "dynamic_modint_barrett_nyaan",
        "body": [
            "struct Barrett {",
            "\tusing u32 = unsigned int;",
            "\tusing i64 = long long;",
            "\tusing u64 = unsigned long long;",
            "\tu32 m;",
            "\tu64 im;",
            "\tBarrett() : m(), im() {}",
            "\tBarrett(int n) : m(n), im(u64(-1) / m + 1) {}",
            "\tconstexpr inline i64 quo(u64 n) {",
            "\t\tu64 x = u64((__uint128_t(n) * im) >> 64);",
            "\t\tu32 r = n - x * m;",
            "\t\treturn m <= r ? x - 1 : x;",
            "\t}",
            "\tconstexpr inline i64 rem(u64 n) {",
            "\t\tu64 x = u64((__uint128_t(n) * im) >> 64);",
            "\t\tu32 r = n - x * m;",
            "\t\treturn m <= r ? r + m : r;",
            "\t}",
            "\tconstexpr inline pair<i64, int> quorem(u64 n) {",
            "\t\tu64 x = u64((__uint128_t(n) * im) >> 64);",
            "\t\tu32 r = n - x * m;",
            "\t\tif (m <= r)",
            "\t\t\treturn {x - 1, r + m};",
            "\t\treturn {x, r};",
            "\t}",
            "\tconstexpr inline i64 pow(u64 n, i64 p) {",
            "\t\tu32 a = rem(n), r = m == 1 ? 0 : 1;",
            "\t\twhile (p) {",
            "\t\t\tif (p & 1)",
            "\t\t\t\tr = rem(u64(r) * a);",
            "\t\t\ta = rem(u64(a) * a);",
            "\t\t\tp >>= 1;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "};",
            "",
            "template <int id> struct dynamic_modint_b {",
            "\tint x;",
            "",
            "\tdynamic_modint_b() : x(0) {}",
            "",
            "\tdynamic_modint_b(int64_t y) {",
            "\t\tint z = y % get_mod();",
            "\t\tif (z < 0)",
            "\t\t\tz += get_mod();",
            "\t\tx = z;",
            "\t}",
            "",
            "\tdynamic_modint_b &operator+=(const dynamic_modint_b &p) {",
            "\t\tif ((x += p.x) >= get_mod())",
            "\t\t\tx -= get_mod();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tdynamic_modint_b &operator-=(const dynamic_modint_b &p) {",
            "\t\tif ((x += get_mod() - p.x) >= get_mod())",
            "\t\t\tx -= get_mod();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tdynamic_modint_b &operator*=(const dynamic_modint_b &p) {",
            "\t\tx = rem((unsigned long long)x * p.x);",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tdynamic_modint_b &operator/=(const dynamic_modint_b &p) {",
            "\t\t*this *= p.inverse();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tdynamic_modint_b operator-() const { return dynamic_modint_b(-x); }",
            "\tdynamic_modint_b operator+() const { return *this; }",
            "",
            "\tdynamic_modint_b operator+(const dynamic_modint_b &p) const { return dynamic_modint_b(*this) += p; }",
            "",
            "\tdynamic_modint_b operator-(const dynamic_modint_b &p) const { return dynamic_modint_b(*this) -= p; }",
            "",
            "\tdynamic_modint_b operator*(const dynamic_modint_b &p) const { return dynamic_modint_b(*this) *= p; }",
            "",
            "\tdynamic_modint_b operator/(const dynamic_modint_b &p) const { return dynamic_modint_b(*this) /= p; }",
            "",
            "\tbool operator==(const dynamic_modint_b &p) const { return x == p.x; }",
            "",
            "\tbool operator!=(const dynamic_modint_b &p) const { return x != p.x; }",
            "",
            "\tdynamic_modint_b inverse() const {",
            "\t\tint a = x, b = get_mod(), u = 1, v = 0, t;",
            "\t\twhile (b > 0) {",
            "\t\t\tt = a / b;",
            "\t\t\tswap(a -= t * b, b);",
            "\t\t\tswap(u -= t * v, v);",
            "\t\t}",
            "\t\treturn dynamic_modint_b(u);",
            "\t}",
            "",
            "\tdynamic_modint_b pow(int64_t n) const {",
            "\t\tassert(n >= 0);",
            "\t\tdynamic_modint_b ret(1), mul(x);",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1)",
            "\t\t\t\tret *= mul;",
            "\t\t\tmul *= mul;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tfriend ostream &operator<<(ostream &os, const dynamic_modint_b &p) { return os << p.x; }",
            "",
            "\tint get() const { return x; }",
            "",
            "\tinline unsigned int rem(unsigned long long p) { return barrett().rem(p); }",
            "",
            "\tstatic inline Barrett &barrett() {",
            "\t\tstatic Barrett b;",
            "\t\treturn b;",
            "\t}",
            "",
            "\tstatic inline int &get_mod() {",
            "\t\tstatic int mod = 0;",
            "\t\treturn mod;",
            "\t}",
            "",
            "\tstatic void set_mod(int md) {",
            "\t\tassert(0 < md && md <= (1LL << 30) - 1);",
            "\t\tget_mod() = md;",
            "\t\tbarrett() = Barrett(md);",
            "\t}",
            "};",
            "using modint = dynamic_modint_b<-1>;"
        ]
    },
    "fast_factorize": {
        "prefix": "fast_factorize",
        "body": [
            "namespace internal {",
            "\ttemplate <typename T>",
            "\tusing is_broadly_integral = typename conditional_t<is_integral_v<T> || is_same_v<T, __int128_t> || is_same_v<T, __uint128_t>,",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t   true_type, false_type>::type;",
            "",
            "\ttemplate <typename T>",
            "\tusing is_broadly_signed = typename conditional_t<is_signed_v<T> || is_same_v<T, __int128_t>, true_type, false_type>::type;",
            "",
            "\ttemplate <typename T>",
            "\tusing is_broadly_unsigned =",
            "\t\ttypename conditional_t<is_unsigned_v<T> || is_same_v<T, __uint128_t>, true_type, false_type>::type;",
            "",
            "}  // namespace internal",
            "",
            "namespace internal {",
            "",
            "\ttemplate <typename T>",
            "\tT safe_mod(T a, T p) {",
            "\t\ta %= p;",
            "\t\tif constexpr (is_broadly_signed<T>::value) {",
            "\t\t\tif (a < 0) a += p;",
            "\t\t}",
            "\t\treturn a;",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tpair<T, T> inv_gcd(T a, T p) {",
            "\t\tstatic_assert(is_broadly_signed<T>::value);",
            "\t\ta = safe_mod(a, p);",
            "\t\tif (a == 0) return {p, 0};",
            "\t\tT b = p, x = 1, y = 0;",
            "\t\twhile (a != 0) {",
            "\t\t\tT q = b / a;",
            "\t\t\tswap(a, b %= a);",
            "\t\t\tswap(x, y -= q * x);",
            "\t\t}",
            "\t\tif (y < 0) y += p / b;",
            "\t\treturn {b, y};",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tT inv(T a, T p) {",
            "\t\tstatic_assert(is_broadly_signed<T>::value);",
            "\t\ta = safe_mod(a, p);",
            "\t\tT b = p, x = 1, y = 0;",
            "\t\twhile (a != 0) {",
            "\t\t\tT q = b / a;",
            "\t\t\tswap(a, b %= a);",
            "\t\t\tswap(x, y -= q * x);",
            "\t\t}",
            "\t\tassert(b == 1);",
            "\t\treturn y < 0 ? y + p : y;",
            "\t}",
            "",
            "\ttemplate <typename T, typename U>",
            "\tT modpow(T a, U n, T p) {",
            "\t\ta = safe_mod(a, p);",
            "\t\tT ret = 1 % p;",
            "\t\twhile (n != 0) {",
            "\t\t\tif (n % 2 == 1) ret = U(ret) * a % p;",
            "\t\t\ta = U(a) * a % p;",
            "\t\t\tn /= 2;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tpair<T, T> crt(const vector<T> &r, const vector<T> &m) {",
            "\t\tstatic_assert(is_broadly_signed<T>::value);",
            "\t\tassert(r.size() == m.size());",
            "\t\tint n = int(r.size());",
            "\t\tT r0 = 0, m0 = 1;",
            "\t\tfor (int i = 0; i < n; i++) {",
            "\t\t\tassert(1 <= m[i]);",
            "\t\t\tT r1 = safe_mod(r[i], m[i]), m1 = m[i];",
            "\t\t\tif (m0 < m1) swap(r0, r1), swap(m0, m1);",
            "\t\t\tif (m0 % m1 == 0) {",
            "\t\t\t\tif (r0 % m1 != r1) return {0, 0};",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tauto [g, im] = inv_gcd(m0, m1);",
            "\t\t\tT u1 = m1 / g;",
            "\t\t\tif ((r1 - r0) % g) return {0, 0};",
            "\t\t\tT x = (r1 - r0) / g % u1 * im % u1;",
            "\t\t\tr0 += x * m0;",
            "\t\t\tm0 *= u1;",
            "\t\t\tif (r0 < 0) r0 += m0;",
            "\t\t}",
            "\t\treturn {r0, m0};",
            "\t}",
            "",
            "}  // namespace internal",
            "",
            "namespace internal {",
            "\tunsigned long long non_deterministic_seed() {",
            "\t\tunsigned long long m =",
            "\t\t\tchrono::duration_cast<chrono::nanoseconds>(chrono::high_resolution_clock::now().time_since_epoch()).count();",
            "\t\tm ^= 9845834732710364265uLL;",
            "\t\tm ^= m << 24, m ^= m >> 31, m ^= m << 35;",
            "\t\treturn m;",
            "\t}",
            "\tunsigned long long deterministic_seed() { return 88172645463325252UL; }",
            "\tunsigned long long seed() { return non_deterministic_seed(); }",
            "\tusing i64 = long long;",
            "\tusing u64 = unsigned long long;",
            "",
            "\t// [0, 2^64 - 1)",
            "\tu64 rng() {",
            "\t\tstatic u64 _x = internal::seed();",
            "\t\treturn _x ^= _x << 7, _x ^= _x >> 9;",
            "\t}",
            "",
            "}  // namespace internal",
            "",
            "template <typename Int, typename UInt, typename Long, typename ULong, int id>",
            "struct Dynamic_Modint_Base {",
            "\tusing mint = Dynamic_Modint_Base;",
            "",
            "\tinline static UInt mod;",
            "\tinline static UInt r;",
            "\tinline static UInt n2;",
            "\tstatic constexpr int bit_length = sizeof(UInt) * 8;",
            "",
            "\tstatic UInt get_r() {",
            "\t\tUInt ret = mod;",
            "\t\twhile (mod * ret != 1) ret *= UInt(2) - mod * ret;",
            "\t\treturn ret;",
            "\t}",
            "\tstatic void set_mod(UInt m) {",
            "\t\tassert(m < (UInt(1u) << (bit_length - 2)));",
            "\t\tassert((m & 1) == 1);",
            "\t\tmod = m, n2 = -ULong(m) % m, r = get_r();",
            "\t}",
            "\tUInt a;",
            "",
            "\tDynamic_Modint_Base() : a(0) {}",
            "\tDynamic_Modint_Base(const Long &b) : a(reduce(ULong(b % mod + mod) * n2)) {};",
            "",
            "\tstatic UInt reduce(const ULong &b) { return (b + ULong(UInt(b) * UInt(-r)) * mod) >> bit_length; }",
            "",
            "\tmint &operator+=(const mint &b) {",
            "\t\tif (Int(a += b.a - 2 * mod) < 0) a += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &b) {",
            "\t\tif (Int(a -= b.a) < 0) a += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &b) {",
            "\t\ta = reduce(ULong(a) * b.a);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &b) {",
            "\t\t*this *= b.inverse();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tmint operator+(const mint &b) const { return mint(*this) += b; }",
            "\tmint operator-(const mint &b) const { return mint(*this) -= b; }",
            "\tmint operator*(const mint &b) const { return mint(*this) *= b; }",
            "\tmint operator/(const mint &b) const { return mint(*this) /= b; }",
            "",
            "\tbool operator==(const mint &b) const { return (a >= mod ? a - mod : a) == (b.a >= mod ? b.a - mod : b.a); }",
            "\tbool operator!=(const mint &b) const { return (a >= mod ? a - mod : a) != (b.a >= mod ? b.a - mod : b.a); }",
            "\tmint operator-() const { return mint(0) - mint(*this); }",
            "\tmint operator+() const { return mint(*this); }",
            "",
            "\tmint pow(ULong n) const {",
            "\t\tmint ret(1), mul(*this);",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1) ret *= mul;",
            "\t\t\tmul *= mul, n >>= 1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tfriend ostream &operator<<(ostream &os, const mint &b) { return os << b.get(); }",
            "",
            "\tfriend istream &operator>>(istream &is, mint &b) {",
            "\t\tLong t;",
            "\t\tis >> t;",
            "\t\tb = Dynamic_Modint_Base(t);",
            "\t\treturn (is);",
            "\t}",
            "",
            "\tmint inverse() const {",
            "\t\tInt x = get(), y = get_mod(), u = 1, v = 0;",
            "\t\twhile (y > 0) {",
            "\t\t\tInt t = x / y;",
            "\t\t\tswap(x -= t * y, y);",
            "\t\t\tswap(u -= t * v, v);",
            "\t\t}",
            "\t\treturn mint{u};",
            "\t}",
            "",
            "\tUInt get() const {",
            "\t\tUInt ret = reduce(a);",
            "\t\treturn ret >= mod ? ret - mod : ret;",
            "\t}",
            "",
            "\tstatic UInt get_mod() { return mod; }",
            "};",
            "",
            "template <int id>",
            "using Dynamic_Modint = Dynamic_Modint_Base<int, unsigned int, long long, unsigned long long, id>;",
            "template <int id>",
            "using Dynamic_Modint64bit = Dynamic_Modint_Base<long long, unsigned long long, __int128_t, __uint128_t, id>;",
            "",
            "namespace fast_factorize {",
            "\ttemplate <typename T, typename U>",
            "\tbool miller_rabin(const T &n, vector<T> ws) {",
            "\t\tif (n <= 2) return n == 2;",
            "\t\tif (n % 2 == 0) return false;",
            "",
            "\t\tT d = n - 1;",
            "\t\twhile (d % 2 == 0) d /= 2;",
            "\t\tU e = 1, rev = n - 1;",
            "\t\tfor (T w : ws) {",
            "\t\t\tif (w % n == 0) continue;",
            "\t\t\tT t = d;",
            "\t\t\tU y = internal::modpow<T, U>(w, t, n);",
            "\t\t\twhile (t != n - 1 && y != e && y != rev) y = y * y % n, t *= 2;",
            "\t\t\tif (y != rev && t % 2 == 0) return false;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "",
            "\tbool miller_rabin_u64(unsigned long long n) {",
            "\t\treturn miller_rabin<unsigned long long, __uint128_t>(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});",
            "\t}",
            "",
            "\ttemplate <typename mint>",
            "\tbool miller_rabin(unsigned long long n, vector<unsigned long long> ws) {",
            "\t\tif (n <= 2) return n == 2;",
            "\t\tif (n % 2 == 0) return false;",
            "",
            "\t\tif (mint::get_mod() != n) mint::set_mod(n);",
            "\t\tunsigned long long d = n - 1;",
            "\t\twhile (~d & 1) d >>= 1;",
            "\t\tmint e = 1, rev = n - 1;",
            "\t\tfor (unsigned long long w : ws) {",
            "\t\t\tif (w % n == 0) continue;",
            "\t\t\tunsigned long long t = d;",
            "\t\t\tmint y = mint(w).pow(t);",
            "\t\t\twhile (t != n - 1 && y != e && y != rev) y *= y, t *= 2;",
            "\t\t\tif (y != rev && t % 2 == 0) return false;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "",
            "\tbool is_prime(unsigned long long n) {",
            "\t\tusing mint32 = Dynamic_Modint<96229631>;",
            "\t\tusing mint64 = Dynamic_Modint64bit<622196072>;",
            "",
            "\t\tif (n <= 2) return n == 2;",
            "\t\tif (n % 2 == 0) return false;",
            "\t\tif (n < (1uLL << 30)) {",
            "\t\t\treturn miller_rabin<mint32>(n, {2, 7, 61});",
            "\t\t} else if (n < (1uLL << 62)) {",
            "\t\t\treturn miller_rabin<mint64>(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});",
            "\t\t} else {",
            "\t\t\treturn miller_rabin_u64(n);",
            "\t\t}",
            "\t}",
            "\tusing u64 = uint64_t;",
            "",
            "\ttemplate <typename mint, typename T>",
            "\tT pollard_rho(T n) {",
            "\t\tif (~n & 1) return 2;",
            "\t\tif (is_prime(n)) return n;",
            "\t\tif (mint::get_mod() != n) mint::set_mod(n);",
            "\t\tmint R, one = 1;",
            "\t\tauto f = [&](mint x) { return x * x + R; };",
            "\t\tauto rnd_ = [&]() { return internal::rng() % (n - 2) + 2; };",
            "\t\twhile (1) {",
            "\t\t\tmint x, y, ys, q = one;",
            "\t\t\tR = rnd_(), y = rnd_();",
            "\t\t\tT g = 1;",
            "\t\t\tconstexpr int m = 128;",
            "\t\t\tfor (int r = 1; g == 1; r <<= 1) {",
            "\t\t\t\tx = y;",
            "\t\t\t\tfor (int i = 0; i < r; ++i) y = f(y);",
            "\t\t\t\tfor (int k = 0; g == 1 && k < r; k += m) {",
            "\t\t\t\t\tys = y;",
            "\t\t\t\t\tfor (int i = 0; i < m && i < r - k; ++i) q *= x - (y = f(y));",
            "\t\t\t\t\tg = gcd(q.get(), n);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif (g == n) do",
            "\t\t\t\t\tg = gcd((x - (ys = f(ys))).get(), n);",
            "\t\t\t\twhile (g == 1);",
            "\t\t\tif (g != n) return g;",
            "\t\t}",
            "\t\texit(1);",
            "\t}",
            "",
            "\tusing i64 = long long;",
            "",
            "\tvector<i64> inner_factorize(u64 n) {",
            "\t\tusing mint32 = Dynamic_Modint<452288976>;",
            "\t\tusing mint64 = Dynamic_Modint64bit<401243123>;",
            "",
            "\t\tif (n <= 1) return {};",
            "\t\tu64 p;",
            "\t\tif (n <= (1LL << 30)) {",
            "\t\t\tp = pollard_rho<mint32, uint32_t>(n);",
            "\t\t} else if (n <= (1LL << 62)) {",
            "\t\t\tp = pollard_rho<mint64, uint64_t>(n);",
            "\t\t} else {",
            "\t\t\texit(1);",
            "\t\t}",
            "\t\tif (p == n) return {i64(p)};",
            "\t\tauto l = inner_factorize(p);",
            "\t\tauto r = inner_factorize(n / p);",
            "\t\tcopy(begin(r), end(r), back_inserter(l));",
            "\t\treturn l;",
            "\t}",
            "",
            "\tvector<i64> factorize(u64 n) {",
            "\t\tauto ret = inner_factorize(n);",
            "\t\tsort(begin(ret), end(ret));",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tmap<i64, i64> factor_count(u64 n) {",
            "\t\tmap<i64, i64> mp;",
            "\t\tfor (auto &x : factorize(n)) mp[x]++;",
            "\t\treturn mp;",
            "\t}",
            "",
            "\tvector<i64> divisors(u64 n) {",
            "\t\tif (n == 0) return {};",
            "\t\tvector<pair<i64, i64>> v;",
            "\t\tfor (auto &p : factorize(n)) {",
            "\t\t\tif (v.empty() || v.back().first != p) {",
            "\t\t\t\tv.emplace_back(p, 1);",
            "\t\t\t} else {",
            "\t\t\t\tv.back().second++;",
            "\t\t\t}",
            "\t\t}",
            "\t\tvector<i64> ret;",
            "\t\tauto f = [&](auto rc, int i, i64 x) -> void {",
            "\t\t\tif (i == (int)v.size()) {",
            "\t\t\t\tret.push_back(x);",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\trc(rc, i + 1, x);",
            "\t\t\tfor (int j = 0; j < v[i].second; j++) rc(rc, i + 1, x *= v[i].first);",
            "\t\t};",
            "\t\tf(f, 0, 1);",
            "\t\tsort(begin(ret), end(ret));",
            "\t\treturn ret;",
            "\t}",
            "",
            "}  // namespace fast_factorize",
            "using fast_factorize::divisors;",
            "using fast_factorize::factor_count;",
            "using fast_factorize::factorize;",
            "using fast_factorize::is_prime;",
            ""
        ]
    },
    "crt_atcoder": {
        "prefix": "crt_atcoder",
        "body": [
            "",
            "constexpr long long safe_mod(long long x, long long m) {",
            "\tx %= m;",
            "\tif (x < 0) x += m;",
            "\treturn x;",
            "}",
            "constexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "\ta = safe_mod(a, b);",
            "\tif (a == 0) return {b, 0};",
            "\tlong long s = b, t = a;",
            "\tlong long m0 = 0, m1 = 1;",
            "\twhile (t) {",
            "\t\tlong long u = s / t;",
            "\t\ts -= t * u;",
            "\t\tm0 -= m1 * u;",
            "\t\tauto tmp = s;",
            "\t\ts = t;",
            "\t\tt = tmp;",
            "\t\ttmp = m0;",
            "\t\tm0 = m1;",
            "\t\tm1 = tmp;",
            "\t}",
            "\tif (m0 < 0) m0 += b / s;",
            "\treturn {s, m0};",
            "}",
            "",
            "// (rem, mod)",
            "std::pair<long long, long long> crt(const std::vector<long long>& r, const std::vector<long long>& m) {",
            "\tassert(r.size() == m.size());",
            "\tint n = int(r.size());",
            "\tlong long r0 = 0, m0 = 1;",
            "\tfor (int i = 0; i < n; i++) {",
            "\t\tassert(1 <= m[i]);",
            "\t\tlong long r1 = safe_mod(r[i], m[i]), m1 = m[i];",
            "\t\tif (m0 < m1) {",
            "\t\t\tstd::swap(r0, r1);",
            "\t\t\tstd::swap(m0, m1);",
            "\t\t}",
            "\t\tif (m0 % m1 == 0) {",
            "\t\t\tif (r0 % m1 != r1) return {0, 0};",
            "\t\t\tcontinue;",
            "\t\t}",
            "\t\tlong long g, im;",
            "\t\tstd::tie(g, im) = inv_gcd(m0, m1);",
            "\t\tlong long u1 = (m1 / g);",
            "\t\tif ((r1 - r0) % g) return {0, 0};",
            "\t\tlong long x = (r1 - r0) / g % u1 * im % u1;",
            "\t\tr0 += x * m0;",
            "\t\tm0 *= u1;",
            "\t\tif (r0 < 0) r0 += m0;",
            "\t}",
            "\treturn {r0, m0};",
            "}"
        ]
    },
    "Mex": {
        "prefix": "Mex",
        "body": [
            "// Reference: https://cp-algorithms.com/sequences/mex.html",
            "template <typename T>",
            "class Mex {",
            "   private:",
            "\tmap<T, int> frequency;",
            "\tset<T> missing_numbers;",
            "\tvector<T> A;",
            "",
            "   public:",
            "\tMex(vector<T> const &A) : A(A) {",
            "\t\tfor (int i = 0; i <= A.size(); i++) missing_numbers.insert(i);",
            "",
            "\t\tfor (T x : A) {",
            "\t\t\t++frequency[x];",
            "\t\t\tmissing_numbers.erase(x);",
            "\t\t}",
            "\t}",
            "",
            "\tint mex() { return *missing_numbers.begin(); }",
            "",
            "\tvoid update(int idx, T new_value) {",
            "\t\tif (--frequency[A[idx]] == 0) missing_numbers.insert(A[idx]);",
            "\t\tA[idx] = new_value;",
            "\t\t++frequency[new_value];",
            "\t\tmissing_numbers.erase(new_value);",
            "\t}",
            "};"
        ]
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "struct Timer {",
            "\tTimer() { reset(); }",
            "",
            "\tvoid reset() { bgn = std::chrono::high_resolution_clock::now(); }",
            "",
            "\ttemplate <typename PeriodType = std::chrono::milliseconds>",
            "\tlong long elapsed() const {",
            "\t\tconst std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();",
            "\t\treturn std::chrono::duration_cast<PeriodType>(end - bgn).count();",
            "\t}",
            "",
            "\tvoid display_time_elapsed() { cerr   << \"[Time Elapsed = \" << elapsed() << \"ms]\" << endl; }",
            "",
            "   private:",
            "\tstd::chrono::high_resolution_clock::time_point bgn;",
            "};"
        ]
    },
    "dynamic_bitset": {
        "prefix": "dynamic_bitset",
        "body": [
            "struct DynamicBitSet {",
            "   private:",
            "\tusing block = unsigned long long;",
            "\tstatic constexpr std::size_t block_size = std::numeric_limits<block>::digits;",
            "\tstatic constexpr std::size_t log_block_size = __builtin_ctz(block_size);",
            "",
            "\tstruct bitref {",
            "\t\tblock& b;",
            "\t\tstd::size_t i;",
            "\t\toperator bool() const { return (b >> i) & 1; }",
            "\t\tbool test() const { return (b >> i) & 1; }",
            "\t\tvoid set() { b |= block(1) << i; }",
            "\t\tvoid reset() { b &= ~(block(1) << i); }",
            "\t\tvoid flip() { b ^= block(1) << i; }",
            "\t\tbitref& operator&=(bool val) {",
            "\t\t\tb &= block(val) << i;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tbitref& operator|=(bool val) {",
            "\t\t\tb |= block(val) << i;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tbitref& operator^=(bool val) {",
            "\t\t\tb ^= block(val) << i;",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tbitref& operator=(bool val) {",
            "\t\t\tval ? set() : reset();",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tbitref& operator=(const bitref& v) { return (*this) = bool(v); }",
            "\t};",
            "",
            "\tstd::size_t n;",
            "\tstd::vector<block> blocks;",
            "",
            "   public:",
            "\tDynamicBitSet(std::size_t n = 0, bool fill_value = false) : n(n), blocks((n + block_size - 1) >> log_block_size, fill_value ? ~block(0) : 0) {}",
            "",
            "\tbool empty() const { return n == 0; }",
            "\tint size() const { return n; }",
            "",
            "\tvoid resize(std::size_t new_size, bool fill_value = false) {",
            "\t\tstd::size_t new_block_num = (new_size + block_size - 1) >> log_block_size;",
            "\t\tif (new_block_num < block_num()) {",
            "\t\t\tn = new_size;",
            "\t\t\treturn blocks.resize(new_block_num);",
            "\t\t}",
            "\t\tblocks.resize(new_block_num);",
            "\t\tstd::size_t old_size = std::exchange(n, new_size);",
            "\t\tif (old_size <= new_size) range_update(old_size, new_size, fill_value);",
            "\t}",
            "\tvoid push_back(bool val) {",
            "\t\tif (n & (block_size - 1)) {",
            "\t\t\t(*this)[n] = val;",
            "\t\t} else {",
            "\t\t\tblocks.push_back(val);",
            "\t\t}",
            "\t\t++n;",
            "\t}",
            "\tvoid pop_back() {",
            "\t\tif ((n & (block_size - 1)) == 1) blocks.pop_back();",
            "\t\t--n;",
            "\t}",
            "",
            "\tfriend bool operator==(const DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tif (x.n != y.n) return false;",
            "\t\tif (x.empty()) return true;",
            "\t\tfor (std::size_t i = 0; i < x.block_num() - 1; ++i) {",
            "\t\t\tif (x.blocks[i] != y.blocks[i]) return false;",
            "\t\t}",
            "\t\tconst std::size_t num = x.n - ((x.block_num() - 1) << log_block_size);",
            "\t\treturn get_lower_bits(x.blocks.back(), num) == get_lower_bits(y.blocks.back(), num);",
            "\t}",
            "\tfriend bool operator!=(const DynamicBitSet& x, const DynamicBitSet& y) { return not(x == y); }",
            "\tfriend bool operator<(const DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tif (x.empty()) return false;",
            "\t\tstd::size_t num = x.n - ((x.block_num() - 1) << log_block_size);",
            "\t\tblock tx = get_lower_bits(x.blocks.back(), num);",
            "\t\tblock ty = get_lower_bits(y.blocks.back(), num);",
            "\t\tif (tx != ty) return tx < ty;",
            "\t\tfor (std::size_t i = x.block_num() - 1; i-- > 0;) {",
            "\t\t\tif (x.blocks[i] != y.blocks[i]) return x.blocks[i] < y.blocks[i];",
            "\t\t}",
            "\t\treturn false;",
            "\t}",
            "\tfriend bool operator<=(const DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tif (x.empty()) return true;",
            "\t\tstd::size_t num = x.n - ((x.block_num() - 1) << log_block_size);",
            "\t\tblock tx = get_lower_bits(x.blocks.back(), num);",
            "\t\tblock ty = get_lower_bits(y.blocks.back(), num);",
            "\t\tif (tx != ty) return tx < ty;",
            "\t\tfor (std::size_t i = x.block_num() - 1; i-- > 0;) {",
            "\t\t\tif (x.blocks[i] != y.blocks[i]) return x.blocks[i] < y.blocks[i];",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\tfriend bool operator>(const DynamicBitSet& x, const DynamicBitSet& y) { return not(x <= y); }",
            "\tfriend bool operator>=(const DynamicBitSet& x, const DynamicBitSet& y) { return not(x < y); }",
            "",
            "\toperator bool() const { return any(); }",
            "",
            "\tfriend DynamicBitSet& operator&=(DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tfor (std::size_t i = 0; i < y.block_num(); ++i) x.blocks[i] &= y.blocks[i];",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet& operator|=(DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tfor (std::size_t i = 0; i < y.block_num(); ++i) x.blocks[i] |= y.blocks[i];",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet& operator^=(DynamicBitSet& x, const DynamicBitSet& y) {",
            "\t\tassert(x.n == y.n);",
            "\t\tfor (std::size_t i = 0; i < y.block_num(); ++i) x.blocks[i] ^= y.blocks[i];",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet operator&(DynamicBitSet x, const DynamicBitSet& y) {",
            "\t\tx &= y;",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet operator|(DynamicBitSet x, const DynamicBitSet& y) {",
            "\t\tx |= y;",
            "\t\treturn x;",
            "\t}",
            "\tfriend DynamicBitSet operator^(DynamicBitSet x, const DynamicBitSet& y) {",
            "\t\tx ^= y;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tfriend DynamicBitSet& operator<<=(DynamicBitSet& x, std::size_t shamt) { return x = x << shamt; }",
            "\tfriend DynamicBitSet& operator>>=(DynamicBitSet& x, std::size_t shamt) { return x = x >> shamt; }",
            "\tfriend DynamicBitSet operator<<(const DynamicBitSet& x, std::size_t shamt) {",
            "\t\tif (shamt >= x.n) return DynamicBitSet(x.size());",
            "\t\tDynamicBitSet res(x.size());",
            "\t\tstd::size_t block_shamt = shamt >> log_block_size;",
            "\t\tstd::size_t bit_shamt = shamt & (block_size - 1);",
            "\t\tfor (std::size_t i = 0; i + block_shamt < res.block_num(); ++i) {",
            "\t\t\tif (bit_shamt == 0) {",
            "\t\t\t\tres.blocks[i + block_shamt] = x.blocks[i];",
            "\t\t\t} else {",
            "\t\t\t\tres.blocks[i + block_shamt] |= x.blocks[i] << bit_shamt;",
            "\t\t\t\tif (i + block_shamt + 1 != res.block_num()) {",
            "\t\t\t\t\tres.blocks[i + block_shamt + 1] |= x.blocks[i] >> (block_size - bit_shamt);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tfriend DynamicBitSet operator>>(const DynamicBitSet& x, std::size_t shamt) {",
            "\t\tif (shamt >= x.n) return DynamicBitSet(x.size());",
            "\t\tDynamicBitSet res(x.size());",
            "\t\tstd::size_t block_shamt = shamt >> log_block_size;",
            "\t\tstd::size_t bit_shamt = shamt & (block_size - 1);",
            "\t\tfor (std::size_t i = 0; i + block_shamt < x.block_num(); ++i) {",
            "\t\t\tif (bit_shamt == 0) {",
            "\t\t\t\tres.blocks[i] = x.blocks[i + block_shamt];",
            "\t\t\t} else {",
            "\t\t\t\tres.blocks[i] |= x.blocks[i + block_shamt] >> bit_shamt;",
            "\t\t\t\tif (i + block_shamt + 1 != x.block_num()) {",
            "\t\t\t\t\tres.blocks[i] |= x.blocks[i + block_shamt + 1] << (block_size - bit_shamt);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tres.range_reset(x.n - shamt, x.n);",
            "\t\treturn res;",
            "\t}",
            "",
            "\tDynamicBitSet operator~() const {",
            "\t\tDynamicBitSet neg(n);",
            "\t\tfor (std::size_t i = 0; i < block_num(); ++i) neg.blocks[i] = ~blocks[i];",
            "\t\treturn neg;",
            "\t}",
            "",
            "\tbool operator[](std::size_t i) const { return (blocks[block_index(i)] >> bit_index(i)) & 1; }",
            "\tbitref operator[](std::size_t i) { return {blocks[block_index(i)], bit_index(i)}; }",
            "",
            "\tvoid range_set(std::size_t l, std::size_t r) {",
            "\t\tassert(l <= r and r <= n);",
            "\t\tif (l == r) return;",
            "\t\tstd::size_t lb = block_index(l), rb = block_index(r - 1);",
            "\t\tstd::size_t li = bit_index(l), ri = bit_index(r);",
            "\t\tif (ri == 0) ri = block_size;",
            "\t\tif (lb == rb) {",
            "\t\t\tblocks[lb] |= mask_range_bits(~block(0), li, ri);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tblocks[lb] |= mask_upper_bits(~block(0), block_size - li);",
            "\t\tblocks[rb] |= mask_lower_bits(~block(0), ri);",
            "\t\tfor (std::size_t i = lb + 1; i < rb; ++i) blocks[i] = ~block(0);",
            "\t}",
            "\tvoid range_reset(std::size_t l, std::size_t r) {",
            "\t\tassert(l <= r and r <= n);",
            "\t\tif (l == r) return;",
            "\t\tstd::size_t lb = block_index(l), rb = block_index(r - 1);",
            "\t\tstd::size_t li = bit_index(l), ri = bit_index(r);",
            "\t\tif (ri == 0) ri = block_size;",
            "\t\tif (lb == rb) {",
            "\t\t\tblocks[lb] &= ~mask_range_bits(~block(0), li, ri);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tblocks[lb] &= ~mask_upper_bits(~block(0), block_size - li);",
            "\t\tblocks[rb] &= ~mask_lower_bits(~block(0), ri);",
            "\t\tfor (std::size_t i = lb + 1; i < rb; ++i) blocks[i] = block(0);",
            "\t}",
            "\tvoid range_flip(std::size_t l, std::size_t r) {",
            "\t\tassert(l <= r and r <= n);",
            "\t\tif (l == r) return;",
            "\t\tstd::size_t lb = block_index(l), rb = block_index(r - 1);",
            "\t\tstd::size_t li = bit_index(l), ri = bit_index(r);",
            "\t\tif (ri == 0) ri = block_size;",
            "\t\tif (lb == rb) {",
            "\t\t\tblocks[lb] ^= mask_range_bits(~block(0), li, ri);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tblocks[lb] ^= mask_upper_bits(~block(0), block_size - li);",
            "\t\tblocks[rb] ^= mask_lower_bits(~block(0), ri);",
            "\t\tfor (std::size_t i = lb + 1; i < rb; ++i) blocks[i] ^= ~block(0);",
            "\t}",
            "\tvoid range_update(std::size_t l, std::size_t r, bool val) { val ? range_set(l, r) : range_reset(l, r); }",
            "\tint range_count(std::size_t l, std::size_t r) const {",
            "\t\tassert(l <= r and r <= n);",
            "\t\tif (l == r) return 0;",
            "\t\tstd::size_t lb = block_index(l), rb = block_index(r - 1);",
            "\t\tstd::size_t li = bit_index(l), ri = bit_index(r);",
            "\t\tif (ri == 0) ri = block_size;",
            "",
            "\t\tif (lb == rb) {",
            "\t\t\treturn __builtin_popcountll(blocks[lb] & mask_range_bits(~block(0), li, ri));",
            "\t\t}",
            "\t\tint res = 0;",
            "\t\tres += __builtin_popcountll(blocks[lb] & mask_upper_bits(~block(0), block_size - li));",
            "\t\tres += __builtin_popcountll(blocks[rb] & mask_lower_bits(~block(0), ri));",
            "\t\tfor (std::size_t i = lb + 1; i < rb; ++i) res += __builtin_popcountll(blocks[i]);",
            "\t\treturn res;",
            "\t}",
            "",
            "\tvoid set() {",
            "\t\tfor (block& b : blocks) b = ~block(0);",
            "\t}",
            "\tvoid reset() {",
            "\t\tfor (block& b : blocks) b = 0;",
            "\t}",
            "\tbool all() const {",
            "\t\tif (empty()) return true;",
            "\t\tfor (std::size_t i = 0; i < block_num() - 1; ++i) {",
            "\t\t\tif (blocks[i] != ~block(0)) return false;",
            "\t\t}",
            "\t\tconst std::size_t num = n - ((block_num() - 1) << log_block_size);",
            "\t\tassert(num);",
            "\t\tconst block upper = ((block(1) << (block_size - num)) - 1) << num;",
            "\t\treturn (upper | blocks.back()) == ~block(0);",
            "\t}",
            "\tbool none() const {",
            "\t\tif (empty()) return true;",
            "\t\tfor (std::size_t i = 0; i < block_num() - 1; ++i) {",
            "\t\t\tif (blocks[i] != 0) return false;",
            "\t\t}",
            "\t\tconst std::size_t num = n - ((block_num() - 1) << log_block_size);",
            "\t\treturn get_lower_bits(blocks.back(), num) == 0;",
            "\t}",
            "\tbool any() const { return not none(); }",
            "\tint count() const {",
            "\t\tif (empty()) return 0;",
            "\t\tint res = 0;",
            "\t\tfor (std::size_t i = 0; i < block_num() - 1; ++i) {",
            "\t\t\tres += __builtin_popcountll(blocks[i]);",
            "\t\t}",
            "\t\tconst std::size_t num = n - ((block_num() - 1) << log_block_size);",
            "\t\treturn res + __builtin_popcountll(get_lower_bits(blocks.back(), num));",
            "\t}",
            "",
            "\tint find_first() const {",
            "\t\tif (empty()) return size();",
            "\t\tfor (std::size_t i = 0; i < block_num(); ++i) {",
            "\t\t\tif (blocks[i] != 0) return std::min(n, __builtin_ctzll(blocks[i]) | (i << log_block_size));",
            "\t\t}",
            "\t\treturn n;",
            "\t}",
            "\tint find_next(std::size_t pos) const {",
            "\t\tstd::size_t i = block_index(++pos);",
            "\t\tif (i >= blocks.size()) return n;",
            "\t\tblock upper = mask_upper_bits(blocks[i], block_size - bit_index(pos));",
            "\t\tif (upper != 0) return std::min(n, __builtin_ctzll(upper) | (i << log_block_size));",
            "\t\twhile (++i < block_num()) {",
            "\t\t\tif (blocks[i] != 0) return std::min(n, __builtin_ctzll(blocks[i]) | (i << log_block_size));",
            "\t\t}",
            "\t\treturn n;",
            "\t}",
            "",
            "\tbool has_intersection(const DynamicBitSet& y) const {",
            "\t\tif (n > y.n) return y.has_intersection(*this);",
            "\t\tif (empty()) return false;",
            "\t\tfor (std::size_t i = 0; i < block_num() - 1; ++i) {",
            "\t\t\tif (blocks[i] & y.blocks[i]) return true;",
            "\t\t}",
            "\t\tconst std::size_t num = n - ((block_num() - 1) << log_block_size);",
            "\t\treturn get_lower_bits(blocks.back(), num) & y.blocks[block_num() - 1];",
            "\t}",
            "\tbool is_disjoint(const DynamicBitSet& y) const { return not has_intersection(y); }",
            "",
            "   private:",
            "\tstatic constexpr std::size_t block_index(std::size_t i) { return i >> log_block_size; }",
            "\tstatic constexpr std::size_t bit_index(std::size_t i) { return i & (block_size - 1); }",
            "\tstatic constexpr block get_lower_bits(block b, std::size_t num) { return num ? (b << (block_size - num) >> (block_size - num)) : block(0); }",
            "\tstatic constexpr block get_upper_bits(block b, std::size_t num) { return num ? (b >> (block_size - num)) : block(0); }",
            "\tstatic constexpr block get_range_bits(block b, std::size_t l, std::size_t r) { return l < r ? b << (block_size - r) >> (block_size - r + l) : block(0); }",
            "\tstatic constexpr block mask_lower_bits(block b, std::size_t num) { return get_lower_bits(b, num); }",
            "\tstatic constexpr block mask_upper_bits(block b, std::size_t num) { return num ? (b >> (block_size - num) << (block_size - num)) : block(0); }",
            "\tstatic constexpr block mask_range_bits(block b, std::size_t l, std::size_t r) { return l < r ? b << (block_size - r) >> (block_size - r + l) << l : block(0); }",
            "",
            "\tstd::size_t block_num() const { return blocks.size(); }",
            "};"
        ]
    },
    "type_alias": {
        "prefix": "type_alias",
        "body": [
            "using uint = uint32_t;",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using lll = __int128_t;",
            "using ulll = __uint128_t;"
        ]
    },
    "fast_sqrt_and_cbrt": {
        "prefix": "fast_sqrt_and_cbrt",
        "body": [
            "unsigned long long fast_sqrt(unsigned long long n) {",
            "\tunsigned long long c, g;",
            "",
            "\tc = g = 0x80000000;",
            "\tfor (;;) {",
            "\t\tif ((g * g) > n)",
            "\t\t\tg ^= c;",
            "\t\tc >>= 1;",
            "\t\tif (!c)",
            "\t\t\treturn g;",
            "\t\tg |= c;",
            "\t}",
            "}",
            "",
            "unsigned long long fast_cbrt(unsigned long long n) {",
            "\tint r = 63;",
            "\tunsigned long long x, res = 0;",
            "",
            "\tfor (; r >= 0; r -= 3) {",
            "\t\tres <<= 1;",
            "\t\tx = (res * (res + 1) * 3) + 1;",
            "\t\tif ((n >> r) >= x) {",
            "\t\t\tres++;",
            "\t\t\tn -= (x << r);",
            "\t\t}",
            "\t}",
            "",
            "\treturn res;",
            "}",
            ""
        ]
    },
    "reader": {
        "prefix": "reader",
        "body": [
            "namespace reader {",
            "\ttemplate <typename T>",
            "\tclass is_iterable {",
            "\t\ttemplate <typename T_>",
            "\t\tstatic auto test(T_ e) -> decltype(e.begin(), e.end(), std::true_type{});",
            "\t\tstatic std::false_type test(...);",
            "",
            "\t   public:",
            "\t\tstatic constexpr bool value = decltype(test(std::declval<T>()))::value;",
            "\t};",
            "\ttemplate <typename T>",
            "\tstatic constexpr bool is_iterable_v = is_iterable<T>::value;",
            "\ttemplate <typename T>",
            "\tclass is_readable {",
            "\t\ttemplate <typename T_>",
            "\t\tstatic auto test(T_ e) -> decltype(std::declval<std::istream &>() >> e, std::true_type{});",
            "\t\tstatic std::false_type test(...);",
            "",
            "\t   public:",
            "\t\tstatic constexpr bool value = decltype(test(std::declval<T>()))::value;",
            "\t};",
            "\ttemplate <typename T>",
            "\tstatic constexpr bool is_readable_v = is_readable<T>::value;",
            "\ttemplate <typename IStream,",
            "\t\t\t  std::enable_if_t<std::conjunction_v<std::is_base_of<std::istream, std::remove_reference_t<IStream>>,",
            "\t\t\t\t\t\t\t\t\t\t\t\t  std::negation<std::is_const<std::remove_reference_t<IStream>>>>,",
            "\t\t\t\t\t\t\t   std::nullptr_t> = nullptr>",
            "\tstruct InputStream {",
            "\t   private:",
            "\t\tusing istream_type = std::remove_reference_t<IStream>;",
            "\t\tIStream is;",
            "\t\tstruct {",
            "\t\t\tInputStream *is;",
            "\t\t\ttemplate <typename T>",
            "\t\t\toperator T() {",
            "\t\t\t\tT e;",
            "\t\t\t\t*is >> e;",
            "\t\t\t\treturn e;",
            "\t\t\t}",
            "\t\t} _reader{this};",
            "",
            "\t   public:",
            "\t\ttemplate <typename IStream_>",
            "\t\tInputStream(IStream_ &&ts) : is(std::move(ts)) {}",
            "\t\ttemplate <typename IStream_>",
            "\t\tInputStream(IStream_ &ts) : is(ts) {}",
            "\t\ttemplate <typename T>",
            "\t\tInputStream &operator>>(T &e) {",
            "\t\t\tif constexpr (is_readable_v<T>)",
            "\t\t\t\tis >> e;",
            "\t\t\telse",
            "\t\t\t\t_read(e);",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tauto read() { return _reader; }",
            "\t\ttemplate <typename Head, typename... Tail>",
            "\t\tvoid read(Head &head, Tail &...tails) {",
            "\t\t\t((*this >> head) >> ... >> tails);",
            "\t\t}",
            "\t\tistream_type &get_stream() { return is; }",
            "",
            "\t   private:",
            "\t\tstatic __uint128_t _stou128(const std::string &s) {",
            "\t\t\t__uint128_t ret = 0;",
            "\t\t\tfor (char c : s)",
            "\t\t\t\tif ('0' <= c and c <= '9') ret = 10 * ret + c - '0';",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\tstatic __int128_t _stoi128(const std::string &s) { return (s[0] == '-' ? -1 : +1) * _stou128(s); }",
            "",
            "\t\tvoid _read(__uint128_t &v) { v = _stou128(std::string(_reader)); }",
            "\t\tvoid _read(__int128_t &v) { v = _stoi128(std::string(_reader)); }",
            "\t\ttemplate <typename T, typename U>",
            "\t\tvoid _read(std::pair<T, U> &a) {",
            "\t\t\t*this >> a.first >> a.second;",
            "\t\t}",
            "\t\ttemplate <size_t N = 0, typename... Args>",
            "\t\tvoid _read(std::tuple<Args...> &a) {",
            "\t\t\tif constexpr (N < sizeof...(Args)) *this >> std::get<N>(a), _read<N + 1>(a);",
            "\t\t}",
            "\t\ttemplate <typename Iterable, std::enable_if_t<is_iterable_v<Iterable>, std::nullptr_t> = nullptr>",
            "\t\tvoid _read(Iterable &a) {",
            "\t\t\tfor (auto &e : a) *this >> e;",
            "\t\t}",
            "\t};",
            "\ttemplate <typename IStream>",
            "\tInputStream(IStream &&) -> InputStream<IStream>;",
            "\ttemplate <typename IStream>",
            "\tInputStream(IStream &) -> InputStream<IStream &>;",
            "",
            "\tInputStream cin{std::cin};",
            "",
            "\tauto re() { return cin.read(); }",
            "\ttemplate <typename Head, typename... Tail>",
            "\tvoid re(Head &head, Tail &...tails) {",
            "\t\tcin.read(head, tails...);",
            "\t}",
            "}  // namespace reader",
            "using reader::re;"
        ]
    },
    "inc_debug": {
        "prefix": "inc_debug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"_debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "incdebug": {
        "prefix": "incdebug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "fileio": {
        "prefix": "fileio",
        "body": [
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif"
        ]
    },
    "reprps": {
        "prefix": "reprps",
        "body": [
            "inline namespace IO {",
            "#define SFINAE(x, ...)\t\t\t \\",
            "\ttemplate <class, class = void> \\",
            "\tstruct x : std::false_type {}; \\",
            "\ttemplate <class T>\t\t\t \\",
            "\tstruct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "",
            "\tostream &operator<<(ostream &os, const __uint128_t &x) {",
            "\t\tconstexpr uint64_t d19 = 10'000'000'000'000'000'000U;",
            "\t\tif (x > d19) {",
            "\t\t\tos << uint64_t(x / d19) << setfill('0') << setw(19) << uint64_t(x % d19);",
            "\t\t} else {",
            "\t\t\tos << uint64_t(x);",
            "\t\t}",
            "\t\treturn os;",
            "\t}",
            "\tostream &operator<<(ostream &os, const __int128_t &x) {",
            "\t\tif (x >= 0) {",
            "\t\t\tos << __uint128_t(x);",
            "\t\t} else {",
            "\t\t\tos << '-' << __uint128_t(-x);",
            "\t\t}",
            "\t\treturn os;",
            "\t}",
            "",
            "\t__uint128_t _stou128(const std::string &s) {",
            "\t\t__uint128_t ret = 0;",
            "\t\tfor (char c : s)",
            "\t\t\tif ('0' <= c and c <= '9') ret = 10 * ret + c - '0';",
            "\t\treturn ret;",
            "\t}",
            "\t__int128_t _stoi128(const std::string &s) { return (s[0] == '-' ? -1 : +1) * _stou128(s); }",
            "",
            "\tstd::istream &operator>>(std::istream &is, __int128_t &x) {",
            "\t\tstd::string s;",
            "\t\treturn is >> s, x = _stoi128(s), is;",
            "\t}",
            "\tstd::istream &operator>>(std::istream &is, __uint128_t &x) {",
            "\t\tstd::string s;",
            "\t\treturn is >> s, x = _stou128(s), is;",
            "\t}",
            "",
            "\tSFINAE(DefaultI, decltype(std::cin >> std::declval<T &>()));",
            "\tSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));",
            "\tSFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "\tSFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "\ttemplate <auto &is>",
            "\tstruct Reader {",
            "\t\ttemplate <class T>",
            "\t\tvoid Impl(T &t) {",
            "\t\t\tif constexpr (DefaultI<T>::value)",
            "\t\t\t\tis >> t;",
            "\t\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\t\tfor (auto &x : t) Impl(x);",
            "\t\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\t\tstd::apply([this](auto &...args) { (Impl(args), ...); }, t);",
            "\t\t\t} else",
            "\t\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for read\");",
            "\t\t}",
            "\t\ttemplate <class... Ts>",
            "\t\tvoid read(Ts &...ts) {",
            "\t\t\t((Impl(ts)), ...);",
            "\t\t}",
            "\t};",
            "",
            "\ttemplate <class... Ts>",
            "\tvoid re(Ts &...ts) {",
            "\t\tReader<cin>{}.read(ts...);",
            "\t}",
            "",
            "\ttemplate <auto &os, bool print_nd>",
            "\tstruct Writer {",
            "\t\ttemplate <class T>",
            "\t\tconstexpr char Space(const T &) const {",
            "\t\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n' : ' ';",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid Impl(T const &t) const {",
            "\t\t\tif constexpr (DefaultO<T>::value)",
            "\t\t\t\tos << t;",
            "\t\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\t\tint i = 0;",
            "\t\t\t\tfor (auto &&x : t) ((i++) ? (os << Space(x), Impl(x)) : Impl(x));",
            "\t\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\t\tstd::apply(",
            "\t\t\t\t\t[this](auto const &...args) {",
            "\t\t\t\t\t\tint i = 0;",
            "\t\t\t\t\t\t(((i++) ? (os << \" \", Impl(args)) : Impl(args)), ...);",
            "\t\t\t\t\t},",
            "\t\t\t\t\tt);",
            "\t\t\t} else",
            "\t\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for print\");",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid ImplWrapper(T const &t) const {",
            "\t\t\tImpl(t);",
            "\t\t}",
            "\t\ttemplate <class... Ts>",
            "\t\tvoid print(Ts const &...ts) const {",
            "\t\t\t((Impl(ts)), ...);",
            "\t\t}",
            "\t\ttemplate <class F, class... Ts>",
            "\t\tvoid print_with_sep(const std::string &sep, F const &f, Ts const &...ts) const {",
            "\t\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';",
            "\t\t}",
            "\t\tvoid print_with_sep(const std::string &) const { os << '\\n'; }",
            "\t};",
            "",
            "\ttemplate <class... Ts>",
            "\tvoid pr(Ts const &...ts) {",
            "\t\tWriter<cout, true>{}.print(ts...);",
            "\t}",
            "\ttemplate <class... Ts>",
            "\tvoid ps(Ts const &...ts) {",
            "\t\tWriter<cout, true>{}.print_with_sep(\" \", ts...);",
            "\t}",
            "}  // namespace IO"
        ]
    },
    "inc": {
        "prefix": "inc",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;"
        ]
    },
    "mex": {
        "prefix": "mex",
        "body": [
            "int mex(vector<int> &a) {",
            "\tvector<bool> f(a.size() + 1, 0);",
            "\tfor (int i : a)",
            "\t\tif (i <= (int)a.size())",
            "\t\t\tf[i] = 1;",
            "\tint mex = 0;",
            "\twhile (f[mex])",
            "\t\t++mex;",
            "\treturn mex;",
            "}"
        ]
    },
    "floor_ceil_division": {
        "prefix": "floor_ceil_division",
        "body": [
            "template <class T>",
            "T floor_div(T x, T y) {",
            "\tauto d = x / y;",
            "\tauto r = x % y;",
            "\tif (r == 0)",
            "\t\treturn d;",
            "\tif ((r > 0) == (y > 0))",
            "\t\treturn d;",
            "\treturn d - 1;",
            "}",
            "template <class T>",
            "T ceil_div(T x, T y) {",
            "\tauto d = x / y;",
            "\tauto r = x % y;",
            "\tif (r == 0)",
            "\t\treturn d;",
            "\tif ((r > 0) == (y > 0))",
            "\t\treturn d + 1;",
            "\treturn d;",
            "}"
        ]
    },
    "gcd_lcm_for_128bit_integer": {
        "prefix": "gcd_lcm_for_128bit_integer",
        "body": [
            "inline int countr_zero(unsigned __int128 x) {",
            "\tauto lo = (unsigned long long)(x);",
            "\tauto hi = (unsigned long long)(x >> 64);",
            "\treturn lo ? std::countr_zero(lo) : 64 + std::countr_zero(hi);",
            "}",
            "",
            "inline __int128_t abs(__int128_t x) { return x < 0 ? -x : x; }",
            "",
            "inline __uint128_t gcd(__uint128_t a, __uint128_t b) {",
            "\tif (a == 0)",
            "\t\treturn b;",
            "\tif (b == 0)",
            "\t\treturn a;",
            "\tint shift;",
            "\t{",
            "\t\tint a_bsf = countr_zero(a);",
            "\t\ta >>= a_bsf;",
            "\t\tint b_bsf = countr_zero(b);",
            "\t\tb >>= b_bsf;",
            "\t\tshift = std::min(a_bsf, b_bsf);",
            "\t}",
            "\twhile (a != b) {",
            "\t\tif (a > b)",
            "\t\t\tstd::swap(a, b);",
            "\t\tb -= a;",
            "\t\tb >>= countr_zero(b);",
            "\t}",
            "\treturn (a << shift);",
            "}",
            "inline __int128_t gcd(__int128_t a, __int128_t b) { return gcd((__uint128_t)abs(a), (__uint128_t)abs(b)); }",
            "inline __uint128_t lcm(__uint128_t a, __uint128_t b) { return a / gcd(a, b) * b; }",
            "inline __int128_t lcm(__int128_t a, __int128_t b) { return a / gcd(a, b) * b; }"
        ]
    },
    "binary_trie": {
        "prefix": "binary_trie",
        "body": [
            "template <typename T, int bit_length = std::numeric_limits<std::make_unsigned_t<T>>::digits>",
            "class BinaryTrie {",
            "\tusing U = std::make_unsigned_t<T>;",
            "\tstruct Node {",
            "\t\tint siz;",
            "\t\tNode *ch[2]{nullptr, nullptr};",
            "\t\tNode() : siz(0) {}",
            "\t\t~Node() {",
            "\t\t\tdelete ch[0];",
            "\t\t\tdelete ch[1];",
            "\t\t}",
            "\t\tinline Node *get_or_create(bool b) noexcept {",
            "\t\t\tif (is_absent(b))",
            "\t\t\t\tch[b] = new Node();",
            "\t\t\treturn ch[b];",
            "\t\t}",
            "\t\tinline Node *operator[](bool b) const noexcept { return ch[b]; }",
            "\t\tinline bool is_absent(bool b) const noexcept { return ch[b] == nullptr; }",
            "\t\tinline bool is_present(bool b) const noexcept { return ch[b] != nullptr; }",
            "\t\tstatic inline int size(const Node *const node) noexcept { return node == nullptr ? 0 : node->siz; }",
            "\t\tinline void update_size() noexcept { siz = size(ch[0]) + size(ch[1]); }",
            "",
            "\t\tstd::string to_string(const int k = bit_length - 1, const U val = 0, const std::string &prefix = \"\") const {",
            "\t\t\tstatic const std::string zo[2]{\"+-[0]- \", \"+-[1]- \"};",
            "\t\t\tstatic const std::string branch = '|' + std::string(zo[0].size() - 1, ' ');",
            "\t\t\tauto res = std::to_string(siz) + ' ';",
            "\t\t\tif (is_absent(0) and is_absent(1)) {",
            "\t\t\t\treturn res + \"(\" + std::to_string(val) + \")\\n\";",
            "\t\t\t}",
            "\t\t\tauto pref0 = prefix + std::string(res.size(), ' ');",
            "\t\t\tauto prefb = pref0 + branch;",
            "\t\t\tauto pref1 = pref0 + std::string(zo[0].size(), ' ');",
            "\t\t\tif (is_absent(0) or is_absent(1)) {",
            "\t\t\t\tbool b = is_absent(0);",
            "\t\t\t\treturn res + zo[b] + ch[b]->to_string(k - 1, val | (b << k), pref1);",
            "\t\t\t}",
            "\t\t\tres += zo[0] + ch[0]->to_string(k - 1, val, prefb);",
            "\t\t\tres += pref0 + \"|\\n\";",
            "\t\t\tres += pref0 + zo[1] + ch[1]->to_string(k - 1, val | (1 << k), pref1);",
            "\t\t\treturn res;",
            "\t\t}",
            "\t};",
            "",
            "  public:",
            "\tBinaryTrie() : root(new Node) {}",
            "\t~BinaryTrie() { delete root; }",
            "",
            "\tinline int size() const noexcept { return Node::size(root); }",
            "\tinline bool empty() const noexcept { return size() == 0; }",
            "",
            "\tint insert(const U val, const int num = 1) noexcept {",
            "\t\tif (num == 0)",
            "\t\t\treturn 0;",
            "\t\tNode *cur = root;",
            "\t\tcur->siz += num;",
            "\t\tfor (int i = bit_length; i-- > 0;) {",
            "\t\t\tcur = cur->get_or_create(bit(val, i));",
            "\t\t\tcur->siz += num;",
            "\t\t}",
            "\t\treturn cur->siz;",
            "\t}",
            "\tint erase(const U val, const int num = 1) noexcept {",
            "\t\tif (num == 0)",
            "\t\t\treturn 0;",
            "\t\treturn erase(root, bit_length - 1, val, num);",
            "\t}",
            "\tint erase_all(const U val) noexcept {",
            "\t\treturn erase(val, std::numeric_limits<int>::max());",
            "\t}",
            "\tint prefix_count(const U val, const unsigned int l) const noexcept {",
            "\t\tNode *cur = root;",
            "\t\tfor (int i = bit_length; i-- > l;) {",
            "\t\t\tif (cur == nullptr)",
            "\t\t\t\treturn 0;",
            "\t\t\tcur = (*cur)[bit(val, i)];",
            "\t\t}",
            "\t\treturn Node::size(cur);",
            "\t}",
            "\tinline int count(const U val) const noexcept { return prefix_count(val, 0); }",
            "\tinline bool contains(const U val) const noexcept { return count(val) > 0; }",
            "",
            "\tinline U xor_kth_min(const U x, const int k) const {",
            "\t\tassert(0 <= k and k < size());",
            "\t\treturn unchecked_xor_kth_element</* is_max_query = */ false>(x, k);",
            "\t}",
            "\tinline U xor_kth_max(const U x, const int k) const {",
            "\t\tassert(0 <= k and k < size());",
            "\t\treturn unchecked_xor_kth_element</* is_max_query = */ true>(x, k);",
            "\t}",
            "\tinline U xor_min(const U x) const { return xor_kth_min(x, 0); }",
            "\tinline U xor_max(const U x) const { return xor_kth_max(x, 0); }",
            "\tint xor_count_lt(const U x, const U val) const noexcept {",
            "\t\tint res = 0;",
            "\t\tNode *cur = root;",
            "\t\tfor (int i = bit_length - 1; i >= 0; --i) {",
            "\t\t\tif (cur == nullptr)",
            "\t\t\t\tbreak;",
            "\t\t\tbool bx = bit(x, i);",
            "\t\t\tbool bv = bit(x ^ val, i);",
            "\t\t\tif (bx != bv) {",
            "\t\t\t\tres += Node::size((*cur)[bx]);",
            "\t\t\t}",
            "\t\t\tcur = (*cur)[bv];",
            "\t\t}",
            "\t\treturn res;",
            "\t}",
            "\tinline int xor_count_leq(const U x, const U val) const noexcept { return xor_count_lt(x, val) + count(val); }",
            "\tinline int xor_count_gt(const U x, const U val) const noexcept { return size() - xor_count_leq(x, val); }",
            "\tinline int xor_count_geq(const U x, const U val) const noexcept { return size() - xor_count_lt(x, val); }",
            "\tinline U xor_lower(const U x, const U val, const U default_value = ~U(0)) const noexcept {",
            "\t\tint k = size() - xor_count_geq(x, val) - 1;",
            "\t\treturn k < 0 ? default_value : unchecked_xor_kth_element(x, k);",
            "\t}",
            "\tinline U xor_floor(const U x, const U val, const U default_value = ~U(0)) const noexcept {",
            "\t\tint k = size() - xor_count_gt(x, val) - 1;",
            "\t\treturn k < 0 ? default_value : unchecked_xor_kth_element(x, k);",
            "\t}",
            "\tinline U xor_higher(const U x, const U val, const U default_value = ~U(0)) const noexcept {",
            "\t\tint k = xor_count_leq(x, val);",
            "\t\treturn k == size() ? default_value : unchecked_xor_kth_element(x, k);",
            "\t}",
            "\tinline U xor_ceil(const U x, const U val, const U default_value = ~U(0)) const noexcept {",
            "\t\tint k = xor_count_lt(x, val);",
            "\t\treturn k == size() ? default_value : unchecked_xor_kth_element(x, k);",
            "\t}",
            "",
            "\tinline U kth_min(const int k) const { return xor_kth_min(0, k); }",
            "\tinline U min() const { return xor_kth_min(0, 0); }",
            "\tinline U max() const { return xor_kth_min(~U(0), 0); }",
            "\tinline int count_lt(const U val) const noexcept { return xor_count_lt(0, val); }",
            "\tinline int count_leq(const U val) const noexcept { return xor_count_leq(0, val); }",
            "\tinline int count_gt(const U val) const noexcept { return xor_count_gt(0, val); }",
            "\tinline int count_geq(const U val) const noexcept { return xor_count_geq(0, val); }",
            "\tinline U lower(const U val, const U default_value = ~U(0)) const noexcept { return xor_lower(0, val, default_value); }",
            "\tinline U floor(const U val, const U default_value = ~U(0)) const noexcept { return xor_floor(0, val, default_value); }",
            "\tinline U higher(const U val, const U default_value = ~U(0)) const noexcept { return xor_higher(0, val, default_value); }",
            "\tinline U ceil(const U val, const U default_value = ~U(0)) const noexcept { return xor_ceil(0, val, default_value); }",
            "",
            "\tinline std::string to_string() const noexcept { return root->to_string(); }",
            "\tfriend std::ostream &operator<<(std::ostream &out, const BinaryTrie &bt) { return out << bt.to_string(); }",
            "",
            "  private:",
            "\tNode *const root;",
            "\tstatic constexpr bool bit(const U val, const int i) noexcept {",
            "\t\treturn (val >> i) & 1;",
            "\t}",
            "\tint erase(Node *cur, const int k, const U val, const int num) {",
            "\t\tif (k == -1) {",
            "\t\t\tint removed = std::min(cur->siz, num);",
            "\t\t\tcur->siz -= removed;",
            "\t\t\treturn removed;",
            "\t\t}",
            "\t\tbool b = bit(val, k);",
            "\t\tif (cur->is_absent(b))",
            "\t\t\treturn 0;",
            "\t\tint removed = erase((*cur)[b], k - 1, val, num);",
            "\t\tcur->update_size();",
            "\t\treturn removed;",
            "\t}",
            "\ttemplate <bool is_max_query = false>",
            "\tU unchecked_xor_kth_element(const U x, const int k) const noexcept {",
            "\t\tU res = 0;",
            "\t\tint rest = k;",
            "\t\tNode *cur = root;",
            "\t\tfor (int i = bit_length - 1; i >= 0; --i) {",
            "\t\t\tbool b = is_max_query ^ bit(x, i);",
            "\t\t\tint sz = Node::size((*cur)[b]);",
            "\t\t\tif (sz <= rest)",
            "\t\t\t\trest -= sz, b = not b;",
            "\t\t\tres |= U(b) << i;",
            "\t\t\tcur = (*cur)[b];",
            "\t\t}",
            "\t\treturn x ^ res;",
            "\t}",
            "};"
        ]
    },
    "mod_power": {
        "prefix": "mod_power",
        "body": [
            "inline constexpr uint64_t mod_power(uint64_t x, uint64_t n, uint64_t m) {",
            "\tif (m == 1)",
            "\t\treturn 0;",
            "\tuint64_t r = 1;",
            "\tuint64_t y = x % m;",
            "\twhile (n) {",
            "\t\tif (n & 1)",
            "\t\t\tr = (uint64_t)((__uint128_t)(1) * r * y % m);",
            "\t\ty = (uint64_t)((__uint128_t)(1) * y * y % m);",
            "\t\tn >>= 1;",
            "\t}",
            "\treturn r;",
            "}"
        ]
    },
    "miller_rabin": {
        "prefix": "miller_rabin",
        "body": [
            "",
            "uint64_t mod_mul64(uint64_t a, uint64_t b, uint64_t mod) {",
            "\tassert(a < mod && b < mod);",
            "",
            "\tif (mod <= 1LLU << 32)",
            "\t\treturn a * b % mod;",
            "",
            "\tif (mod <= 1LLU << 63) {",
            "\t\tuint64_t q = uint64_t((long double)a * b / mod);",
            "\t\tuint64_t result = a * b - q * mod;",
            "",
            "\t\tif (result > 1LLU << 63)",
            "\t\t\tresult += mod;",
            "\t\telse if (result >= mod)",
            "\t\t\tresult -= mod;",
            "",
            "\t\treturn result;",
            "\t}",
            "",
            "#ifdef __SIZEOF_INT128__",
            "\treturn uint64_t(__uint128_t(a) * b % mod);",
            "#endif",
            "",
            "\tassert(false);",
            "}",
            "",
            "uint64_t mod_pow64(uint64_t a, uint64_t b, uint64_t mod) {",
            "\tuint64_t result = 1;",
            "",
            "\twhile (b > 0) {",
            "\t\tif (b & 1)",
            "\t\t\tresult = mod_mul64(result, a, mod);",
            "",
            "\t\ta = mod_mul64(a, a, mod);",
            "\t\tb >>= 1;",
            "\t}",
            "",
            "\treturn result;",
            "}",
            "",
            "bool miller_rabin(uint64_t n) {",
            "\tif (n < 2)",
            "\t\treturn false;",
            "",
            "\t// Check small primes.",
            "\tfor (uint64_t p : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29})",
            "\t\tif (n % p == 0)",
            "\t\t\treturn n == p;",
            "",
            "\t// https://miller-rabin.appspot.com/",
            "\tauto get_miller_rabin_bases = [&]() -> vector<uint64_t> {",
            "\t\tif (n < 341531)",
            "\t\t\treturn {9345883071009581737LLU};",
            "\t\tif (n < 1050535501)",
            "\t\t\treturn {336781006125, 9639812373923155};",
            "\t\tif (n < 350269456337)",
            "\t\t\treturn {4230279247111683200, 14694767155120705706LLU, 16641139526367750375LLU};",
            "\t\tif (n < 55245642489451)",
            "\t\t\treturn {2, 141889084524735, 1199124725622454117, 11096072698276303650LLU};",
            "\t\tif (n < 7999252175582851)",
            "\t\t\treturn {2, 4130806001517, 149795463772692060, 186635894390467037, 3967304179347715805};",
            "\t\tif (n < 585226005592931977)",
            "\t\t\treturn {2,",
            "\t\t\t\t\t123635709730000,",
            "\t\t\t\t\t9233062284813009,",
            "\t\t\t\t\t43835965440333360,",
            "\t\t\t\t\t761179012939631437,",
            "\t\t\t\t\t1263739024124850375};",
            "\t\treturn {2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
            "\t};",
            "",
            "\tint r = __builtin_ctzll(n - 1);",
            "\tuint64_t d = (n - 1) >> r;",
            "",
            "\tfor (uint64_t a : get_miller_rabin_bases()) {",
            "\t\tif (a % n == 0)",
            "\t\t\tcontinue;",
            "",
            "\t\tuint64_t x = mod_pow64(a % n, d, n);",
            "",
            "\t\tif (x == 1 || x == n - 1)",
            "\t\t\tcontinue;",
            "",
            "\t\tfor (int i = 0; i < r - 1 && x != n - 1; i++)",
            "\t\t\tx = mod_mul64(x, x, n);",
            "",
            "\t\tif (x != n - 1)",
            "\t\t\treturn false;",
            "\t}",
            "",
            "\treturn true;",
            "}"
        ]
    },
    "power": {
        "prefix": "power",
        "body": [
            "int64_t power(int64_t a, int64_t b) {",
            "\tint64_t res = 1;",
            "\twhile (b > 0) {",
            "\t\tif (b & 1)",
            "\t\t\tres = res * a;",
            "\t\ta = a * a;",
            "\t\tb >>= 1;",
            "\t}",
            "\treturn res;",
            "}"
        ]
    },
    "pbds": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "using __gnu_pbds::null_type;",
            "using __gnu_pbds::rb_tree_tag;",
            "using __gnu_pbds::tree;",
            "using __gnu_pbds::tree_order_statistics_node_update;",
            "",
            "#undef _GLIBCXX_DEBUG",
            "",
            "template <typename K, typename V, typename Comp = less<K>>",
            "using indexed_map =",
            "\ttree<K, V, Comp, rb_tree_tag, tree_order_statistics_node_update>;",
            "",
            "template <typename K, typename Comp = less<K>>",
            "using indexed_set = indexed_map<K, null_type, Comp>;",
            "",
            "template <typename K, typename V, typename Comp = less_equal<K>>",
            "using indexed_multimap = indexed_map<K, V, Comp>;",
            "",
            "template <typename K, typename Comp = less_equal<K>>",
            "using indexed_multiset = indexed_map<K, null_type, Comp>;"
        ]
    },
    "heap": {
        "prefix": "heap",
        "body": [
            "template <typename T, typename Sequence = vector<T>, typename Compare = less<T>>",
            "using template_heap = priority_queue<T, Sequence, Compare>;",
            "template <typename T> using max_heap = template_heap<T>;",
            "template <typename T> using min_heap = template_heap<T, vector<T>, greater<T>>;"
        ]
    },
    "inverse": {
        "prefix": "inverse",
        "body": [
            "int64_t inverse(int64_t a, int64_t mod) {",
            "\ta %= mod;",
            "\tif (a < 0) a += mod;",
            "\tint64_t b = mod, u = 0, v = 1;",
            "\twhile (a) {",
            "\t\tint64_t t = b / a;",
            "\t\tb -= t * a;",
            "\t\tswap(a, b);",
            "\t\tu -= t * v;",
            "\t\tswap(u, v);",
            "\t}",
            "\tassert(b == 1);",
            "\tif (u < 0) u += mod;",
            "\treturn u;",
            "}"
        ]
    },
    "dst": {
        "prefix": "dst",
        "body": [
            "template <typename T, typename F>",
            "class dst {",
            "   public:",
            "\tint n;",
            "\tvector<vector<T>> st;",
            "\tF op;",
            "",
            "\tdst(const vector<T> &a, const F &f) : n(int(a.size())), op(f) {",
            "\t\tst.push_back(a);",
            "\t\tfor (int p = 1; (1 << p) < n; p++) {",
            "\t\t\tst.emplace_back(n);",
            "\t\t\tfor (int mid = 1 << p; mid < n; mid += 1 << (p + 1)) {",
            "\t\t\t\tst[p][mid - 1] = a[mid - 1];",
            "\t\t\t\tfor (int j = mid - 2; j >= mid - (1 << p); j--) {",
            "\t\t\t\t\tst[p][j] = op(a[j], st[p][j + 1]);",
            "\t\t\t\t}",
            "\t\t\t\tst[p][mid] = a[mid];",
            "\t\t\t\tfor (int j = mid + 1; j < min(n, mid + (1 << p)); j++) {",
            "\t\t\t\t\tst[p][j] = op(st[p][j - 1], a[j]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\t// [l, r), 0-indexed",
            "\tT Query(int l, int r) const {",
            "\t\tassert(0 <= l && l < r && r <= n);",
            "\t\tif (r - l == 1) {",
            "\t\t\treturn st[0][l];",
            "\t\t}",
            "\t\tint p = bit_width(unsigned(l ^ (r - 1))) - 1;",
            "\t\treturn op(st[p][l], st[p][r - 1]);",
            "\t}",
            "};"
        ]
    },
    "sparse": {
        "prefix": "sparse",
        "body": [
            "template <typename T, typename F>",
            "class SparseTable {",
            "   public:",
            "\tint n;",
            "\tvector<vector<T>> mat;",
            "\tF func;",
            "",
            "\tSparseTable(const vector<T> &a, const F &f) : func(f) {",
            "\t\tn = static_cast<int>(a.size());",
            "\t\tint max_log = 32 - __builtin_clz(n);",
            "\t\tmat.resize(max_log);",
            "\t\tmat[0] = a;",
            "\t\tfor (int j = 1; j < max_log; j++) {",
            "\t\t\tmat[j].resize(n - (1 << j) + 1);",
            "\t\t\tfor (int i = 0; i <= n - (1 << j); i++) {",
            "\t\t\t\tmat[j][i] = func(mat[j - 1][i], mat[j - 1][i + (1 << (j - 1))]);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t//[from, to] 0-indexed",
            "\tT get(int from, int to) const {",
            "\t\tassert(0 <= from && from <= to && to <= n - 1);",
            "\t\tint lg = 32 - __builtin_clz(to - from + 1) - 1;",
            "\t\treturn func(mat[lg][from], mat[lg][to - (1 << lg) + 1]);",
            "\t}",
            "};"
        ]
    },
    "time": {
        "prefix": "time",
        "body": [
            "#define start\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\",
            "\tusing namespace chrono;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \\",
            "\tauto start_time = high_resolution_clock::now();",
            "",
            "#define stop\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\",
            "\tauto stop_time = high_resolution_clock::now();\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \\",
            "\tauto duration = duration_cast<milliseconds>(stop_time - start_time);\t\t\t\t\t\t\t\t\t \\",
            "\tcerr << \"[Time Taken\" << \" = \" << duration << \"]\" << endl << endl;",
            ""
        ]
    },
    "mint": {
        "prefix": "mint",
        "body": [
            "",
            "template <typename T> T inverse(T a, T m) {",
            "\tT u = 0, v = 1;",
            "\twhile (a != 0) {",
            "\t\tT t = m / a;",
            "\t\tm -= t * a;",
            "\t\tswap(a, m);",
            "\t\tu -= t * v;",
            "\t\tswap(u, v);",
            "\t}",
            "\tassert(m == 1);",
            "\treturn u;",
            "}",
            "",
            "template <typename T> class Modular {",
            "  public:",
            "\tusing Type = typename decay<decltype(T::value)>::type;",
            "",
            "\tconstexpr Modular() : value() {}",
            "\ttemplate <typename U> Modular(const U &x) { value = normalize(x); }",
            "",
            "\ttemplate <typename U> static Type normalize(const U &x) {",
            "\t\tType v;",
            "\t\tif (-mod() <= x && x < mod())",
            "\t\t\tv = static_cast<Type>(x);",
            "\t\telse",
            "\t\t\tv = static_cast<Type>(x % mod());",
            "\t\tif (v < 0)",
            "\t\t\tv += mod();",
            "\t\treturn v;",
            "\t}",
            "",
            "\tconst Type &operator()() const { return value; }",
            "\ttemplate <typename U> explicit operator U() const { return static_cast<U>(value); }",
            "\tconstexpr static Type mod() { return T::value; }",
            "",
            "\tModular &operator+=(const Modular &other) {",
            "\t\tvalue += other.value;",
            "\t\tvalue -= (value >= mod()) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\tModular &operator-=(const Modular &other) {",
            "\t\tvalue -= other.value;",
            "\t\tvalue += (value < 0) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }",
            "\ttemplate <typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }",
            "\tModular &operator++() { return *this += 1; }",
            "\tModular &operator--() { return *this -= 1; }",
            "\tModular operator++(int) {",
            "\t\tModular result(*this);",
            "\t\t*this += 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator--(int) {",
            "\t\tModular result(*this);",
            "\t\t*this -= 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator-() const { return Modular(-value); }",
            "",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &",
            "\toperator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &",
            "\toperator*=(const Modular &rhs) {",
            "\t\tint64_t q = int64_t(static_cast<long double>(value) * rhs.value / mod());",
            "\t\tvalue = normalize(value * rhs.value - q * mod());",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &",
            "\toperator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(value * rhs.value);",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tModular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
            "",
            "\tfriend const Type &abs(const Modular &x) { return x.value; }",
            "",
            "\ttemplate <typename U> friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename U> friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename V, typename U> friend V &operator>>(V &stream, Modular<U> &number);",
            "",
            "  private:",
            "\tType value;",
            "};",
            "",
            "template <typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn lhs.value == rhs.value;",
            "}",
            "template <typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) {",
            "\treturn lhs == Modular<T>(rhs);",
            "}",
            "template <typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) == rhs;",
            "}",
            "",
            "template <typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "",
            "template <typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn lhs.value < rhs.value;",
            "}",
            "",
            "template <typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) += rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) += rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) += rhs;",
            "}",
            "",
            "template <typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) -= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) -= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) -= rhs;",
            "}",
            "",
            "template <typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) *= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) *= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) *= rhs;",
            "}",
            "",
            "template <typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) /= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) {",
            "\treturn Modular<T>(lhs) /= rhs;",
            "}",
            "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) {",
            "\treturn Modular<T>(lhs) /= rhs;",
            "}",
            "",
            "template <typename T, typename U> Modular<T> power(const Modular<T> &a, const U &b) {",
            "\tassert(b >= 0);",
            "\tModular<T> x = a, res = 1;",
            "\tU p = b;",
            "\twhile (p > 0) {",
            "\t\tif (p & 1)",
            "\t\t\tres *= x;",
            "\t\tx *= x;",
            "\t\tp >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "template <typename T> bool IsZero(const Modular<T> &number) { return number() == 0; }",
            "",
            "template <typename T> string to_string(const Modular<T> &number) { return to_string(number()); }",
            "",
            "template <typename U, typename T> U &operator<<(U &stream, const Modular<T> &number) {",
            "\treturn stream << number();",
            "}",
            "",
            "template <typename U, typename T> U &operator>>(U &stream, Modular<T> &number) {",
            "\ttypename common_type<typename Modular<T>::Type, int64_t>::type x;",
            "\tstream >> x;",
            "\tnumber.value = Modular<T>::normalize(x);",
            "\treturn stream;",
            "}",
            "",
            "constexpr int md = $0;",
            "using mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
            ""
        ]
    },
    "prps_simple": {
        "prefix": "prps_simple",
        "body": [
            "void ps() { cout << \"\\n\"; }",
            "template <class H, class... T> void ps(const H &h, const T &...t) {",
            "\tcout << h;",
            "\tif (sizeof...(t))",
            "\t\tcout << ' ';",
            "\tps(t...);",
            "}",
            "",
            "void pr() { cout << \"\"; }",
            "template <class H, class... T> void pr(const H &h, const T &...t) {",
            "\tcout << h;",
            "\tpr(t...);",
            "}"
        ]
    },
    "ispowerofn": {
        "prefix": "ispowerofn",
        "body": [
            "bool is_power_of_n(int64_t number, int64_t N) { ",
            "\tif(number == 0 || (number!=1 && N == 0))",
            "\t\treturn false; ",
            "\telse if(N == 1)",
            "\t\treturn true;",
            "\t",
            "\twhile(number != 1) {  ",
            "\t\tif(number % N != 0)",
            "\t\t\treturn false; ",
            "\t\tnumber = number / N;  ",
            "\t} ",
            "\treturn true; ",
            "}",
            "",
            "int64_t log_a_to_base_b(int64_t a, int64_t b) { return log2(a) / log2(b); }"
        ]
    },
    "divisors": {
        "prefix": "divisors",
        "body": [
            "template <typename T>",
            "vector<T> divisors(T number) {",
            "\tvector<T> ans;",
            "\tfor (T i = 1; i * i <= number; ++i) {",
            "\t\tif (number % i == 0) {",
            "\t\t\tif (number / i == i) {",
            "\t\t\t\tans.push_back(i);",
            "\t\t\t} else {",
            "\t\t\t\tans.push_back(i);",
            "\t\t\t\tans.push_back(number / i);",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\t//unsorted",
            "\treturn ans;",
            "}"
        ]
    },
    "tourist_is_prime": {
        "prefix": "tourist_is_prime",
        "body": [
            "bool is_prime(uint64_t n) {",
            "\tif (n < 2) {",
            "\t\treturn false;",
            "\t}",
            "\tvector<uint32_t> sp = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
            "\tfor (uint32_t x : sp) {",
            "\t\tif (n == x) {",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tif (n % x == 0) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "\tif (n < 31 * 31) {",
            "\t\treturn true;",
            "\t}",
            "\tuint32_t s = __builtin_ctzll(n - 1);",
            "\tuint64_t d = (n - 1) >> s;",
            "\tfunction<bool(uint64_t)> check = [&n, &s, &d](uint64_t a) {",
            "\t\tuint64_t cur = 1, p = d;",
            "\t\twhile (p > 0) {",
            "\t\t\tif (p & 1) {",
            "\t\t\t\tcur = (__uint128_t)cur * a % n;",
            "\t\t\t}",
            "\t\t\ta = (__uint128_t)a * a % n;",
            "\t\t\tp >>= 1;",
            "\t\t}",
            "\t\tif (cur == 1) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t\tfor (uint32_t r = 0; r < s; r++) {",
            "\t\t\tif (cur == n - 1) {",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t\tcur = (__uint128_t)cur * cur % n;",
            "\t\t}",
            "\t\treturn true;",
            "\t};",
            "\tvector<uint64_t> b = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
            "\tfor (uint64_t a : b) {",
            "\t\tif (a % n == 0) {",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tif (check(a)) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "\treturn true;",
            "}"
        ]
    },
    "kthroot": {
        "prefix": "kthroot",
        "body": [
            "uint64_t kth_root_integer(uint64_t a, int k) {",
            "\tif (k == 1) return a;",
            "\tauto check = [&](uint32_t x) {",
            "\t\tuint64_t mul = 1;",
            "\t\tfor (int j = 0; j < k; j++) {",
            "\t\t\tif (__builtin_mul_overflow(mul, x, &mul)) return false;",
            "\t\t}",
            "\t\treturn mul <= a;",
            "\t};",
            "\tuint64_t ret = 0;",
            "\tfor (int i = 31; i >= 0; i--) {",
            "\t\tif (check(ret | (1u << i))) ret |= 1u << i;",
            "\t}",
            "\treturn ret;",
            "}"
        ]
    },
    "cpp": {
        "prefix": "cpp",
        "body": [
            "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math,inline\")",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "using uint = uint32_t;",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using lll = __int128_t;",
            "using ulll = __uint128_t;",
            "",
            "",
            "const ll MOD = 1e9 + 7;",
            "const ll OMOD = 998'244'353;",
            "",
            "#if defined(LOCAL)",
            "#include \"debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif",
            "",
            "namespace reader {",
            "\ttemplate <typename T>",
            "\tclass is_iterable {",
            "\t\ttemplate <typename T_>",
            "\t\tstatic auto test(T_ e) -> decltype(e.begin(), e.end(), std::true_type{});",
            "\t\tstatic std::false_type test(...);",
            "",
            "\t   public:",
            "\t\tstatic constexpr bool value = decltype(test(std::declval<T>()))::value;",
            "\t};",
            "\ttemplate <typename T>",
            "\tstatic constexpr bool is_iterable_v = is_iterable<T>::value;",
            "\ttemplate <typename T>",
            "\tclass is_readable {",
            "\t\ttemplate <typename T_>",
            "\t\tstatic auto test(T_ e) -> decltype(std::declval<std::istream &>() >> e, std::true_type{});",
            "\t\tstatic std::false_type test(...);",
            "",
            "\t   public:",
            "\t\tstatic constexpr bool value = decltype(test(std::declval<T>()))::value;",
            "\t};",
            "\ttemplate <typename T>",
            "\tstatic constexpr bool is_readable_v = is_readable<T>::value;",
            "\ttemplate <typename IStream, std::enable_if_t<std::conjunction_v<std::is_base_of<std::istream, std::remove_reference_t<IStream>>, std::negation<std::is_const<std::remove_reference_t<IStream>>>>, std::nullptr_t> = nullptr>",
            "\tstruct InputStream {",
            "\t   private:",
            "\t\tusing istream_type = std::remove_reference_t<IStream>;",
            "\t\tIStream is;",
            "\t\tstruct {",
            "\t\t\tInputStream *is;",
            "\t\t\ttemplate <typename T>",
            "\t\t\toperator T() {",
            "\t\t\t\tT e;",
            "\t\t\t\t*is >> e;",
            "\t\t\t\treturn e;",
            "\t\t\t}",
            "\t\t} _reader{this};",
            "",
            "\t   public:",
            "\t\ttemplate <typename IStream_>",
            "\t\tInputStream(IStream_ &&ts) : is(std::move(ts)) {}",
            "\t\ttemplate <typename IStream_>",
            "\t\tInputStream(IStream_ &ts) : is(ts) {}",
            "\t\ttemplate <typename T>",
            "\t\tInputStream &operator>>(T &e) {",
            "\t\t\tif constexpr (is_readable_v<T>)",
            "\t\t\t\tis >> e;",
            "\t\t\telse",
            "\t\t\t\t_read(e);",
            "\t\t\treturn *this;",
            "\t\t}",
            "\t\tauto read() { return _reader; }",
            "\t\ttemplate <typename Head, typename... Tail>",
            "\t\tvoid read(Head &head, Tail &...tails) {",
            "\t\t\t((*this >> head) >> ... >> tails);",
            "\t\t}",
            "\t\tistream_type &get_stream() { return is; }",
            "",
            "\t   private:",
            "\t\tstatic __uint128_t _stou128(const std::string &s) {",
            "\t\t\t__uint128_t ret = 0;",
            "\t\t\tfor (char c : s)",
            "\t\t\t\tif ('0' <= c and c <= '9') ret = 10 * ret + c - '0';",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\tstatic __int128_t _stoi128(const std::string &s) { return (s[0] == '-' ? -1 : +1) * _stou128(s); }",
            "",
            "\t\tvoid _read(__uint128_t &v) { v = _stou128(std::string(_reader)); }",
            "\t\tvoid _read(__int128_t &v) { v = _stoi128(std::string(_reader)); }",
            "\t\ttemplate <typename T, typename U>",
            "\t\tvoid _read(std::pair<T, U> &a) {",
            "\t\t\t*this >> a.first >> a.second;",
            "\t\t}",
            "\t\ttemplate <size_t N = 0, typename... Args>",
            "\t\tvoid _read(std::tuple<Args...> &a) {",
            "\t\t\tif constexpr (N < sizeof...(Args)) *this >> std::get<N>(a), _read<N + 1>(a);",
            "\t\t}",
            "\t\ttemplate <typename Iterable, std::enable_if_t<is_iterable_v<Iterable>, std::nullptr_t> = nullptr>",
            "\t\tvoid _read(Iterable &a) {",
            "\t\t\tfor (auto &e : a) *this >> e;",
            "\t\t}",
            "\t};",
            "\ttemplate <typename IStream>",
            "\tInputStream(IStream &&) -> InputStream<IStream>;",
            "\ttemplate <typename IStream>",
            "\tInputStream(IStream &) -> InputStream<IStream &>;",
            "",
            "\tInputStream cin{std::cin};",
            "",
            "\tauto re() { return cin.read(); }",
            "\ttemplate <typename Head, typename... Tail>",
            "\tvoid re(Head &head, Tail &...tails) {",
            "\t\tcin.read(head, tails...);",
            "\t}",
            "}  // namespace reader",
            "using reader::re;",
            "namespace printer {",
            "#define SFINAE(x, ...)\t\t\t \\",
            "\ttemplate <class, class = void> \\",
            "\tstruct x : std::false_type {}; \\",
            "\ttemplate <class T>\t\t\t \\",
            "\tstruct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "",
            "\tostream &operator<<(ostream &os, const __uint128_t &x) {",
            "\t\tconstexpr uint64_t d19 = 10'000'000'000'000'000'000U;",
            "\t\tif (x > d19) {",
            "\t\t\tos << uint64_t(x / d19) << setfill('0') << setw(19) << uint64_t(x % d19);",
            "\t\t} else {",
            "\t\t\tos << uint64_t(x);",
            "\t\t}",
            "\t\treturn os;",
            "\t}",
            "\tostream &operator<<(ostream &os, const __int128_t &x) {",
            "\t\tif (x >= 0) {",
            "\t\t\tos << __uint128_t(x);",
            "\t\t} else {",
            "\t\t\tos << '-' << __uint128_t(-x);",
            "\t\t}",
            "\t\treturn os;",
            "\t}",
            "",
            "\tSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));",
            "\tSFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "\tSFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "\ttemplate <auto &os, bool print_nd>",
            "\tstruct Writer {",
            "\t\ttemplate <class T>",
            "\t\tconstexpr char Space(const T &) const {",
            "\t\t\treturn print_nd && (Iterable<T>::value or IsTuple<T>::value) ? '\\n' : ' ';",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid Impl(T const &t) const {",
            "\t\t\tif constexpr (DefaultO<T>::value)",
            "\t\t\t\tos << t;",
            "\t\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\t\tint i = 0;",
            "\t\t\t\tfor (auto &&x : t) ((i++) ? (os << Space(x), Impl(x)) : Impl(x));",
            "\t\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\t\tstd::apply(",
            "\t\t\t\t\t[this](auto const &...args) {",
            "\t\t\t\t\t\tint i = 0;",
            "\t\t\t\t\t\t(((i++) ? (os << \" \", Impl(args)) : Impl(args)), ...);",
            "\t\t\t\t\t},",
            "\t\t\t\t\tt);",
            "\t\t\t} else",
            "\t\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for print\");",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid ImplWrapper(T const &t) const {",
            "\t\t\tImpl(t);",
            "\t\t}",
            "\t\ttemplate <class... Ts>",
            "\t\tvoid print(Ts const &...ts) const {",
            "\t\t\t((Impl(ts)), ...);",
            "\t\t}",
            "\t\ttemplate <class F, class... Ts>",
            "\t\tvoid print_with_sep(const std::string &sep, F const &f, Ts const &...ts) const {",
            "\t\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';",
            "\t\t}",
            "\t\tvoid print_with_sep(const std::string &) const { os << '\\n'; }",
            "\t};",
            "",
            "\ttemplate <class... Ts>",
            "\tvoid pr(Ts const &...ts) {",
            "\t\tWriter<cout, true>{}.print(ts...);",
            "\t}",
            "\ttemplate <class... Ts>",
            "\tvoid ps(Ts const &...ts) {",
            "\t\tWriter<cout, true>{}.print_with_sep(\" \", ts...);",
            "\t}",
            "}  // namespace printer",
            "using printer::pr;",
            "using printer::ps;",
            "",
            "void solve();",
            "",
            "int32_t main() {",
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif",
            "\tios::sync_with_stdio(0);",
            "\tcin.tie(0);",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}",
            "",
            "/****************************************************************************************************************************************************/",
            "",
            "void solve() {",
            "\t$0",
            "}"
        ]
    },
    "leet": {
        "prefix": "leet",
        "body": [
            "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math,inline\")",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define writer_out cout",
            "template <typename A, typename B>",
            "ostream &operator<<(ostream &os, const pair<A, B> &p) {",
            "\treturn os << '(' << p.first << \", \" << p.second << ')';",
            "}",
            "template <typename... Args>",
            "ostream &operator<<(ostream &os, const tuple<Args...> &t) {",
            "\tos << '(';",
            "\tapply(",
            "\t\t[&os](const Args &...args) {",
            "\t\t\tsize_t n = 0;",
            "\t\t\t((os << args << (++n != sizeof...(Args) ? \", \" : \"\")), ...);",
            "\t\t},",
            "\t\tt);",
            "\treturn os << ')';",
            "}",
            "template <typename T_container, typename T = typename enable_if<!is_same<T_container, string>::value, typename T_container::value_type>::type>",
            "ostream &operator<<(ostream &os, const T_container &v) {",
            "\tos << '{';",
            "\tstring sep;",
            "\tfor (const T &x : v) os << sep << x, sep = \", \";",
            "\treturn os << '}';",
            "}",
            "void dbg_out() { writer_out << endl; }",
            "template <typename Head, typename... Tail>",
            "void dbg_out(Head H, Tail... T) {",
            "\twriter_out << ' ' << H;",
            "\tdbg_out(T...);",
            "}",
            "#define clg(...) writer_out << '[' << __FILE__ << ':' << __LINE__ << \"] (\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)",
            "",
            "using uint = uint32_t;",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using lll = __int128_t;",
            "using ulll = __uint128_t;",
            "",
            "const ll MOD = 1e9 + 7;",
            "const ll OMOD = 998'244'353;",
            "",
            "",
            "$0",
            ""
        ]
    },
    "interval_set": {
        "prefix": "interval_set",
        "body": [
            "template <typename T>",
            "class IntervalSet {",
            "   public:",
            "\tstatic constexpr T INF = std::numeric_limits<T>::max() / 2;",
            "",
            "\tIntervalSet() {",
            "\t\tst.emplace(INF, INF);",
            "\t\tst.emplace(-INF, -INF);",
            "\t}",
            "",
            "\tbool covered(T x) const { return covered(x, x); }",
            "\tbool covered(T l, T r) const {",
            "\t\tassert(l <= r);",
            "\t\tauto it = --(st.lower_bound({l + 1, l + 1}));",
            "\t\treturn it->first <= l && r <= it->second;",
            "\t}",
            "",
            "\tstd::pair<T, T> covered_by(T x) const { return covered_by(x, x); }",
            "\tstd::pair<T, T> covered_by(T l, T r) const {",
            "\t\tassert(l <= r);",
            "\t\tauto it = --(st.lower_bound({l + 1, l + 1}));",
            "\t\tif (it->first <= l && r <= it->second) return *it;",
            "\t\treturn {-INF, -INF};",
            "\t}",
            "",
            "\tvoid insert(T x) { insert(x, x); }",
            "\tvoid insert(T l, T r) {",
            "\t\tassert(l <= r);",
            "\t\tauto it = --(st.lower_bound({l + 1, l + 1}));",
            "\t\tif (it->first <= l && r <= it->second) return;",
            "\t\tif (it->first <= l && l <= it->second + 1) {",
            "\t\t\tl = it->first;",
            "\t\t\tit = st.erase(it);",
            "\t\t} else {",
            "\t\t\t++it;",
            "\t\t}",
            "\t\twhile (it->second < r) {",
            "\t\t\tit = st.erase(it);",
            "\t\t}",
            "\t\tif (it->first - 1 <= r && r <= it->second) {",
            "\t\t\tr = it->second;",
            "\t\t\tst.erase(it);",
            "\t\t}",
            "\t\tst.emplace(l, r);",
            "\t}",
            "",
            "\tvoid erase(T x) { erase(x, x); }",
            "\tvoid erase(T l, T r) {",
            "\t\tassert(l <= r);",
            "\t\tauto it = --(st.lower_bound({l + 1, l + 1}));",
            "\t\tif (it->first <= l && r <= it->second) {",
            "\t\t\tif (it->first < l) st.emplace(it->first, l - 1);",
            "\t\t\tif (r < it->second) st.emplace(r + 1, it->second);",
            "\t\t\tst.erase(it);",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (it->first <= l && l <= it->second) {",
            "\t\t\tif (it->first < l) st.emplace(it->first, l - 1);",
            "\t\t\tit = st.erase(it);",
            "\t\t} else {",
            "\t\t\t++it;",
            "\t\t}",
            "\t\twhile (it->second <= r) {",
            "\t\t\tit = st.erase(it);",
            "\t\t}",
            "\t\tif (it->first <= r && r <= it->second) {",
            "\t\t\tif (r < it->second) st.emplace(r + 1, it->second);",
            "\t\t\tst.erase(it);",
            "\t\t}",
            "\t}",
            "",
            "\tstd::set<std::pair<T, T>> ranges() const { return st; }",
            "",
            "\tT mex(T x) const {",
            "\t\tauto it = --(st.lower_bound({x + 1, x + 1}));",
            "\t\tif (it->first <= x && x <= it->second) return it->second + 1;",
            "\t\treturn x;",
            "\t}",
            "",
            "   private:",
            "\tstd::set<std::pair<T, T>> st;",
            "};"
        ]
    },
    "coordinate_compression": {
        "prefix": "coordinate_compression",
        "body": [
            "template <typename T>",
            "class Compress {",
            "   public:",
            "\tCompress() = default;",
            "\texplicit Compress(const std::vector<T> &vs) : xs(vs) {",
            "\t\tstd::ranges::sort(xs);",
            "\t\txs.erase(std::ranges::unique(xs).begin(), xs.end());",
            "\t}",
            "",
            "\tint compress(const T &x) const { return std::ranges::lower_bound(xs, x) - xs.begin(); }",
            "",
            "\tstd::vector<int> compress(const std::vector<T> &vs) const {",
            "\t\tstd::vector<int> res(vs.size());",
            "\t\tstd::ranges::transform(vs, res.begin(), [&](const T &x) { return compress(x); });",
            "\t\treturn res;",
            "\t}",
            "",
            "\tT decompress(int i) const { return xs[i]; }",
            "",
            "\tint size() const { return xs.size(); }",
            "",
            "   private:",
            "\tstd::vector<T> xs;",
            "};"
        ]
    },
    "factorize_using_linear_sieve_returning_map": {
        "prefix": "factorize_using_linear_sieve_returning_map",
        "body": [
            "struct Sieve {",
            "\tstd::vector<int> min_factor;",
            "\tstd::vector<int> primes;",
            "\tSieve(int MAXN) : min_factor(MAXN + 1) {",
            "\t\tfor (int d = 2; d <= MAXN; d++) {",
            "\t\t\tif (!min_factor[d]) {",
            "\t\t\t\tmin_factor[d] = d;",
            "\t\t\t\tprimes.emplace_back(d);",
            "\t\t\t}",
            "\t\t\tfor (const auto &p : primes) {",
            "\t\t\t\tif (p > min_factor[d] or int64_t(d) * p > MAXN) break;",
            "\t\t\t\tmin_factor[d * p] = p;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\ttemplate <class T>",
            "\tstd::map<T, int> factorize(T x) const {",
            "\t\tstd::map<T, int> ret;",
            "\t\tassert(x > 0 and x <= ((long long)min_factor.size() - 1) * ((long long)min_factor.size() - 1));",
            "\t\tfor (const auto &p : primes) {",
            "\t\t\tif (x < T(min_factor.size())) break;",
            "\t\t\twhile (!(x % p)) x /= p, ret[p]++;",
            "\t\t}",
            "\t\tif (x >= T(min_factor.size())) ret[x]++, x = 1;",
            "\t\twhile (x > 1) ret[min_factor[x]]++, x /= min_factor[x];",
            "\t\treturn ret;",
            "\t}",
            "};"
        ]
    },
    "dir4": {
        "prefix": "dir4",
        "body": [
            "constexpr int dx[4] = {1, 0, -1, 0};",
            "constexpr int dy[4] = {0, 1, 0, -1};"
        ]
    },
    "dir8": {
        "prefix": "dir8",
        "body": [
            "constexpr int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};",
            "constexpr int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};"
        ]
    },
    "simple_segment_tree_nyaan": {
        "prefix": "simple_segment_tree_nyaan",
        "body": [
            "template <typename T, typename F>",
            "struct seg_tree {",
            "   private:",
            "\tint N;",
            "\tint size;",
            "\tvector<T> seg;",
            "\tconst F f;",
            "\tconst T I;",
            "\tvoid init(int _N) {",
            "\t\tN = _N;",
            "\t\tsize = 1;",
            "\t\twhile (size < N) size <<= 1;",
            "\t\tseg.assign(2 * size, I);",
            "\t}",
            "",
            "\tvoid build() {",
            "\t\tfor (int k = size - 1; k > 0; k--) {",
            "\t\t\tseg[k] = f(seg[2 * k], seg[2 * k + 1]);",
            "\t\t}",
            "\t}",
            "",
            "   public:",
            "\tseg_tree(F _f, const T &I_) : N(0), size(0), f(_f), I(I_) {}",
            "",
            "\tseg_tree(int _N, F _f, const T &I_) : f(_f), I(I_) { init(_N); }",
            "\ttemplate <typename given_type>",
            "\tseg_tree(const vector<given_type> &v, F _f, T I_) : f(_f), I(I_) {",
            "\t\tinit(v.size());",
            "\t\tfor (int i = 0; i < (int)v.size(); i++) {",
            "\t\t\tseg[i + size] = v[i];",
            "\t\t}",
            "\t\tbuild();",
            "\t}",
            "",
            "\tvoid set(int k, T x) {",
            "\t\tk += size;",
            "\t\tseg[k] = x;",
            "\t\twhile (k >>= 1) {",
            "\t\t\tseg[k] = f(seg[2 * k], seg[2 * k + 1]);",
            "\t\t}",
            "\t}",
            "",
            "\tvoid add(int k, T x) {",
            "\t\tk += size;",
            "\t\tseg[k] += x;",
            "\t\twhile (k >>= 1) {",
            "\t\t\tseg[k] = f(seg[2 * k], seg[2 * k + 1]);",
            "\t\t}",
            "\t}",
            "",
            "\t// query to [a, b)",
            "\tT query(int a, int b) {",
            "\t\tT L = I, R = I;",
            "\t\tfor (a += size, b += size; a < b; a >>= 1, b >>= 1) {",
            "\t\t\tif (a & 1) L = f(L, seg[a++]);",
            "\t\t\tif (b & 1) R = f(seg[--b], R);",
            "\t\t}",
            "\t\treturn f(L, R);",
            "\t}",
            "",
            "\tT &operator[](const int &k) { return seg[k + size]; }",
            "};"
        ]
    },
    "dsu_atcoder": {
        "prefix": "dsu_atcoder",
        "body": [
            "struct dsu {",
            "  public:",
            "\tdsu() : _n(0) {}",
            "\texplicit dsu(int n) : _n(n), parent_or_size(n, -1) {}",
            "",
            "\tint merge(int a, int b) {",
            "\t\tassert(0 <= a && a < _n);",
            "\t\tassert(0 <= b && b < _n);",
            "\t\tint x = leader(a), y = leader(b);",
            "\t\tif (x == y)",
            "\t\t\treturn x;",
            "\t\tif (-parent_or_size[x] < -parent_or_size[y])",
            "\t\t\tstd::swap(x, y);",
            "\t\tparent_or_size[x] += parent_or_size[y];",
            "\t\tparent_or_size[y] = x;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tbool same(int a, int b) {",
            "\t\tassert(0 <= a && a < _n);",
            "\t\tassert(0 <= b && b < _n);",
            "\t\treturn leader(a) == leader(b);",
            "\t}",
            "",
            "\tint leader(int a) {",
            "\t\tassert(0 <= a && a < _n);",
            "\t\tif (parent_or_size[a] < 0)",
            "\t\t\treturn a;",
            "\t\treturn parent_or_size[a] = leader(parent_or_size[a]);",
            "\t}",
            "",
            "\tint size(int a) {",
            "\t\tassert(0 <= a && a < _n);",
            "\t\treturn -parent_or_size[leader(a)];",
            "\t}",
            "",
            "\tstd::vector<std::vector<int>> groups() {",
            "\t\tstd::vector<int> leader_buf(_n), group_size(_n);",
            "\t\tfor (int i = 0; i < _n; i++) {",
            "\t\t\tleader_buf[i] = leader(i);",
            "\t\t\tgroup_size[leader_buf[i]]++;",
            "\t\t}",
            "\t\tstd::vector<std::vector<int>> result(_n);",
            "\t\tfor (int i = 0; i < _n; i++) {",
            "\t\t\tresult[i].reserve(group_size[i]);",
            "\t\t}",
            "\t\tfor (int i = 0; i < _n; i++) {",
            "\t\t\tresult[leader_buf[i]].push_back(i);",
            "\t\t}",
            "\t\tresult.erase(",
            "\t\t\tstd::remove_if(result.begin(), result.end(),",
            "\t\t\t\t\t\t   [&](const std::vector<int> &v) { return v.empty(); }),",
            "\t\t\tresult.end());",
            "\t\treturn result;",
            "\t}",
            "",
            "  private:",
            "\tint _n;",
            "\tstd::vector<int> parent_or_size;",
            "};"
        ]
    },
    "doubleendedpriorityqueue": {
        "prefix": "doubleendedpriorityqueue",
        "body": [
            "template <typename T, typename Comp = std::less<T>> struct DoubleEndedPriorityQueue {",
            "\tusing value_type = T;",
            "\tusing compare_type = Comp;",
            "",
            "\tDoubleEndedPriorityQueue() = default;",
            "\tDoubleEndedPriorityQueue(const Comp &comp) : _comp(comp) {}",
            "",
            "\ttemplate <typename InputIterator>",
            "\tDoubleEndedPriorityQueue(InputIterator first, InputIterator last) : _max_heap(first, last) {",
            "\t\tstd::make_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t}",
            "\ttemplate <typename InputIterator>",
            "\tDoubleEndedPriorityQueue(InputIterator first, InputIterator last, const Comp &comp)",
            "\t\t: _comp(comp), _max_heap(first, last) {",
            "\t\tstd::make_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t}",
            "",
            "\ttemplate <typename Iterable, typename = std::void_t<typename Iterable::iterator>>",
            "\tDoubleEndedPriorityQueue(const Iterable &dat) : DoubleEndedPriorityQueue(dat.begin(), dat.end()) {}",
            "\ttemplate <typename Iterable, typename = std::void_t<typename Iterable::iterator>>",
            "\tDoubleEndedPriorityQueue(const Iterable &dat, Comp &comp)",
            "\t\t: DoubleEndedPriorityQueue(dat.begin(), dat.end(), comp) {}",
            "",
            "\tbool empty() const { return size() == 0; }",
            "\tint size() const { return _min_heap.size() + _max_heap.size(); }",
            "",
            "\tvoid push(const value_type &v) {",
            "\t\tif (_min_heap.empty() or _comp(pivot, v)) {",
            "\t\t\t_max_heap.push_back(v);",
            "\t\t\tstd::push_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t\t} else {",
            "\t\t\t_min_heap.push_back(v);",
            "\t\t\tstd::push_heap(_min_heap.begin(), _min_heap.end(), _rev_comp);",
            "\t\t}",
            "\t}",
            "\ttemplate <typename... Args> void emplace(Args &&...args) {",
            "\t\tpush(value_type(std::forward<Args>(args)...));",
            "\t}",
            "",
            "\tconst value_type &max() const {",
            "\t\tassert(size());",
            "\t\treturn _max_heap.size() ? _max_heap.front() : pivot;",
            "\t}",
            "\tconst value_type &min() {",
            "\t\tensure_min_heap_nonempty();",
            "\t\treturn _min_heap.front();",
            "\t}",
            "\tconst value_type &top() const { return max(); }",
            "",
            "\tvalue_type pop_max() {",
            "\t\tensure_max_heap_nonempty();",
            "\t\tstd::pop_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t\tvalue_type res = std::move(_max_heap.back());",
            "\t\t_max_heap.pop_back();",
            "\t\treturn res;",
            "\t}",
            "\tvalue_type pop_min() {",
            "\t\tensure_min_heap_nonempty();",
            "\t\tstd::pop_heap(_min_heap.begin(), _min_heap.end(), _rev_comp);",
            "\t\tvalue_type res = std::move(_min_heap.back());",
            "\t\t_min_heap.pop_back();",
            "\t\treturn res;",
            "\t}",
            "\tvalue_type pop() { return pop_max(); }",
            "",
            "\tstd::vector<value_type> dump_sorted() const {",
            "\t\tstd::vector<value_type> res_l(_min_heap), res_r(_max_heap);",
            "\t\tstd::sort(res_l.begin(), res_l.end(), _comp);",
            "\t\tstd::sort(res_r.begin(), res_r.end(), _comp);",
            "\t\tres_l.reserve(size());",
            "\t\tstd::copy(res_r.begin(), res_r.end(), std::back_inserter(res_l));",
            "\t\treturn res_l;",
            "\t}",
            "",
            "  private:",
            "\tcompare_type _comp;",
            "\tstruct {",
            "\t\tcompare_type *comp;",
            "\t\tbool operator()(const value_type &x, const value_type &y) { return (*comp)(y, x); }",
            "\t} _rev_comp{&_comp};",
            "",
            "\tstd::vector<value_type> _max_heap, _min_heap;",
            "\tvalue_type pivot;",
            "",
            "\tvoid ensure_min_heap_nonempty() {",
            "\t\tconst int siz = size();",
            "\t\tassert(siz);",
            "\t\tif (not _min_heap.empty())",
            "\t\t\treturn;",
            "\t\tif (siz == 1) {",
            "\t\t\tstd::swap(_min_heap, _max_heap);",
            "\t\t\tpivot = _min_heap.front();",
            "\t\t} else {",
            "\t\t\tconst int mid = (siz + 1) >> 1;",
            "\t\t\tstd::nth_element(_max_heap.begin(), _max_heap.begin() + mid - 1, _max_heap.end(), _comp);",
            "\t\t\tpivot = _max_heap[mid - 1];",
            "\t\t\t_min_heap.reserve(mid);",
            "\t\t\tstd::move(_max_heap.begin(), _max_heap.begin() + mid, std::back_inserter(_min_heap));",
            "\t\t\t_max_heap.erase(_max_heap.begin(), _max_heap.begin() + mid);",
            "\t\t\tstd::make_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t\t\tstd::make_heap(_min_heap.begin(), _min_heap.end(), _rev_comp);",
            "\t\t}",
            "\t}",
            "\tvoid ensure_max_heap_nonempty() {",
            "\t\tconst int siz = size();",
            "\t\tassert(siz);",
            "\t\tif (not _max_heap.empty())",
            "\t\t\treturn;",
            "\t\tif (siz == 1) {",
            "\t\t\tstd::swap(_min_heap, _max_heap);",
            "\t\t} else {",
            "\t\t\tconst int mid = siz >> 1;",
            "\t\t\tstd::nth_element(_min_heap.begin(), _min_heap.begin() + mid - 1, _min_heap.end(), _comp);",
            "\t\t\tpivot = _min_heap[mid - 1];",
            "\t\t\t_max_heap.reserve(siz - mid);",
            "\t\t\tstd::move(_min_heap.begin() + mid, _min_heap.end(), std::back_inserter(_max_heap));",
            "\t\t\t_min_heap.erase(_min_heap.begin() + mid, _min_heap.end());",
            "\t\t\tstd::make_heap(_max_heap.begin(), _max_heap.end(), _comp);",
            "\t\t\tstd::make_heap(_min_heap.begin(), _min_heap.end(), _rev_comp);",
            "\t\t}",
            "\t}",
            "};"
        ]
    },
    "minmaxheap": {
        "prefix": "minmaxheap",
        "body": [
            "template <typename T> class MinMaxHeap {",
            "  public:",
            "\tMinMaxHeap() = default;",
            "\texplicit MinMaxHeap(const std::vector<T> &v) : heap(v) {",
            "\t\tfor (int i = (int)heap.size() / 2 - 1; i >= 0; --i) {",
            "\t\t\tpushdown(i);",
            "\t\t}",
            "\t}",
            "",
            "\tvoid insert(T x) {",
            "\t\theap.push_back(x);",
            "\t\tpushup(heap.size() - 1);",
            "\t}",
            "",
            "\tT min_element() const {",
            "\t\tassert(!heap.empty());",
            "\t\treturn heap[0];",
            "\t}",
            "",
            "\tT max_element() const {",
            "\t\tassert(!heap.empty());",
            "\t\tif (heap.size() <= 2)",
            "\t\t\treturn heap.back();",
            "\t\treturn std::max(heap[1], heap[2]);",
            "\t}",
            "",
            "\tvoid erase_min() {",
            "\t\tassert(!heap.empty());",
            "\t\theap[0] = heap.back();",
            "\t\theap.pop_back();",
            "\t\tpushdown(0);",
            "\t}",
            "",
            "\tvoid erase_max() {",
            "\t\tassert(!heap.empty());",
            "\t\tif (heap.size() <= 2) {",
            "\t\t\theap.pop_back();",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tif (heap.size() == 3) {",
            "\t\t\theap[1] = std::min(heap[1], heap[2]);",
            "\t\t\theap.pop_back();",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint i = heap[1] > heap[2] ? 1 : 2;",
            "\t\theap[i] = heap.back();",
            "\t\theap.pop_back();",
            "\t\tpushdown(i);",
            "\t}",
            "",
            "  private:",
            "\tstd::vector<T> heap;",
            "",
            "\tvoid pushdown(int i) {",
            "\t\tint d = std::bit_width((unsigned int)i + 1) - 1;",
            "\t\tint n = heap.size();",
            "",
            "\t\twhile (true) {",
            "\t\t\tint l = 2 * i + 1, r = l + 1;",
            "\t\t\tif (l >= n)",
            "\t\t\t\treturn;",
            "",
            "\t\t\tint m = i;",
            "\t\t\tstd::vector<int> check = {l, r, 2 * l + 1, 2 * l + 2, 2 * r + 1, 2 * r + 2};",
            "\t\t\tfor (int j : check) {",
            "\t\t\t\tif (j < n && ((d % 2) ^ (heap[j] < heap[m])))",
            "\t\t\t\t\tm = j;",
            "\t\t\t}",
            "",
            "\t\t\tif (m >= 2 * l + 1) { ",
            "\t\t\t\tif ((d % 2) ^ (heap[m] < heap[i])) {",
            "\t\t\t\t\tstd::swap(heap[m], heap[i]);",
            "\t\t\t\t\tint p = (m - 1) / 2;",
            "\t\t\t\t\tif ((d % 2) ^ (heap[m] > heap[p]))",
            "\t\t\t\t\t\tstd::swap(heap[m], heap[p]);",
            "\t\t\t\t\ti = m;",
            "\t\t\t\t} else {",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t} else {",
            "\t\t\t\tstd::swap(heap[m], heap[i]);",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "",
            "\tvoid pushup(int i) {",
            "\t\tif (i == 0)",
            "\t\t\treturn;",
            "\t\tint p = (i - 1) / 2;",
            "\t\tint d = std::bit_width((unsigned int)i + 1) - 1;",
            "\t\tif ((d % 2) ^ (heap[i] > heap[p])) {",
            "\t\t\tstd::swap(heap[i], heap[p]);",
            "\t\t\ti = p;",
            "\t\t\t--d;",
            "\t\t}",
            "\t\twhile (i >= 3) { ",
            "\t\t\tint g = ((i - 1) / 2 - 1) / 2;",
            "\t\t\tif ((d % 2) ^ (heap[i] > heap[g]))",
            "\t\t\t\tbreak;",
            "\t\t\tstd::swap(heap[i], heap[g]);",
            "\t\t\ti = g;",
            "\t\t}",
            "\t}",
            "};"
        ]
    },
    "prime_factorization_using_linear_sieve_returning_vector<pair>": {
        "prefix": "prime_factorize_using_linear_sieve_returning_vector<pair>",
        "body": [
            "",
            "class LinearSieve {",
            "   public:",
            "\tLinearSieve(const int n) : _n(n), min_prime_factor(std::vector<int>(n + 1)) {",
            "\t\tstd::iota(min_prime_factor.begin(), min_prime_factor.end(), 0);",
            "\t\tprime_list.reserve(_n / 20);",
            "\t\tfor (int d = 2; d <= _n; ++d) {",
            "\t\t\tif (min_prime_factor[d] == d) prime_list.push_back(d);",
            "\t\t\tconst int prime_max = std::min(min_prime_factor[d], _n / d);",
            "\t\t\tfor (int prime : prime_list) {",
            "\t\t\t\tif (prime > prime_max) break;",
            "\t\t\t\tmin_prime_factor[prime * d] = prime;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tstd::vector<std::pair<int, int>> factorize(int n) const noexcept {",
            "\t\tassert(0 < n and n <= _n);",
            "\t\tstd::vector<std::pair<int, int>> prime_powers;",
            "\t\twhile (n > 1) {",
            "\t\t\tint p = min_prime_factor[n], c = 0;",
            "\t\t\tdo {",
            "\t\t\t\tn /= p, ++c;",
            "\t\t\t} while (n % p == 0);",
            "\t\t\tprime_powers.emplace_back(p, c);",
            "\t\t}",
            "\t\treturn prime_powers;",
            "\t}",
            "\tconst int _n;",
            "\tstd::vector<int> min_prime_factor;",
            "\tstd::vector<int> prime_list;",
            "};",
            ""
        ]
    },
    "ext_gcd": {
        "prefix": "ext_gcd",
        "body": [
            "",
            "constexpr long long safe_mod(long long x, long long m) {",
            "\tx %= m;",
            "\treturn x < 0 ? x + m : x;",
            "}",
            "",
            "// returns {x,y,g} s.t. ax+by=g=gcd(a,b)>=0.",
            "std::tuple<long long, long long, long long> ext_gcd(long long a, long long b) {",
            "\tlong long x = 1, y = 0;",
            "\tlong long z = 0, w = 1;",
            "\twhile (b) {",
            "\t\tlong long p = a / b, q = a % b;",
            "\t\tx -= y * p, std::swap(x, y);",
            "\t\tz -= w * p, std::swap(z, w);",
            "\t\ta = b, b = q;",
            "\t}",
            "\tif (a < 0) {",
            "\t\tx = -x, z = -z, a = -a;",
            "\t}",
            "\treturn {x, z, a};",
            "}",
            "",
            "// returns {x,g} s.t. a*x=g (mod m)",
            "std::pair<long long, long long> gcd_inv(long long a, long long m) {",
            "\tauto [x, y, g] = ext_gcd(a, m);",
            "\treturn {safe_mod(x, m), g};",
            "}",
            "",
            "// returns x s.t. a*x=1 (mod m) if exists, otherwise throws runtime error.",
            "long long inv_mod(long long a, long long mod) {",
            "\tauto [inv, y, g] = ext_gcd(a, mod);",
            "\tassert(g == 1);",
            "\treturn safe_mod(inv, mod);",
            "}",
            ""
        ]
    },
    "linear_sieve": {
        "prefix": "linear_sieve",
        "body": [
            "vector<int> spf;",
            "vector<bool> ipm;",
            "vector<int> pm;",
            "",
            "void sieve(int maximum) {",
            "\tmaximum = max(maximum, 1);",
            "\tspf.assign(maximum + 1, 0);",
            "\tipm.assign(maximum + 1, true);",
            "\tipm[0] = ipm[1] = false;",
            "\tpm = {};",
            "",
            "\tfor (int i = 2; i <= maximum; i++) {",
            "\t\tif (ipm[i]) {",
            "\t\t\tspf[i] = i;",
            "\t\t\tpm.push_back(i);",
            "\t\t}",
            "",
            "\t\tfor (int p : pm) {",
            "\t\t\tif (p > spf[i] || int64_t(i) * p > maximum) break;",
            "",
            "\t\t\tipm[i * p] = false;",
            "\t\t\tspf[i * p] = p;",
            "\t\t}",
            "\t}",
            "}"
        ]
    },
    "factorizer_tourist": {
        "prefix": "factorizer_tourist",
        "body": [
            "",
            "template <typename T>",
            "T inverse(T a, T m) {",
            "\tT u = 0, v = 1;",
            "\twhile (a != 0) {",
            "\t\tT t = m / a;",
            "\t\tm -= t * a;",
            "\t\tswap(a, m);",
            "\t\tu -= t * v;",
            "\t\tswap(u, v);",
            "\t}",
            "\tassert(m == 1);",
            "\treturn u;",
            "}",
            "",
            "template <typename T>",
            "class Modular {",
            "  public:",
            "\tusing Type = typename decay<decltype(T::value)>::type;",
            "",
            "\tconstexpr Modular() : value() {}",
            "\ttemplate <typename U>",
            "\tModular(const U &x) {",
            "\t\tvalue = normalize(x);",
            "\t}",
            "",
            "\ttemplate <typename U>",
            "\tstatic Type normalize(const U &x) {",
            "\t\tType v;",
            "\t\tif (-mod() <= x && x < mod())",
            "\t\t\tv = static_cast<Type>(x);",
            "\t\telse",
            "\t\t\tv = static_cast<Type>(x % mod());",
            "\t\tif (v < 0)",
            "\t\t\tv += mod();",
            "\t\treturn v;",
            "\t}",
            "",
            "\tconst Type &operator()() const { return value; }",
            "\ttemplate <typename U>",
            "\texplicit operator U() const { return static_cast<U>(value); }",
            "\tconstexpr static Type mod() { return T::value; }",
            "",
            "\tModular &operator+=(const Modular &other) {",
            "\t\tvalue += other.value;",
            "\t\tvalue -= (value >= mod()) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\tModular &operator-=(const Modular &other) {",
            "\t\tvalue -= other.value;",
            "\t\tvalue += (value < 0) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U>",
            "\tModular &operator+=(const U &other) { return *this += Modular(other); }",
            "\ttemplate <typename U>",
            "\tModular &operator-=(const U &other) { return *this -= Modular(other); }",
            "\tModular &operator++() { return *this += 1; }",
            "\tModular &operator--() { return *this -= 1; }",
            "\tModular operator++(int) {",
            "\t\tModular result(*this);",
            "\t\t*this += 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator--(int) {",
            "\t\tModular result(*this);",
            "\t\t*this -= 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator-() const { return Modular(-value); }",
            "",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {",
            "\t\tint64_t q = int64_t(static_cast<long double>(value) * rhs.value / mod());",
            "\t\tvalue = normalize(value * rhs.value - q * mod());",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(value * rhs.value);",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tModular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
            "",
            "\tfriend const Type &abs(const Modular &x) { return x.value; }",
            "",
            "\ttemplate <typename U>",
            "\tfriend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename U>",
            "\tfriend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename V, typename U>",
            "\tfriend V &operator>>(V &stream, Modular<U> &number);",
            "",
            "  private:",
            "\tType value;",
            "};",
            "",
            "template <typename T>",
            "bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }",
            "template <typename T, typename U>",
            "bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }",
            "template <typename T, typename U>",
            "bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }",
            "",
            "template <typename T>",
            "bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U>",
            "bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U>",
            "bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "",
            "template <typename T>",
            "bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }",
            "",
            "template <typename T>",
            "Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
            "",
            "template <typename T>",
            "Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
            "",
            "template <typename T>",
            "Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
            "",
            "template <typename T>",
            "Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
            "",
            "template <typename T, typename U>",
            "Modular<T> power(const Modular<T> &a, const U &b) {",
            "\tassert(b >= 0);",
            "\tModular<T> x = a, res = 1;",
            "\tU p = b;",
            "\twhile (p > 0) {",
            "\t\tif (p & 1)",
            "\t\t\tres *= x;",
            "\t\tx *= x;",
            "\t\tp >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "template <typename T>",
            "bool IsZero(const Modular<T> &number) {",
            "\treturn number() == 0;",
            "}",
            "",
            "template <typename T>",
            "string to_string(const Modular<T> &number) {",
            "\treturn to_string(number());",
            "}",
            "",
            "template <typename U, typename T>",
            "U &operator<<(U &stream, const Modular<T> &number) {",
            "\treturn stream << number();",
            "}",
            "",
            "template <typename U, typename T>",
            "U &operator>>(U &stream, Modular<T> &number) {",
            "\ttypename common_type<typename Modular<T>::Type, int64_t>::type x;",
            "\tstream >> x;",
            "\tnumber.value = Modular<T>::normalize(x);",
            "\treturn stream;",
            "}",
            "namespace factorizer {",
            "",
            "\ttemplate <typename T>",
            "\tstruct FactorizerVarMod {",
            "\t\tstatic T value;",
            "\t};",
            "\ttemplate <typename T>",
            "\tT FactorizerVarMod<T>::value;",
            "",
            "\ttemplate <typename T>",
            "\tbool IsPrime(T n, const vector<T> &bases) {",
            "\t\tif (n < 2) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t\tvector<T> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
            "\t\tfor (const T &x : small_primes) {",
            "\t\t\tif (n % x == 0) {",
            "\t\t\t\treturn n == x;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (n < 31 * 31) {",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tint s = 0;",
            "\t\tT d = n - 1;",
            "\t\twhile ((d & 1) == 0) {",
            "\t\t\td >>= 1;",
            "\t\t\ts++;",
            "\t\t}",
            "\t\tFactorizerVarMod<T>::value = n;",
            "\t\tfor (const T &a : bases) {",
            "\t\t\tif (a % n == 0) {",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tModular<FactorizerVarMod<T>> cur = a;",
            "\t\t\tcur = power(cur, d);",
            "\t\t\tif (cur == 1) {",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tbool witness = true;",
            "\t\t\tfor (int r = 0; r < s; r++) {",
            "\t\t\t\tif (cur == n - 1) {",
            "\t\t\t\t\twitness = false;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tcur *= cur;",
            "\t\t\t}",
            "\t\t\tif (witness) {",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "",
            "\tbool IsPrime(int64_t n) {",
            "\t\treturn IsPrime(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});",
            "\t}",
            "",
            "\tbool IsPrime(int32_t n) {",
            "\t\treturn IsPrime(n, {2, 7, 61});",
            "\t}",
            "",
            "\tvector<int> least = {0, 1};",
            "\tvector<int> primes;",
            "\tint precalculated = 1;",
            "",
            "\tvoid RunLinearSieve(int n) {",
            "\t\tn = max(n, 1);",
            "\t\tleast.assign(n + 1, 0);",
            "\t\tprimes.clear();",
            "\t\tfor (int i = 2; i <= n; i++) {",
            "\t\t\tif (least[i] == 0) {",
            "\t\t\t\tleast[i] = i;",
            "\t\t\t\tprimes.push_back(i);",
            "\t\t\t}",
            "\t\t\tfor (int x : primes) {",
            "\t\t\t\tif (x > least[i] || i * x > n) {",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tleast[i * x] = x;",
            "\t\t\t}",
            "\t\t}",
            "\t\tprecalculated = n;",
            "\t}",
            "",
            "\tvoid RunSieve(int n) {",
            "\t\tRunLinearSieve(n);",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<pair<T, int>> MergeFactors(const vector<pair<T, int>> &a, const vector<pair<T, int>> &b) {",
            "\t\tvector<pair<T, int>> c;",
            "\t\tint i = 0;",
            "\t\tint j = 0;",
            "\t\twhile (i < (int)a.size() || j < (int)b.size()) {",
            "\t\t\tif (i < (int)a.size() && j < (int)b.size() && a[i].first == b[j].first) {",
            "\t\t\t\tc.emplace_back(a[i].first, a[i].second + b[j].second);",
            "\t\t\t\t++i;",
            "\t\t\t\t++j;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif (j == (int)b.size() || (i < (int)a.size() && a[i].first < b[j].first)) {",
            "\t\t\t\tc.push_back(a[i++]);",
            "\t\t\t} else {",
            "\t\t\t\tc.push_back(b[j++]);",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn c;",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<pair<T, int>> RhoC(const T &n, const T &c) {",
            "\t\tif (n <= 1) {",
            "\t\t\treturn {};",
            "\t\t}",
            "\t\tif ((n & 1) == 0) {",
            "\t\t\treturn MergeFactors({{2, 1}}, RhoC(n / 2, c));",
            "\t\t}",
            "\t\tif (IsPrime(n)) {",
            "\t\t\treturn {{n, 1}};",
            "\t\t}",
            "\t\tFactorizerVarMod<T>::value = n;",
            "\t\tModular<FactorizerVarMod<T>> x = 2;",
            "\t\tModular<FactorizerVarMod<T>> saved = 2;",
            "\t\tT power = 1;",
            "\t\tT lam = 1;",
            "\t\twhile (true) {",
            "\t\t\tx = x * x + c;",
            "\t\t\tT g = __gcd((x - saved)(), n);",
            "\t\t\tif (g != 1) {",
            "\t\t\t\treturn MergeFactors(RhoC(g, c + 1), RhoC(n / g, c + 1));",
            "\t\t\t}",
            "\t\t\tif (power == lam) {",
            "\t\t\t\tsaved = x;",
            "\t\t\t\tpower <<= 1;",
            "\t\t\t\tlam = 0;",
            "\t\t\t}",
            "\t\t\tlam++;",
            "\t\t}",
            "\t\treturn {};",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<pair<T, int>> Rho(const T &n) {",
            "\t\treturn RhoC(n, static_cast<T>(1));",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<pair<T, int>> Factorize(T x) {",
            "\t\tif (x <= 1) {",
            "\t\t\treturn {};",
            "\t\t}",
            "\t\tif (x <= precalculated) {",
            "\t\t\tvector<pair<T, int>> ret;",
            "\t\t\twhile (x > 1) {",
            "\t\t\t\tif (!ret.empty() && ret.back().first == least[x]) {",
            "\t\t\t\t\tret.back().second++;",
            "\t\t\t\t} else {",
            "\t\t\t\t\tret.emplace_back(least[x], 1);",
            "\t\t\t\t}",
            "\t\t\t\tx /= least[x];",
            "\t\t\t}",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\tif (x <= static_cast<int64_t>(precalculated) * precalculated) {",
            "\t\t\tvector<pair<T, int>> ret;",
            "\t\t\tif (!IsPrime(x)) {",
            "\t\t\t\tfor (T i : primes) {",
            "\t\t\t\t\tT t = x / i;",
            "\t\t\t\t\tif (i > t) {",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tif (x == t * i) {",
            "\t\t\t\t\t\tint cnt = 0;",
            "\t\t\t\t\t\twhile (x % i == 0) {",
            "\t\t\t\t\t\t\tx /= i;",
            "\t\t\t\t\t\t\tcnt++;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tret.emplace_back(i, cnt);",
            "\t\t\t\t\t\tif (IsPrime(x)) {",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif (x > 1) {",
            "\t\t\t\tret.emplace_back(x, 1);",
            "\t\t\t}",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\treturn Rho(x);",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<T> BuildDivisorsFromFactors(const vector<pair<T, int>> &factors) {",
            "\t\tvector<T> divisors = {1};",
            "\t\tfor (auto &p : factors) {",
            "\t\t\tint sz = (int)divisors.size();",
            "\t\t\tfor (int i = 0; i < sz; i++) {",
            "\t\t\t\tT cur = divisors[i];",
            "\t\t\t\tfor (int j = 0; j < p.second; j++) {",
            "\t\t\t\t\tcur *= p.first;",
            "\t\t\t\t\tdivisors.push_back(cur);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tsort(divisors.begin(), divisors.end());",
            "\t\treturn divisors;",
            "\t}",
            "\ttemplate <typename T>",
            "\tstruct PrimitiveVarMod {",
            "\t\tstatic T value;",
            "\t};",
            "\ttemplate <typename T>",
            "\tT PrimitiveVarMod<T>::value;",
            "",
            "\ttemplate <typename T, class F>",
            "\tT GetPrimitiveRoot(const T &modulo, const F &factorize) {",
            "\t\tif (modulo <= 0) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tif (modulo == 1 || modulo == 2 || modulo == 4) {",
            "\t\t\treturn modulo - 1;",
            "\t\t}",
            "\t\tvector<pair<T, int>> modulo_factors = factorize(modulo);",
            "\t\tif (modulo_factors[0].first == 2 && (modulo_factors[0].second != 1 || modulo_factors.size() != 2)) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tif (modulo_factors[0].first != 2 && modulo_factors.size() != 1) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tset<T> phi_factors;",
            "\t\tT phi = modulo;",
            "\t\tfor (auto &d : modulo_factors) {",
            "\t\t\tphi = phi / d.first * (d.first - 1);",
            "\t\t\tif (d.second > 1) {",
            "\t\t\t\tphi_factors.insert(d.first);",
            "\t\t\t}",
            "\t\t\tfor (auto &e : factorize(d.first - 1)) {",
            "\t\t\t\tphi_factors.insert(e.first);",
            "\t\t\t}",
            "\t\t}",
            "\t\tPrimitiveVarMod<T>::value = modulo;",
            "\t\tModular<PrimitiveVarMod<T>> gen = 2;",
            "\t\twhile (gen != 0) {",
            "\t\t\tif (power(gen, phi) != 1) {",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tbool ok = true;",
            "\t\t\tfor (auto &p : phi_factors) {",
            "\t\t\t\tif (power(gen, phi / p) == 1) {",
            "\t\t\t\t\tok = false;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif (ok) {",
            "\t\t\t\treturn gen();",
            "\t\t\t}",
            "\t\t\tgen++;",
            "\t\t}",
            "\t\tassert(false);",
            "\t\treturn -1;",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tT get_primitive_root(const T &modulo) {",
            "\t\treturn GetPrimitiveRoot(modulo, Factorize<T>);",
            "\t}",
            "} // namespace factorizer",
            "using factorizer::BuildDivisorsFromFactors;",
            "using factorizer::Factorize;",
            "using factorizer::get_primitive_root;",
            "using factorizer::MergeFactors;"
        ]
    },
    "is_prime": {
        "prefix": "is_prime",
        "body": [
            "inline constexpr uint64_t mod_power(uint64_t x, uint64_t n, uint64_t m) {",
            "\tif (m == 1)",
            "\t\treturn 0;",
            "\tuint64_t r = 1;",
            "\tuint64_t y = x % m;",
            "\twhile (n) {",
            "\t\tif (n & 1)",
            "\t\t\tr = (uint64_t)((__uint128_t)(1) * r * y % m);",
            "\t\ty = (uint64_t)((__uint128_t)(1) * y * y % m);",
            "\t\tn >>= 1;",
            "\t}",
            "\treturn r;",
            "}",
            "inline bool is_prime(uint64_t n) {",
            "\tif (n % 2 == 0)",
            "\t\treturn false;",
            "\tuint64_t d = n - 1;",
            "\twhile (d % 2 == 0)",
            "\t\td /= 2;",
            "\tfor (uint64_t a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {",
            "\t\tif (a % n == 0)",
            "\t\t\treturn true;",
            "\t\tuint64_t t = d;",
            "\t\tuint64_t y = mod_power(a, t, n);",
            "\t\twhile (t != n - 1 && y != 1 && y != n - 1) {",
            "\t\t\ty = (uint64_t)((__uint128_t)(1) * y * y % n);",
            "\t\t\tt <<= 1;",
            "\t\t}",
            "\t\tif (y != n - 1 && t % 2 == 0) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "\treturn true;",
            "}"
        ]
    },
    "spf_and_primes": {
        "prefix": "spf_and_primes",
        "body": [
            "inline std::vector<int> get_spf_table(int n) {",
            "\t\tstd::vector<int> table(n + 1, -1);",
            "\t\tstd::vector<int> primes;",
            "\t\tfor (int d = 2; d <= n; d++) {",
            "\t\t\tif (table[d] == -1) {",
            "\t\t\t\tprimes.push_back(d);",
            "\t\t\t\ttable[d] = d;",
            "\t\t\t}",
            "\t\t\tfor (int p : primes) {",
            "\t\t\t\tif (p * d > n || p > table[d])",
            "\t\t\t\t\tbreak;",
            "\t\t\t\ttable[p * d] = p;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn table;",
            "\t}",
            "",
            "\tinline std::vector<int> get_prime_table(int n) {",
            "\t\tstd::vector<int> table = get_spf_table(n);",
            "\t\tstd::vector<int> p;",
            "\t\tfor (int i = 2; i <= n; i++) {",
            "\t\t\tif (table[i] == i)",
            "\t\t\t\tp.push_back(i);",
            "\t\t}",
            "\t\treturn p;",
            "\t}"
        ]
    },
    "sort_unique": {
        "prefix": "sort_unique",
        "body": [
            "template <typename T> void sort_unique(vector<T> &v) {",
            "\tsort(v.begin(), v.end());",
            "\tv.erase(unique(v.begin(), v.end()), v.end());",
            "}"
        ]
    },
    "range_set": {
        "prefix": "range_set",
        "body": [
            "template <typename T, bool merge_adjacent_segment = true>",
            "struct RangeSet : public std::map<T, T> {",
            "  public:",
            "\tRangeSet() : _size(0) {}",
            "",
            "\tT size() const { return number_of_elements(); }",
            "\tT number_of_elements() const { return _size; }",
            "\tint number_of_ranges() const { return std::map<T, T>::size(); }",
            "",
            "\tbool contains(T x) const {",
            "\t\tauto it = this->upper_bound(x);",
            "\t\treturn it != this->begin() and x <= std::prev(it)->second;",
            "\t}",
            "",
            "\tauto find_range(T x) const {",
            "\t\tauto it = this->upper_bound(x);",
            "\t\treturn it != this->begin() and x <= (--it)->second ? it : this->end();",
            "\t}",
            "",
            "\tbool in_the_same_range(T x, T y) const {",
            "\t\tauto it = get_containing_range(x);",
            "\t\treturn it != this->end() and it->first <= y and y <= it->second;",
            "\t}",
            "",
            "\tT insert(T x) {",
            "\t\treturn insert(x, x);",
            "\t}",
            "",
            "\tT insert(T l, T r) {",
            "\t\tif (l > r)",
            "\t\t\treturn 0;",
            "\t\tauto it = this->upper_bound(l);",
            "\t\tif (it != this->begin() and is_mergeable(std::prev(it)->second, l)) {",
            "\t\t\tit = std::prev(it);",
            "\t\t\tl = std::min(l, it->first);",
            "\t\t}",
            "\t\tT inserted = 0;",
            "\t\tfor (; it != this->end() and is_mergeable(r, it->first); it = std::map<T, T>::erase(it)) {",
            "\t\t\tauto [cl, cr] = *it;",
            "\t\t\tr = std::max(r, cr);",
            "\t\t\tinserted -= cr - cl + 1;",
            "\t\t}",
            "\t\tinserted += r - l + 1;",
            "\t\t(*this)[l] = r;",
            "\t\t_size += inserted;",
            "\t\treturn inserted;",
            "\t}",
            "",
            "\tT erase(T x) {",
            "\t\treturn erase(x, x);",
            "\t}",
            "",
            "\tT erase(T l, T r) {",
            "\t\tif (l > r)",
            "\t\t\treturn 0;",
            "\t\tT tl = l, tr = r;",
            "\t\tauto it = this->upper_bound(l);",
            "\t\tif (it != this->begin() and l <= std::prev(it)->second) {",
            "\t\t\tit = std::prev(it);",
            "\t\t\ttl = it->first;",
            "\t\t}",
            "\t\tT erased = 0;",
            "\t\tfor (; it != this->end() and it->first <= r; it = std::map<T, T>::erase(it)) {",
            "\t\t\tauto [cl, cr] = *it;",
            "\t\t\ttr = cr;",
            "\t\t\terased += cr - cl + 1;",
            "\t\t}",
            "\t\tif (tl < l) {",
            "\t\t\t(*this)[tl] = l - 1;",
            "\t\t\terased -= l - tl;",
            "\t\t}",
            "\t\tif (r < tr) {",
            "\t\t\t(*this)[r + 1] = tr;",
            "\t\t\terased -= tr - r;",
            "\t\t}",
            "\t\t_size -= erased;",
            "\t\treturn erased;",
            "\t}",
            "",
            "\tT minimum_excluded(T lower = 0) const {",
            "\t\tstatic_assert(merge_adjacent_segment);",
            "\t\tauto it = find_range(lower);",
            "\t\treturn it == this->end() ? lower : it->second + 1;",
            "\t}",
            "",
            "\tT maximum_excluded(T upper) const {",
            "\t\tstatic_assert(merge_adjacent_segment);",
            "\t\tauto it = find_range(upper);",
            "\t\treturn it == this->end() ? upper : it->first - 1;",
            "\t}",
            "",
            "  private:",
            "\tT _size;",
            "",
            "\tbool is_mergeable(T cur_r, T next_l) {",
            "\t\treturn next_l <= cur_r + merge_adjacent_segment;",
            "\t}",
            "};",
            "// https://suisen-cp.github.io/cp-library-cpp/library/datastructure/util/range_set.hpp"
        ]
    }
}