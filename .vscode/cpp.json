{
    "simple_segment_tree_myself": {
        "prefix": "simple_segment_tree_myself",
        "body": [
            "template <typename tree_type, typename F>",
            "class seg_tree {",
            "\tvector<tree_type> tree;",
            "\tF op;",
            "\ttree_type identity;",
            "\tint n;",
            "\ttemplate <typename given_type>",
            "\tvoid build(int id, int l, int r, vector<given_type> &given) {",
            "\t\tif (l == r) {",
            "\t\t\ttree[id] = given[l];",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tbuild(lc, l, mid, given);",
            "\t\tbuild(rc, mid + 1, r, given);",
            "\t\ttree[id] = op(tree[lc], tree[rc]);",
            "\t}",
            "\ttree_type query(int id, int l, int r, int ql, int qr) {",
            "\t\tif (l > qr || r < ql) {",
            "\t\t\treturn identity;",
            "\t\t}",
            "\t\tif (l >= ql && r <= qr) {",
            "\t\t\treturn tree[id];",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\ttree_type lhs = query(lc, l, mid, ql, qr);",
            "\t\ttree_type rhs = query(rc, mid + 1, r, ql, qr);",
            "\t\treturn op(lhs, rhs);",
            "\t}",
            "\tvoid set(int id, int l, int r, int ind, tree_type value) {",
            "\t\tif (l == r && l == ind) {",
            "\t\t\ttree[id] = value;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tif (ind <= mid)",
            "\t\t\tset(lc, l, mid, ind, value);",
            "\t\telse",
            "\t\t\tset(rc, mid + 1, r, ind, value);",
            "\t\ttree[id] = op(tree[lc], tree[rc]);",
            "\t}",
            "",
            "\tvoid add(int id, int l, int r, int ind, tree_type value) {",
            "\t\tif (l == r && l == ind) {",
            "\t\t\ttree[id] += value;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tif (ind <= mid)",
            "\t\t\tadd(lc, l, mid, ind, value);",
            "\t\telse",
            "\t\t\tadd(rc, mid + 1, r, ind, value);",
            "\t\ttree[id] = op(tree[lc], tree[rc]);",
            "\t}",
            "",
            "\ttree_type get(int id, int l, int r, int ind) {",
            "\t\tif (l == r && l == ind) {",
            "\t\t\treturn tree[id];",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tif (ind <= mid) {",
            "\t\t\treturn get(lc, l, mid, ind);",
            "\t\t}",
            "\t\treturn get(rc, mid + 1, r, ind);",
            "\t}",
            "",
            "   public:",
            "\ttemplate <typename given_type>",
            "\tseg_tree(vector<given_type> &g, F operation, tree_type identity_element) : op(operation), identity(identity_element) {",
            "\t\tthis->n = g.size();",
            "\t\ttree.resize(4 * n);",
            "\t\tbuild(1, 0, n - 1, g);",
            "\t}",
            "\t// [l, r] 0-indexed",
            "\ttree_type query(int ql, int qr) {",
            "\t\tassert(ql >= 0 && qr <= n - 1 && ql <= qr);",
            "\t\treturn query(1, 0, n - 1, ql, qr);",
            "\t}",
            "\tvoid add(int ind, tree_type delta) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\tadd(1, 0, n - 1, ind, delta);",
            "\t}",
            "\tvoid set(int ind, tree_type val) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\tset(1, 0, n - 1, ind, val);",
            "\t}",
            "\ttree_type get(int ind) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\treturn get(1, 0, n - 1, ind);",
            "\t}",
            "\ttree_type prefix_query(int r) { return query(0, r); }",
            "\ttree_type suffix_query(int l) { return query(l, n - 1); }",
            "\ttree_type operator[](int ind) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\treturn get(ind);",
            "\t}",
            "\ttree_type query_all() { return tree[1]; }",
            "};"
        ]
    },
    "io_xll": {
        "prefix": "io_xll",
        "body": [
            "ostream& operator<<(ostream& os, __uint128_t x) {",
            "\tchar buffer[41], *d = std::end(buffer);",
            "\tdo *--d = '0' + (x % 10), x /= 10;",
            "\twhile (x);",
            "\tos.rdbuf()->sputn(d, std::end(buffer) - d);",
            "\treturn os;",
            "}",
            "ostream& operator<<(ostream& os, __int128_t x) {",
            "\tif (x < 0) os << '-';",
            "\treturn os << (__uint128_t(x < 0 ? -x : x));",
            "}"
        ]
    },
    "atcoder_static_mint": {
        "prefix": "atcoder_static_mint",
        "body": [
            "namespace internal {",
            "\ttemplate <class T>",
            "\tusing is_signed_int128 =",
            "\t\ttypename std::conditional<std::is_same<T, __int128_t>::value || std::is_same<T, __int128>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int128 =",
            "\t\ttypename std::conditional<std::is_same<T, __uint128_t>::value || std::is_same<T, unsigned __int128>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_integral = typename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value ||",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t  is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_signed_int =",
            "\t\ttypename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) || is_signed_int128<T>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int =",
            "\t\ttypename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) || is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "\tconstexpr long long safe_mod(long long x, long long m) {",
            "\t\tx %= m;",
            "\t\tif (x < 0) x += m;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tconstexpr long long pow_mod_constexpr(long long x, long long n, int m) {",
            "\t\tif (m == 1) return 0;",
            "\t\tunsigned int _m = (unsigned int)(m);",
            "\t\tunsigned long long r = 1;",
            "\t\tunsigned long long y = safe_mod(x, m);",
            "\t\twhile (n) {",
            "\t\t\tif (n & 1) r = (r * y) % _m;",
            "\t\t\ty = (y * y) % _m;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "",
            "\tconstexpr bool is_prime_constexpr(int n) {",
            "\t\tif (n <= 1) return false;",
            "\t\tif (n == 2 || n == 7 || n == 61) return true;",
            "\t\tif (n % 2 == 0) return false;",
            "\t\tlong long d = n - 1;",
            "\t\twhile (d % 2 == 0) d /= 2;",
            "\t\tconstexpr long long bases[3] = {2, 7, 61};",
            "\t\tfor (long long a : bases) {",
            "\t\t\tlong long t = d;",
            "\t\t\tlong long y = pow_mod_constexpr(a, t, n);",
            "\t\t\twhile (t != n - 1 && y != 1 && y != n - 1) {",
            "\t\t\t\ty = y * y % n;",
            "\t\t\t\tt <<= 1;",
            "\t\t\t}",
            "\t\t\tif (y != n - 1 && t % 2 == 0) {",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "\ttemplate <int n>",
            "\tconstexpr bool is_prime = is_prime_constexpr(n);",
            "\tconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "\t\ta = safe_mod(a, b);",
            "\t\tif (a == 0) return {b, 0};",
            "\t\tlong long s = b, t = a;",
            "\t\tlong long m0 = 0, m1 = 1;",
            "",
            "\t\twhile (t) {",
            "\t\t\tlong long u = s / t;",
            "\t\t\ts -= t * u;",
            "\t\t\tm0 -= m1 * u;",
            "\t\t\tauto tmp = s;",
            "\t\t\ts = t;",
            "\t\t\tt = tmp;",
            "\t\t\ttmp = m0;",
            "\t\t\tm0 = m1;",
            "\t\t\tm1 = tmp;",
            "\t\t}",
            "\t\tif (m0 < 0) m0 += b / s;",
            "\t\treturn {s, m0};",
            "\t}",
            "",
            "\tstruct modint_base {};",
            "\tstruct static_modint_base : modint_base {};",
            "",
            "}  // namespace internal",
            "",
            "template <int m, std::enable_if_t<(1 <= m)> * = nullptr>",
            "struct static_modint : internal::static_modint_base {",
            "\tusing mint = static_modint;",
            "",
            "   public:",
            "\tstatic constexpr int mod() { return m; }",
            "\tstatic mint raw(int v) {",
            "\t\tmint x;",
            "\t\tx._v = v;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tstatic_modint() : _v(0) {}",
            "\ttemplate <class T, internal::is_signed_int_t<T> * = nullptr>",
            "\tstatic_modint(T v) {",
            "\t\tlong long x = (long long)(v % (long long)(umod()));",
            "\t\tif (x < 0) x += umod();",
            "\t\t_v = (unsigned int)(x);",
            "\t}",
            "\ttemplate <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "\tstatic_modint(T v) {",
            "\t\t_v = (unsigned int)(v % umod());",
            "\t}",
            "",
            "\tunsigned int val() const { return _v; }",
            "",
            "\tmint &operator++() {",
            "\t\t_v++;",
            "\t\tif (_v == umod()) _v = 0;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator--() {",
            "\t\tif (_v == 0) _v = umod();",
            "\t\t_v--;",
            "\t\treturn *this;",
            "\t}",
            "\tmint operator++(int) {",
            "\t\tmint result = *this;",
            "\t\t++*this;",
            "\t\treturn result;",
            "\t}",
            "\tmint operator--(int) {",
            "\t\tmint result = *this;",
            "\t\t--*this;",
            "\t\treturn result;",
            "\t}",
            "",
            "\tmint &operator+=(const mint &rhs) {",
            "\t\t_v += rhs._v;",
            "\t\tif (_v >= umod()) _v -= umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &rhs) {",
            "\t\t_v -= rhs._v;",
            "\t\tif (_v >= umod()) _v += umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &rhs) {",
            "\t\tunsigned long long z = _v;",
            "\t\tz *= rhs._v;",
            "\t\t_v = (unsigned int)(z % umod());",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "\tmint operator+() const { return *this; }",
            "\tmint operator-() const { return mint() - *this; }",
            "",
            "\tmint pow(long long n) const {",
            "\t\tassert(0 <= n);",
            "\t\tmint x = *this, r = 1;",
            "\t\twhile (n) {",
            "\t\t\tif (n & 1) r *= x;",
            "\t\t\tx *= x;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "\tmint inv() const {",
            "\t\tif (prime) {",
            "\t\t\tassert(_v);",
            "\t\t\treturn pow(umod() - 2);",
            "\t\t} else {",
            "\t\t\tauto eg = internal::inv_gcd(_v, m);",
            "\t\t\tassert(eg.first == 1);",
            "\t\t\treturn eg.second;",
            "\t\t}",
            "\t}",
            "",
            "\tfriend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "\tfriend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "\tfriend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "\tfriend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "\tfriend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "\tfriend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "",
            "   private:",
            "\tunsigned int _v;",
            "\tstatic constexpr unsigned int umod() { return m; }",
            "\tstatic constexpr bool prime = internal::is_prime<m>;",
            "};",
            "template <int md>",
            "std::ostream &operator<<(std::ostream &os, const static_modint<md> &x) {",
            "\treturn os << x.val();",
            "}",
            "",
            "// using mint = static_modint<998244353>;",
            "using mint = static_modint<1000'000'007>;"
        ]
    },
    "atcoder_dynamic_modint": {
        "prefix": "atcoder_dynamic_modint",
        "body": [
            "namespace internal {",
            "\ttemplate <class T>",
            "\tusing is_signed_int128 =",
            "\t\ttypename std::conditional<std::is_same<T, __int128_t>::value || std::is_same<T, __int128>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int128 =",
            "\t\ttypename std::conditional<std::is_same<T, __uint128_t>::value || std::is_same<T, unsigned __int128>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_integral = typename std::conditional<std::is_integral<T>::value || is_signed_int128<T>::value ||",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t  is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_signed_int =",
            "\t\ttypename std::conditional<(is_integral<T>::value && std::is_signed<T>::value) || is_signed_int128<T>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int =",
            "\t\ttypename std::conditional<(is_integral<T>::value && std::is_unsigned<T>::value) || is_unsigned_int128<T>::value,",
            "\t\t\t\t\t\t\t\t  std::true_type, std::false_type>::type;",
            "",
            "\ttemplate <class T>",
            "\tusing is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "\ttemplate <class T>",
            "\tusing is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "\tconstexpr long long safe_mod(long long x, long long m) {",
            "\t\tx %= m;",
            "\t\tif (x < 0) x += m;",
            "\t\treturn x;",
            "\t}",
            "\tstruct barrett {",
            "\t\tunsigned int _m;",
            "\t\tunsigned long long im;",
            "\t\texplicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "\t\tunsigned int umod() const { return _m; }",
            "\t\tunsigned int mul(unsigned int a, unsigned int b) const {",
            "\t\t\tunsigned long long z = a;",
            "\t\t\tz *= b;",
            "\t\t\tunsigned long long x = (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "\t\t\tunsigned long long y = x * _m;",
            "\t\t\treturn (unsigned int)(z - y + (z < y ? _m : 0));",
            "\t\t}",
            "\t};",
            "",
            "\tconstexpr std::pair<long long, long long> inv_gcd(long long a, long long b) {",
            "\t\ta = safe_mod(a, b);",
            "\t\tif (a == 0) return {b, 0};",
            "\t\tlong long s = b, t = a;",
            "\t\tlong long m0 = 0, m1 = 1;",
            "",
            "\t\twhile (t) {",
            "\t\t\tlong long u = s / t;",
            "\t\t\ts -= t * u;",
            "\t\t\tm0 -= m1 * u;",
            "\t\t\tauto tmp = s;",
            "\t\t\ts = t;",
            "\t\t\tt = tmp;",
            "\t\t\ttmp = m0;",
            "\t\t\tm0 = m1;",
            "\t\t\tm1 = tmp;",
            "\t\t}",
            "\t\tif (m0 < 0) m0 += b / s;",
            "\t\treturn {s, m0};",
            "\t}",
            "",
            "\tstruct modint_base {};",
            "}  // namespace internal",
            "",
            "template <int id>",
            "struct dynamic_modint : internal::modint_base {",
            "\tusing mint = dynamic_modint;",
            "",
            "   public:",
            "\tstatic int mod() { return (int)(bt.umod()); }",
            "",
            "\tstatic void set_mod(int m) {",
            "\t\tassert(1 <= m);",
            "\t\tbt = internal::barrett(m);",
            "\t}",
            "",
            "\tstatic mint raw(int v) {",
            "\t\tmint x;",
            "\t\tx._v = v;",
            "\t\treturn x;",
            "\t}",
            "",
            "\tdynamic_modint() : _v(0) {}",
            "",
            "\ttemplate <class T, internal::is_signed_int_t<T> * = nullptr>",
            "\tdynamic_modint(T v) {",
            "\t\tlong long x = (long long)(v % (long long)(mod()));",
            "\t\tif (x < 0) x += mod();",
            "\t\t_v = (unsigned int)(x);",
            "\t}",
            "",
            "\ttemplate <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "\tdynamic_modint(T v) {",
            "\t\t_v = (unsigned int)(v % mod());",
            "\t}",
            "",
            "\tunsigned int val() const { return _v; }",
            "",
            "\tmint &operator++() {",
            "\t\t_v++;",
            "\t\tif (_v == umod()) _v = 0;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator--() {",
            "\t\tif (_v == 0) _v = umod();",
            "\t\t_v--;",
            "\t\treturn *this;",
            "\t}",
            "\tmint operator++(int) {",
            "\t\tmint result = *this;",
            "\t\t++*this;",
            "\t\treturn result;",
            "\t}",
            "\tmint operator--(int) {",
            "\t\tmint result = *this;",
            "\t\t--*this;",
            "\t\treturn result;",
            "\t}",
            "",
            "\tmint &operator+=(const mint &rhs) {",
            "\t\t_v += rhs._v;",
            "\t\tif (_v >= umod()) _v -= umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &rhs) {",
            "\t\t_v += mod() - rhs._v;",
            "\t\tif (_v >= umod()) _v -= umod();",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &rhs) {",
            "\t\t_v = bt.mul(_v, rhs._v);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "\tmint operator+() const { return *this; }",
            "\tmint operator-() const { return mint() - *this; }",
            "",
            "\tmint pow(long long n) const {",
            "\t\tassert(0 <= n);",
            "\t\tmint x = *this, r = 1;",
            "\t\twhile (n) {",
            "\t\t\tif (n & 1) r *= x;",
            "\t\t\tx *= x;",
            "\t\t\tn >>= 1;",
            "\t\t}",
            "\t\treturn r;",
            "\t}",
            "\tmint inv() const {",
            "\t\tauto eg = internal::inv_gcd(_v, mod());",
            "\t\tassert(eg.first == 1);",
            "\t\treturn eg.second;",
            "\t}",
            "",
            "\tfriend mint operator+(const mint &lhs, const mint &rhs) { return mint(lhs) += rhs; }",
            "\tfriend mint operator-(const mint &lhs, const mint &rhs) { return mint(lhs) -= rhs; }",
            "\tfriend mint operator*(const mint &lhs, const mint &rhs) { return mint(lhs) *= rhs; }",
            "\tfriend mint operator/(const mint &lhs, const mint &rhs) { return mint(lhs) /= rhs; }",
            "\tfriend bool operator==(const mint &lhs, const mint &rhs) { return lhs._v == rhs._v; }",
            "\tfriend bool operator!=(const mint &lhs, const mint &rhs) { return lhs._v != rhs._v; }",
            "",
            "   private:",
            "\tunsigned int _v;",
            "\tstatic internal::barrett bt;",
            "\tstatic unsigned int umod() { return bt.umod(); }",
            "};",
            "template <int id>",
            "internal::barrett dynamic_modint<id>::bt(998244353);",
            "",
            "",
            "template <int id>",
            "std::ostream &operator<<(std::ostream &os, const dynamic_modint<id> &x) {",
            "\treturn os << x.val();",
            "}",
            "",
            "using modint = dynamic_modint<-1>;"
        ]
    },
    "fast_factorize": {
        "prefix": "fast_factorize",
        "body": [
            "namespace internal {",
            "\ttemplate <typename T>",
            "\tusing is_broadly_integral = typename conditional_t<is_integral_v<T> || is_same_v<T, __int128_t> || is_same_v<T, __uint128_t>,",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t   true_type, false_type>::type;",
            "",
            "\ttemplate <typename T>",
            "\tusing is_broadly_signed = typename conditional_t<is_signed_v<T> || is_same_v<T, __int128_t>, true_type, false_type>::type;",
            "",
            "\ttemplate <typename T>",
            "\tusing is_broadly_unsigned =",
            "\t\ttypename conditional_t<is_unsigned_v<T> || is_same_v<T, __uint128_t>, true_type, false_type>::type;",
            "",
            "}  // namespace internal",
            "",
            "namespace internal {",
            "",
            "\ttemplate <typename T>",
            "\tT safe_mod(T a, T p) {",
            "\t\ta %= p;",
            "\t\tif constexpr (is_broadly_signed<T>::value) {",
            "\t\t\tif (a < 0) a += p;",
            "\t\t}",
            "\t\treturn a;",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tpair<T, T> inv_gcd(T a, T p) {",
            "\t\tstatic_assert(is_broadly_signed<T>::value);",
            "\t\ta = safe_mod(a, p);",
            "\t\tif (a == 0) return {p, 0};",
            "\t\tT b = p, x = 1, y = 0;",
            "\t\twhile (a != 0) {",
            "\t\t\tT q = b / a;",
            "\t\t\tswap(a, b %= a);",
            "\t\t\tswap(x, y -= q * x);",
            "\t\t}",
            "\t\tif (y < 0) y += p / b;",
            "\t\treturn {b, y};",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tT inv(T a, T p) {",
            "\t\tstatic_assert(is_broadly_signed<T>::value);",
            "\t\ta = safe_mod(a, p);",
            "\t\tT b = p, x = 1, y = 0;",
            "\t\twhile (a != 0) {",
            "\t\t\tT q = b / a;",
            "\t\t\tswap(a, b %= a);",
            "\t\t\tswap(x, y -= q * x);",
            "\t\t}",
            "\t\tassert(b == 1);",
            "\t\treturn y < 0 ? y + p : y;",
            "\t}",
            "",
            "\ttemplate <typename T, typename U>",
            "\tT modpow(T a, U n, T p) {",
            "\t\ta = safe_mod(a, p);",
            "\t\tT ret = 1 % p;",
            "\t\twhile (n != 0) {",
            "\t\t\tif (n % 2 == 1) ret = U(ret) * a % p;",
            "\t\t\ta = U(a) * a % p;",
            "\t\t\tn /= 2;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tpair<T, T> crt(const vector<T> &r, const vector<T> &m) {",
            "\t\tstatic_assert(is_broadly_signed<T>::value);",
            "\t\tassert(r.size() == m.size());",
            "\t\tint n = int(r.size());",
            "\t\tT r0 = 0, m0 = 1;",
            "\t\tfor (int i = 0; i < n; i++) {",
            "\t\t\tassert(1 <= m[i]);",
            "\t\t\tT r1 = safe_mod(r[i], m[i]), m1 = m[i];",
            "\t\t\tif (m0 < m1) swap(r0, r1), swap(m0, m1);",
            "\t\t\tif (m0 % m1 == 0) {",
            "\t\t\t\tif (r0 % m1 != r1) return {0, 0};",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tauto [g, im] = inv_gcd(m0, m1);",
            "\t\t\tT u1 = m1 / g;",
            "\t\t\tif ((r1 - r0) % g) return {0, 0};",
            "\t\t\tT x = (r1 - r0) / g % u1 * im % u1;",
            "\t\t\tr0 += x * m0;",
            "\t\t\tm0 *= u1;",
            "\t\t\tif (r0 < 0) r0 += m0;",
            "\t\t}",
            "\t\treturn {r0, m0};",
            "\t}",
            "",
            "}  // namespace internal",
            "",
            "namespace internal {",
            "\tunsigned long long non_deterministic_seed() {",
            "\t\tunsigned long long m =",
            "\t\t\tchrono::duration_cast<chrono::nanoseconds>(chrono::high_resolution_clock::now().time_since_epoch()).count();",
            "\t\tm ^= 9845834732710364265uLL;",
            "\t\tm ^= m << 24, m ^= m >> 31, m ^= m << 35;",
            "\t\treturn m;",
            "\t}",
            "\tunsigned long long deterministic_seed() { return 88172645463325252UL; }",
            "\tunsigned long long seed() { return non_deterministic_seed(); }",
            "\tusing i64 = long long;",
            "\tusing u64 = unsigned long long;",
            "",
            "\t// [0, 2^64 - 1)",
            "\tu64 rng() {",
            "\t\tstatic u64 _x = internal::seed();",
            "\t\treturn _x ^= _x << 7, _x ^= _x >> 9;",
            "\t}",
            "",
            "}  // namespace internal",
            "",
            "template <typename Int, typename UInt, typename Long, typename ULong, int id>",
            "struct Dynamic_Modint_Base {",
            "\tusing mint = Dynamic_Modint_Base;",
            "",
            "\tinline static UInt mod;",
            "\tinline static UInt r;",
            "\tinline static UInt n2;",
            "\tstatic constexpr int bit_length = sizeof(UInt) * 8;",
            "",
            "\tstatic UInt get_r() {",
            "\t\tUInt ret = mod;",
            "\t\twhile (mod * ret != 1) ret *= UInt(2) - mod * ret;",
            "\t\treturn ret;",
            "\t}",
            "\tstatic void set_mod(UInt m) {",
            "\t\tassert(m < (UInt(1u) << (bit_length - 2)));",
            "\t\tassert((m & 1) == 1);",
            "\t\tmod = m, n2 = -ULong(m) % m, r = get_r();",
            "\t}",
            "\tUInt a;",
            "",
            "\tDynamic_Modint_Base() : a(0) {}",
            "\tDynamic_Modint_Base(const Long &b) : a(reduce(ULong(b % mod + mod) * n2)) {};",
            "",
            "\tstatic UInt reduce(const ULong &b) { return (b + ULong(UInt(b) * UInt(-r)) * mod) >> bit_length; }",
            "",
            "\tmint &operator+=(const mint &b) {",
            "\t\tif (Int(a += b.a - 2 * mod) < 0) a += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator-=(const mint &b) {",
            "\t\tif (Int(a -= b.a) < 0) a += 2 * mod;",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator*=(const mint &b) {",
            "\t\ta = reduce(ULong(a) * b.a);",
            "\t\treturn *this;",
            "\t}",
            "\tmint &operator/=(const mint &b) {",
            "\t\t*this *= b.inverse();",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tmint operator+(const mint &b) const { return mint(*this) += b; }",
            "\tmint operator-(const mint &b) const { return mint(*this) -= b; }",
            "\tmint operator*(const mint &b) const { return mint(*this) *= b; }",
            "\tmint operator/(const mint &b) const { return mint(*this) /= b; }",
            "",
            "\tbool operator==(const mint &b) const { return (a >= mod ? a - mod : a) == (b.a >= mod ? b.a - mod : b.a); }",
            "\tbool operator!=(const mint &b) const { return (a >= mod ? a - mod : a) != (b.a >= mod ? b.a - mod : b.a); }",
            "\tmint operator-() const { return mint(0) - mint(*this); }",
            "\tmint operator+() const { return mint(*this); }",
            "",
            "\tmint pow(ULong n) const {",
            "\t\tmint ret(1), mul(*this);",
            "\t\twhile (n > 0) {",
            "\t\t\tif (n & 1) ret *= mul;",
            "\t\t\tmul *= mul, n >>= 1;",
            "\t\t}",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tfriend ostream &operator<<(ostream &os, const mint &b) { return os << b.get(); }",
            "",
            "\tfriend istream &operator>>(istream &is, mint &b) {",
            "\t\tLong t;",
            "\t\tis >> t;",
            "\t\tb = Dynamic_Modint_Base(t);",
            "\t\treturn (is);",
            "\t}",
            "",
            "\tmint inverse() const {",
            "\t\tInt x = get(), y = get_mod(), u = 1, v = 0;",
            "\t\twhile (y > 0) {",
            "\t\t\tInt t = x / y;",
            "\t\t\tswap(x -= t * y, y);",
            "\t\t\tswap(u -= t * v, v);",
            "\t\t}",
            "\t\treturn mint{u};",
            "\t}",
            "",
            "\tUInt get() const {",
            "\t\tUInt ret = reduce(a);",
            "\t\treturn ret >= mod ? ret - mod : ret;",
            "\t}",
            "",
            "\tstatic UInt get_mod() { return mod; }",
            "};",
            "",
            "template <int id>",
            "using Dynamic_Modint = Dynamic_Modint_Base<int, unsigned int, long long, unsigned long long, id>;",
            "template <int id>",
            "using Dynamic_Modint64bit = Dynamic_Modint_Base<long long, unsigned long long, __int128_t, __uint128_t, id>;",
            "",
            "namespace fast_factorize {",
            "\ttemplate <typename T, typename U>",
            "\tbool miller_rabin(const T &n, vector<T> ws) {",
            "\t\tif (n <= 2) return n == 2;",
            "\t\tif (n % 2 == 0) return false;",
            "",
            "\t\tT d = n - 1;",
            "\t\twhile (d % 2 == 0) d /= 2;",
            "\t\tU e = 1, rev = n - 1;",
            "\t\tfor (T w : ws) {",
            "\t\t\tif (w % n == 0) continue;",
            "\t\t\tT t = d;",
            "\t\t\tU y = internal::modpow<T, U>(w, t, n);",
            "\t\t\twhile (t != n - 1 && y != e && y != rev) y = y * y % n, t *= 2;",
            "\t\t\tif (y != rev && t % 2 == 0) return false;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "",
            "\tbool miller_rabin_u64(unsigned long long n) {",
            "\t\treturn miller_rabin<unsigned long long, __uint128_t>(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});",
            "\t}",
            "",
            "\ttemplate <typename mint>",
            "\tbool miller_rabin(unsigned long long n, vector<unsigned long long> ws) {",
            "\t\tif (n <= 2) return n == 2;",
            "\t\tif (n % 2 == 0) return false;",
            "",
            "\t\tif (mint::get_mod() != n) mint::set_mod(n);",
            "\t\tunsigned long long d = n - 1;",
            "\t\twhile (~d & 1) d >>= 1;",
            "\t\tmint e = 1, rev = n - 1;",
            "\t\tfor (unsigned long long w : ws) {",
            "\t\t\tif (w % n == 0) continue;",
            "\t\t\tunsigned long long t = d;",
            "\t\t\tmint y = mint(w).pow(t);",
            "\t\t\twhile (t != n - 1 && y != e && y != rev) y *= y, t *= 2;",
            "\t\t\tif (y != rev && t % 2 == 0) return false;",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "",
            "\tbool is_prime(unsigned long long n) {",
            "\t\tusing mint32 = Dynamic_Modint<96229631>;",
            "\t\tusing mint64 = Dynamic_Modint64bit<622196072>;",
            "",
            "\t\tif (n <= 2) return n == 2;",
            "\t\tif (n % 2 == 0) return false;",
            "\t\tif (n < (1uLL << 30)) {",
            "\t\t\treturn miller_rabin<mint32>(n, {2, 7, 61});",
            "\t\t} else if (n < (1uLL << 62)) {",
            "\t\t\treturn miller_rabin<mint64>(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});",
            "\t\t} else {",
            "\t\t\treturn miller_rabin_u64(n);",
            "\t\t}",
            "\t}",
            "\tusing u64 = uint64_t;",
            "",
            "\ttemplate <typename mint, typename T>",
            "\tT pollard_rho(T n) {",
            "\t\tif (~n & 1) return 2;",
            "\t\tif (is_prime(n)) return n;",
            "\t\tif (mint::get_mod() != n) mint::set_mod(n);",
            "\t\tmint R, one = 1;",
            "\t\tauto f = [&](mint x) { return x * x + R; };",
            "\t\tauto rnd_ = [&]() { return internal::rng() % (n - 2) + 2; };",
            "\t\twhile (1) {",
            "\t\t\tmint x, y, ys, q = one;",
            "\t\t\tR = rnd_(), y = rnd_();",
            "\t\t\tT g = 1;",
            "\t\t\tconstexpr int m = 128;",
            "\t\t\tfor (int r = 1; g == 1; r <<= 1) {",
            "\t\t\t\tx = y;",
            "\t\t\t\tfor (int i = 0; i < r; ++i) y = f(y);",
            "\t\t\t\tfor (int k = 0; g == 1 && k < r; k += m) {",
            "\t\t\t\t\tys = y;",
            "\t\t\t\t\tfor (int i = 0; i < m && i < r - k; ++i) q *= x - (y = f(y));",
            "\t\t\t\t\tg = gcd(q.get(), n);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif (g == n) do",
            "\t\t\t\t\tg = gcd((x - (ys = f(ys))).get(), n);",
            "\t\t\t\twhile (g == 1);",
            "\t\t\tif (g != n) return g;",
            "\t\t}",
            "\t\texit(1);",
            "\t}",
            "",
            "\tusing i64 = long long;",
            "",
            "\tvector<i64> inner_factorize(u64 n) {",
            "\t\tusing mint32 = Dynamic_Modint<452288976>;",
            "\t\tusing mint64 = Dynamic_Modint64bit<401243123>;",
            "",
            "\t\tif (n <= 1) return {};",
            "\t\tu64 p;",
            "\t\tif (n <= (1LL << 30)) {",
            "\t\t\tp = pollard_rho<mint32, uint32_t>(n);",
            "\t\t} else if (n <= (1LL << 62)) {",
            "\t\t\tp = pollard_rho<mint64, uint64_t>(n);",
            "\t\t} else {",
            "\t\t\texit(1);",
            "\t\t}",
            "\t\tif (p == n) return {i64(p)};",
            "\t\tauto l = inner_factorize(p);",
            "\t\tauto r = inner_factorize(n / p);",
            "\t\tcopy(begin(r), end(r), back_inserter(l));",
            "\t\treturn l;",
            "\t}",
            "",
            "\tvector<i64> factorize(u64 n) {",
            "\t\tauto ret = inner_factorize(n);",
            "\t\tsort(begin(ret), end(ret));",
            "\t\treturn ret;",
            "\t}",
            "",
            "\tmap<i64, i64> factor_count(u64 n) {",
            "\t\tmap<i64, i64> mp;",
            "\t\tfor (auto &x : factorize(n)) mp[x]++;",
            "\t\treturn mp;",
            "\t}",
            "",
            "\tvector<i64> divisors(u64 n) {",
            "\t\tif (n == 0) return {};",
            "\t\tvector<pair<i64, i64>> v;",
            "\t\tfor (auto &p : factorize(n)) {",
            "\t\t\tif (v.empty() || v.back().first != p) {",
            "\t\t\t\tv.emplace_back(p, 1);",
            "\t\t\t} else {",
            "\t\t\t\tv.back().second++;",
            "\t\t\t}",
            "\t\t}",
            "\t\tvector<i64> ret;",
            "\t\tauto f = [&](auto rc, int i, i64 x) -> void {",
            "\t\t\tif (i == (int)v.size()) {",
            "\t\t\t\tret.push_back(x);",
            "\t\t\t\treturn;",
            "\t\t\t}",
            "\t\t\trc(rc, i + 1, x);",
            "\t\t\tfor (int j = 0; j < v[i].second; j++) rc(rc, i + 1, x *= v[i].first);",
            "\t\t};",
            "\t\tf(f, 0, 1);",
            "\t\tsort(begin(ret), end(ret));",
            "\t\treturn ret;",
            "\t}",
            "",
            "}  // namespace fast_factorize",
            "using fast_factorize::divisors;",
            "using fast_factorize::factor_count;",
            "using fast_factorize::factorize;",
            "using fast_factorize::is_prime;",
            ""
        ]
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "struct Timer {",
            "\tTimer() { reset(); }",
            "",
            "\tvoid reset() { bgn = std::chrono::high_resolution_clock::now(); }",
            "",
            "\ttemplate <typename PeriodType = std::chrono::milliseconds>",
            "\tlong long elapsed() const {",
            "\t\tconst std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();",
            "\t\treturn std::chrono::duration_cast<PeriodType>(end - bgn).count();",
            "\t}",
            "",
            "\tvoid display_time_elapsed() { cerr   << \"[Time Elapsed = \" << elapsed() << \"ms]\" << endl; }",
            "",
            "   private:",
            "\tstd::chrono::high_resolution_clock::time_point bgn;",
            "};"
        ]
    },
    "type_alias": {
        "prefix": "type_alias",
        "body": [
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using xll = __int128_t;",
            "using uxll = __uint128_t;"
        ]
    },
    "inc_debug": {
        "prefix": "inc_debug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"_debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "incdebug": {
        "prefix": "incdebug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "fileio": {
        "prefix": "fileio",
        "body": [
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif"
        ]
    },
    "mod_power": {
        "prefix": "mod_power",
        "body": [
            "inline constexpr uint64_t mod_power(uint64_t x, uint64_t n, uint64_t m) {",
            "\tif (m == 1)",
            "\t\treturn 0;",
            "\tuint64_t r = 1;",
            "\tuint64_t y = x % m;",
            "\twhile (n) {",
            "\t\tif (n & 1)",
            "\t\t\tr = (uint64_t)((__uint128_t)(1) * r * y % m);",
            "\t\ty = (uint64_t)((__uint128_t)(1) * y * y % m);",
            "\t\tn >>= 1;",
            "\t}",
            "\treturn r;",
            "}"
        ]
    },
    "valid": {
        "prefix": "valid",
        "body": [
            "auto valid = [&](int x, int y) -> bool { return x >= 0 && y >= 0 && x < n && y < m; };"
        ]
    },
    "inc__debug": {
        "prefix": "inc__debug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"__debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "fastio": {
        "prefix": "fastio",
        "body": [
            "ios::sync_with_stdio(0);",
            "\tcin.tie(0);"
        ]
    },
    "trim": {
        "prefix": "trim",
        "body": [
            "void trimleft(string &input) {",
            "\tinput.erase(input.begin(), find_if(input.begin(), input.end(), [](int ch) { return !isspace(ch); }));",
            "}",
            "void trimright(string &input) {",
            "\tinput.erase(find_if(input.rbegin(), input.rend(), [](int ch) { return !isspace(ch); }).base(), input.end());",
            "}",
            "",
            "void trim(string &input) {",
            "\ttrimleft(input);",
            "\ttrimright(input);",
            "}"
        ]
    },
    "main": {
        "prefix": [
            "main",
            "multi"
        ],
        "body": [
            "#include <bits/extc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using xll = __int128_t;",
            "using xull = __uint128_t;",
            "",
            "#if defined(LOCAL)",
            "#include \"__debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif",
            "",
            "void solve() {",
            "\t$0",
            "}",
            "",
            "int32_t main() {",
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif",
            "\tios::sync_with_stdio(0);",
            "\tcin.tie(0);",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}"
        ]
    },
    "inf": {
        "prefix": "inf",
        "body": [
            "#define pinf(type) (numeric_limits<type>::max())",
            "#define ninf(type) (numeric_limits<type>::min())"
        ]
    },
    "time": {
        "prefix": "time",
        "body": [
            "#define start\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\",
            "\tusing namespace chrono;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \\",
            "\tauto start_time = high_resolution_clock::now();",
            "",
            "#define stop\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\",
            "\tauto stop_time = high_resolution_clock::now();\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \\",
            "\tauto duration = duration_cast<milliseconds>(stop_time - start_time);\t\t\t\t\t\t\t\t\t \\",
            "\tcerr << \"[Time Taken\" << \" = \" << duration << \"]\" << endl << endl;",
            ""
        ]
    },
    "cpp": {
        "prefix": "cpp",
        "body": [
            "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math,inline\")",
            "#include <bits/extc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using xll = __int128_t;",
            "using xull = __uint128_t;",
            "",
            "const ll MOD = 1e9 + 7;",
            "const ll OMOD = 998'244'353;",
            "",
            "#if defined(LOCAL)",
            "#include \"__debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif",
            "",
            "void solve() {",
            "\t$0",
            "}",
            "",
            "int32_t main() {",
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif",
            "\tios::sync_with_stdio(0);",
            "\tcin.tie(0);",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}"
        ]
    },
    "leet": {
        "prefix": "leet",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using xll = __int128_t;",
            "using uxll = __uint128_t;",
            "",
            "const ll MOD = 1e9 + 7;",
            "const ll OMOD = 998244353;",
            "",
            "#define pinf(type) (numeric_limits<type>::max())",
            "#define ninf(type) (numeric_limits<type>::min())",
            "",
            "inline namespace IO {",
            "#define SFINAE(x, ...)\t\t\t \\",
            "\ttemplate <class, class = void> \\",
            "\tstruct x : std::false_type {}; \\",
            "\ttemplate <class T>\t\t\t \\",
            "\tstruct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "",
            "\tostream &operator<<(ostream &os, __uint128_t x) {",
            "\t\tchar buffer[41], *d = std::end(buffer);",
            "\t\tdo *--d = '0' + (x % 10), x /= 10;",
            "\t\twhile (x);",
            "\t\tos.rdbuf()->sputn(d, std::end(buffer) - d);",
            "\t\treturn os;",
            "\t}",
            "\tostream &operator<<(ostream &os, __int128_t x) {",
            "\t\tif (x < 0) os << '-';",
            "\t\treturn os << (__uint128_t(x < 0 ? -x : x));",
            "\t}",
            "",
            "\tSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));",
            "\tSFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "\tSFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "\ttemplate <auto &os>",
            "\tstruct Writer {",
            "\t\ttemplate <class T>",
            "\t\tvoid Impl(T const &t) const {",
            "\t\t\tif constexpr (DefaultO<T>::value)",
            "\t\t\t\tos << t;",
            "\t\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\t\tos << '{';",
            "\t\t\t\tint i = 0;",
            "\t\t\t\tfor (auto &&x : t) ((i++) ? (os << ',' << ' ', Impl(x)) : Impl(x));",
            "\t\t\t\tos << '}';",
            "\t\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\t\tos << '(';",
            "\t\t\t\tstd::apply(",
            "\t\t\t\t\t[this](auto const &...args) {",
            "\t\t\t\t\t\tint i = 0;",
            "\t\t\t\t\t\t(((i++) ? (os << ',' << \" \", Impl(args)) : Impl(args)), ...);",
            "\t\t\t\t\t},",
            "\t\t\t\t\tt);",
            "\t\t\t\tos << ')';",
            "\t\t\t} else",
            "\t\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for print\");",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid ImplWrapper(T const &t) const {",
            "\t\t\tImpl(t);",
            "\t\t}",
            "\t\ttemplate <class... Ts>",
            "\t\tvoid print(Ts const &...ts) const {",
            "\t\t\t((Impl(ts)), ...);",
            "\t\t}",
            "\t\ttemplate <class F, class... Ts>",
            "\t\tvoid print_with_sep(const std::string &sep, F const &f, Ts const &...ts) const {",
            "\t\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';",
            "\t\t}",
            "\t\tvoid print_with_sep(const std::string &) const { os << '\\n'; }",
            "\t};",
            "}  // namespace IO",
            "",
            "inline namespace Debug {",
            "\ttemplate <typename... Args>",
            "\tvoid err(Args... args) {",
            "\t\tWriter<cout>{}.print_with_sep(\" | \", args...);",
            "\t}",
            "",
            "\tvoid err_prefix(string func, int line, string args) {",
            "\t\tcout << \"DEBUG\"",
            "\t\t\t << \" | \" << func << \":\" << line << \": \"",
            "\t\t\t << \"[\" << args << \"] = \";",
            "\t}",
            "}  // namespace Debug",
            "",
            "#define clg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)",
            ""
        ]
    },
    "dir4": {
        "prefix": "dir4",
        "body": [
            "constexpr int dx[4] = {1, 0, -1, 0};",
            "constexpr int dy[4] = {0, 1, 0, -1};"
        ]
    },
    "dir8": {
        "prefix": "dir8",
        "body": [
            "constexpr int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};",
            "constexpr int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};"
        ]
    },
    "prime_factorization_using_linear_sieve_returning_vector<pair>": {
        "prefix": "prime_factorize_using_linear_sieve_returning_vector<pair>",
        "body": [
            "",
            "class LinearSieve {",
            "   public:",
            "\tLinearSieve(const int n) : _n(n), min_prime_factor(std::vector<int>(n + 1)) {",
            "\t\tstd::iota(min_prime_factor.begin(), min_prime_factor.end(), 0);",
            "\t\tprime_list.reserve(_n / 20);",
            "\t\tfor (int d = 2; d <= _n; ++d) {",
            "\t\t\tif (min_prime_factor[d] == d) prime_list.push_back(d);",
            "\t\t\tconst int prime_max = std::min(min_prime_factor[d], _n / d);",
            "\t\t\tfor (int prime : prime_list) {",
            "\t\t\t\tif (prime > prime_max) break;",
            "\t\t\t\tmin_prime_factor[prime * d] = prime;",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "\tstd::vector<std::pair<int, int>> factorize(int n) const noexcept {",
            "\t\tassert(0 < n and n <= _n);",
            "\t\tstd::vector<std::pair<int, int>> prime_powers;",
            "\t\twhile (n > 1) {",
            "\t\t\tint p = min_prime_factor[n], c = 0;",
            "\t\t\tdo {",
            "\t\t\t\tn /= p, ++c;",
            "\t\t\t} while (n % p == 0);",
            "\t\t\tprime_powers.emplace_back(p, c);",
            "\t\t}",
            "\t\treturn prime_powers;",
            "\t}",
            "\tconst int _n;",
            "\tstd::vector<int> min_prime_factor;",
            "\tstd::vector<int> prime_list;",
            "};",
            ""
        ]
    },
    "ext_gcd": {
        "prefix": "ext_gcd",
        "body": [
            "",
            "constexpr long long safe_mod(long long x, long long m) {",
            "\tx %= m;",
            "\treturn x < 0 ? x + m : x;",
            "}",
            "",
            "// returns {x,y,g} s.t. ax+by=g=gcd(a,b)>=0.",
            "std::tuple<long long, long long, long long> ext_gcd(long long a, long long b) {",
            "\tlong long x = 1, y = 0;",
            "\tlong long z = 0, w = 1;",
            "\twhile (b) {",
            "\t\tlong long p = a / b, q = a % b;",
            "\t\tx -= y * p, std::swap(x, y);",
            "\t\tz -= w * p, std::swap(z, w);",
            "\t\ta = b, b = q;",
            "\t}",
            "\tif (a < 0) {",
            "\t\tx = -x, z = -z, a = -a;",
            "\t}",
            "\treturn {x, z, a};",
            "}",
            "",
            "// returns {x,g} s.t. a*x=g (mod m)",
            "std::pair<long long, long long> gcd_inv(long long a, long long m) {",
            "\tauto [x, y, g] = ext_gcd(a, m);",
            "\treturn {safe_mod(x, m), g};",
            "}",
            "",
            "// returns x s.t. a*x=1 (mod m) if exists, otherwise throws runtime error.",
            "long long inv_mod(long long a, long long mod) {",
            "\tauto [inv, y, g] = ext_gcd(a, mod);",
            "\tassert(g == 1);",
            "\treturn safe_mod(inv, mod);",
            "}",
            ""
        ]
    },
    "linear_sieve": {
        "prefix": "linear_sieve",
        "body": [
            "vector<int> spf;",
            "vector<bool> ipm;",
            "vector<int> pm;",
            "",
            "void sieve(int maximum) {",
            "\tmaximum = max(maximum, 1);",
            "\tspf.assign(maximum + 1, 0);",
            "\tipm.assign(maximum + 1, true);",
            "\tipm[0] = ipm[1] = false;",
            "\tpm = {};",
            "",
            "\tfor (int i = 2; i <= maximum; i++) {",
            "\t\tif (ipm[i]) {",
            "\t\t\tspf[i] = i;",
            "\t\t\tpm.push_back(i);",
            "\t\t}",
            "",
            "\t\tfor (int p : pm) {",
            "\t\t\tif (p > spf[i] || int64_t(i) * p > maximum) break;",
            "",
            "\t\t\tipm[i * p] = false;",
            "\t\t\tspf[i * p] = p;",
            "\t\t}",
            "\t}",
            "}"
        ]
    },
    "factorizer_tourist": {
        "prefix": "factorizer_tourist",
        "body": [
            "",
            "template <typename T>",
            "T inverse(T a, T m) {",
            "\tT u = 0, v = 1;",
            "\twhile (a != 0) {",
            "\t\tT t = m / a;",
            "\t\tm -= t * a;",
            "\t\tswap(a, m);",
            "\t\tu -= t * v;",
            "\t\tswap(u, v);",
            "\t}",
            "\tassert(m == 1);",
            "\treturn u;",
            "}",
            "",
            "template <typename T>",
            "class Modular {",
            "  public:",
            "\tusing Type = typename decay<decltype(T::value)>::type;",
            "",
            "\tconstexpr Modular() : value() {}",
            "\ttemplate <typename U>",
            "\tModular(const U &x) {",
            "\t\tvalue = normalize(x);",
            "\t}",
            "",
            "\ttemplate <typename U>",
            "\tstatic Type normalize(const U &x) {",
            "\t\tType v;",
            "\t\tif (-mod() <= x && x < mod())",
            "\t\t\tv = static_cast<Type>(x);",
            "\t\telse",
            "\t\t\tv = static_cast<Type>(x % mod());",
            "\t\tif (v < 0)",
            "\t\t\tv += mod();",
            "\t\treturn v;",
            "\t}",
            "",
            "\tconst Type &operator()() const { return value; }",
            "\ttemplate <typename U>",
            "\texplicit operator U() const { return static_cast<U>(value); }",
            "\tconstexpr static Type mod() { return T::value; }",
            "",
            "\tModular &operator+=(const Modular &other) {",
            "\t\tvalue += other.value;",
            "\t\tvalue -= (value >= mod()) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\tModular &operator-=(const Modular &other) {",
            "\t\tvalue -= other.value;",
            "\t\tvalue += (value < 0) * mod();",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U>",
            "\tModular &operator+=(const U &other) { return *this += Modular(other); }",
            "\ttemplate <typename U>",
            "\tModular &operator-=(const U &other) { return *this -= Modular(other); }",
            "\tModular &operator++() { return *this += 1; }",
            "\tModular &operator--() { return *this -= 1; }",
            "\tModular operator++(int) {",
            "\t\tModular result(*this);",
            "\t\t*this += 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator--(int) {",
            "\t\tModular result(*this);",
            "\t\t*this -= 1;",
            "\t\treturn result;",
            "\t}",
            "\tModular operator-() const { return Modular(-value); }",
            "",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {",
            "\t\tint64_t q = int64_t(static_cast<long double>(value) * rhs.value / mod());",
            "\t\tvalue = normalize(value * rhs.value - q * mod());",
            "\t\treturn *this;",
            "\t}",
            "\ttemplate <typename U = T>",
            "\ttypename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {",
            "\t\tvalue = normalize(value * rhs.value);",
            "\t\treturn *this;",
            "\t}",
            "",
            "\tModular &operator/=(const Modular &other) { return *this *= Modular(inverse(other.value, mod())); }",
            "",
            "\tfriend const Type &abs(const Modular &x) { return x.value; }",
            "",
            "\ttemplate <typename U>",
            "\tfriend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename U>",
            "\tfriend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);",
            "",
            "\ttemplate <typename V, typename U>",
            "\tfriend V &operator>>(V &stream, Modular<U> &number);",
            "",
            "  private:",
            "\tType value;",
            "};",
            "",
            "template <typename T>",
            "bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }",
            "template <typename T, typename U>",
            "bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }",
            "template <typename T, typename U>",
            "bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }",
            "",
            "template <typename T>",
            "bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U>",
            "bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U>",
            "bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
            "",
            "template <typename T>",
            "bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }",
            "",
            "template <typename T>",
            "Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
            "",
            "template <typename T>",
            "Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
            "",
            "template <typename T>",
            "Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
            "",
            "template <typename T>",
            "Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U>",
            "Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
            "",
            "template <typename T, typename U>",
            "Modular<T> power(const Modular<T> &a, const U &b) {",
            "\tassert(b >= 0);",
            "\tModular<T> x = a, res = 1;",
            "\tU p = b;",
            "\twhile (p > 0) {",
            "\t\tif (p & 1)",
            "\t\t\tres *= x;",
            "\t\tx *= x;",
            "\t\tp >>= 1;",
            "\t}",
            "\treturn res;",
            "}",
            "",
            "template <typename T>",
            "bool IsZero(const Modular<T> &number) {",
            "\treturn number() == 0;",
            "}",
            "",
            "template <typename T>",
            "string to_string(const Modular<T> &number) {",
            "\treturn to_string(number());",
            "}",
            "",
            "template <typename U, typename T>",
            "U &operator<<(U &stream, const Modular<T> &number) {",
            "\treturn stream << number();",
            "}",
            "",
            "template <typename U, typename T>",
            "U &operator>>(U &stream, Modular<T> &number) {",
            "\ttypename common_type<typename Modular<T>::Type, int64_t>::type x;",
            "\tstream >> x;",
            "\tnumber.value = Modular<T>::normalize(x);",
            "\treturn stream;",
            "}",
            "namespace factorizer {",
            "",
            "\ttemplate <typename T>",
            "\tstruct FactorizerVarMod {",
            "\t\tstatic T value;",
            "\t};",
            "\ttemplate <typename T>",
            "\tT FactorizerVarMod<T>::value;",
            "",
            "\ttemplate <typename T>",
            "\tbool IsPrime(T n, const vector<T> &bases) {",
            "\t\tif (n < 2) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t\tvector<T> small_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};",
            "\t\tfor (const T &x : small_primes) {",
            "\t\t\tif (n % x == 0) {",
            "\t\t\t\treturn n == x;",
            "\t\t\t}",
            "\t\t}",
            "\t\tif (n < 31 * 31) {",
            "\t\t\treturn true;",
            "\t\t}",
            "\t\tint s = 0;",
            "\t\tT d = n - 1;",
            "\t\twhile ((d & 1) == 0) {",
            "\t\t\td >>= 1;",
            "\t\t\ts++;",
            "\t\t}",
            "\t\tFactorizerVarMod<T>::value = n;",
            "\t\tfor (const T &a : bases) {",
            "\t\t\tif (a % n == 0) {",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tModular<FactorizerVarMod<T>> cur = a;",
            "\t\t\tcur = power(cur, d);",
            "\t\t\tif (cur == 1) {",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tbool witness = true;",
            "\t\t\tfor (int r = 0; r < s; r++) {",
            "\t\t\t\tif (cur == n - 1) {",
            "\t\t\t\t\twitness = false;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tcur *= cur;",
            "\t\t\t}",
            "\t\t\tif (witness) {",
            "\t\t\t\treturn false;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn true;",
            "\t}",
            "",
            "\tbool IsPrime(int64_t n) {",
            "\t\treturn IsPrime(n, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});",
            "\t}",
            "",
            "\tbool IsPrime(int32_t n) {",
            "\t\treturn IsPrime(n, {2, 7, 61});",
            "\t}",
            "",
            "\tvector<int> least = {0, 1};",
            "\tvector<int> primes;",
            "\tint precalculated = 1;",
            "",
            "\tvoid RunLinearSieve(int n) {",
            "\t\tn = max(n, 1);",
            "\t\tleast.assign(n + 1, 0);",
            "\t\tprimes.clear();",
            "\t\tfor (int i = 2; i <= n; i++) {",
            "\t\t\tif (least[i] == 0) {",
            "\t\t\t\tleast[i] = i;",
            "\t\t\t\tprimes.push_back(i);",
            "\t\t\t}",
            "\t\t\tfor (int x : primes) {",
            "\t\t\t\tif (x > least[i] || i * x > n) {",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t\tleast[i * x] = x;",
            "\t\t\t}",
            "\t\t}",
            "\t\tprecalculated = n;",
            "\t}",
            "",
            "\tvoid RunSieve(int n) {",
            "\t\tRunLinearSieve(n);",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<pair<T, int>> MergeFactors(const vector<pair<T, int>> &a, const vector<pair<T, int>> &b) {",
            "\t\tvector<pair<T, int>> c;",
            "\t\tint i = 0;",
            "\t\tint j = 0;",
            "\t\twhile (i < (int)a.size() || j < (int)b.size()) {",
            "\t\t\tif (i < (int)a.size() && j < (int)b.size() && a[i].first == b[j].first) {",
            "\t\t\t\tc.emplace_back(a[i].first, a[i].second + b[j].second);",
            "\t\t\t\t++i;",
            "\t\t\t\t++j;",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tif (j == (int)b.size() || (i < (int)a.size() && a[i].first < b[j].first)) {",
            "\t\t\t\tc.push_back(a[i++]);",
            "\t\t\t} else {",
            "\t\t\t\tc.push_back(b[j++]);",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn c;",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<pair<T, int>> RhoC(const T &n, const T &c) {",
            "\t\tif (n <= 1) {",
            "\t\t\treturn {};",
            "\t\t}",
            "\t\tif ((n & 1) == 0) {",
            "\t\t\treturn MergeFactors({{2, 1}}, RhoC(n / 2, c));",
            "\t\t}",
            "\t\tif (IsPrime(n)) {",
            "\t\t\treturn {{n, 1}};",
            "\t\t}",
            "\t\tFactorizerVarMod<T>::value = n;",
            "\t\tModular<FactorizerVarMod<T>> x = 2;",
            "\t\tModular<FactorizerVarMod<T>> saved = 2;",
            "\t\tT power = 1;",
            "\t\tT lam = 1;",
            "\t\twhile (true) {",
            "\t\t\tx = x * x + c;",
            "\t\t\tT g = __gcd((x - saved)(), n);",
            "\t\t\tif (g != 1) {",
            "\t\t\t\treturn MergeFactors(RhoC(g, c + 1), RhoC(n / g, c + 1));",
            "\t\t\t}",
            "\t\t\tif (power == lam) {",
            "\t\t\t\tsaved = x;",
            "\t\t\t\tpower <<= 1;",
            "\t\t\t\tlam = 0;",
            "\t\t\t}",
            "\t\t\tlam++;",
            "\t\t}",
            "\t\treturn {};",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<pair<T, int>> Rho(const T &n) {",
            "\t\treturn RhoC(n, static_cast<T>(1));",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<pair<T, int>> Factorize(T x) {",
            "\t\tif (x <= 1) {",
            "\t\t\treturn {};",
            "\t\t}",
            "\t\tif (x <= precalculated) {",
            "\t\t\tvector<pair<T, int>> ret;",
            "\t\t\twhile (x > 1) {",
            "\t\t\t\tif (!ret.empty() && ret.back().first == least[x]) {",
            "\t\t\t\t\tret.back().second++;",
            "\t\t\t\t} else {",
            "\t\t\t\t\tret.emplace_back(least[x], 1);",
            "\t\t\t\t}",
            "\t\t\t\tx /= least[x];",
            "\t\t\t}",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\tif (x <= static_cast<int64_t>(precalculated) * precalculated) {",
            "\t\t\tvector<pair<T, int>> ret;",
            "\t\t\tif (!IsPrime(x)) {",
            "\t\t\t\tfor (T i : primes) {",
            "\t\t\t\t\tT t = x / i;",
            "\t\t\t\t\tif (i > t) {",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t}",
            "\t\t\t\t\tif (x == t * i) {",
            "\t\t\t\t\t\tint cnt = 0;",
            "\t\t\t\t\t\twhile (x % i == 0) {",
            "\t\t\t\t\t\t\tx /= i;",
            "\t\t\t\t\t\t\tcnt++;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tret.emplace_back(i, cnt);",
            "\t\t\t\t\t\tif (IsPrime(x)) {",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif (x > 1) {",
            "\t\t\t\tret.emplace_back(x, 1);",
            "\t\t\t}",
            "\t\t\treturn ret;",
            "\t\t}",
            "\t\treturn Rho(x);",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tvector<T> BuildDivisorsFromFactors(const vector<pair<T, int>> &factors) {",
            "\t\tvector<T> divisors = {1};",
            "\t\tfor (auto &p : factors) {",
            "\t\t\tint sz = (int)divisors.size();",
            "\t\t\tfor (int i = 0; i < sz; i++) {",
            "\t\t\t\tT cur = divisors[i];",
            "\t\t\t\tfor (int j = 0; j < p.second; j++) {",
            "\t\t\t\t\tcur *= p.first;",
            "\t\t\t\t\tdivisors.push_back(cur);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t}",
            "\t\tsort(divisors.begin(), divisors.end());",
            "\t\treturn divisors;",
            "\t}",
            "\ttemplate <typename T>",
            "\tstruct PrimitiveVarMod {",
            "\t\tstatic T value;",
            "\t};",
            "\ttemplate <typename T>",
            "\tT PrimitiveVarMod<T>::value;",
            "",
            "\ttemplate <typename T, class F>",
            "\tT GetPrimitiveRoot(const T &modulo, const F &factorize) {",
            "\t\tif (modulo <= 0) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tif (modulo == 1 || modulo == 2 || modulo == 4) {",
            "\t\t\treturn modulo - 1;",
            "\t\t}",
            "\t\tvector<pair<T, int>> modulo_factors = factorize(modulo);",
            "\t\tif (modulo_factors[0].first == 2 && (modulo_factors[0].second != 1 || modulo_factors.size() != 2)) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tif (modulo_factors[0].first != 2 && modulo_factors.size() != 1) {",
            "\t\t\treturn -1;",
            "\t\t}",
            "\t\tset<T> phi_factors;",
            "\t\tT phi = modulo;",
            "\t\tfor (auto &d : modulo_factors) {",
            "\t\t\tphi = phi / d.first * (d.first - 1);",
            "\t\t\tif (d.second > 1) {",
            "\t\t\t\tphi_factors.insert(d.first);",
            "\t\t\t}",
            "\t\t\tfor (auto &e : factorize(d.first - 1)) {",
            "\t\t\t\tphi_factors.insert(e.first);",
            "\t\t\t}",
            "\t\t}",
            "\t\tPrimitiveVarMod<T>::value = modulo;",
            "\t\tModular<PrimitiveVarMod<T>> gen = 2;",
            "\t\twhile (gen != 0) {",
            "\t\t\tif (power(gen, phi) != 1) {",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\tbool ok = true;",
            "\t\t\tfor (auto &p : phi_factors) {",
            "\t\t\t\tif (power(gen, phi / p) == 1) {",
            "\t\t\t\t\tok = false;",
            "\t\t\t\t\tbreak;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tif (ok) {",
            "\t\t\t\treturn gen();",
            "\t\t\t}",
            "\t\t\tgen++;",
            "\t\t}",
            "\t\tassert(false);",
            "\t\treturn -1;",
            "\t}",
            "",
            "\ttemplate <typename T>",
            "\tT get_primitive_root(const T &modulo) {",
            "\t\treturn GetPrimitiveRoot(modulo, Factorize<T>);",
            "\t}",
            "} // namespace factorizer",
            "using factorizer::BuildDivisorsFromFactors;",
            "using factorizer::Factorize;",
            "using factorizer::get_primitive_root;",
            "using factorizer::MergeFactors;"
        ]
    },
    "is_prime": {
        "prefix": "is_prime",
        "body": [
            "inline constexpr uint64_t mod_power(uint64_t x, uint64_t n, uint64_t m) {",
            "\tif (m == 1)",
            "\t\treturn 0;",
            "\tuint64_t r = 1;",
            "\tuint64_t y = x % m;",
            "\twhile (n) {",
            "\t\tif (n & 1)",
            "\t\t\tr = (uint64_t)((__uint128_t)(1) * r * y % m);",
            "\t\ty = (uint64_t)((__uint128_t)(1) * y * y % m);",
            "\t\tn >>= 1;",
            "\t}",
            "\treturn r;",
            "}",
            "inline bool is_prime(uint64_t n) {",
            "\tif (n % 2 == 0)",
            "\t\treturn false;",
            "\tuint64_t d = n - 1;",
            "\twhile (d % 2 == 0)",
            "\t\td /= 2;",
            "\tfor (uint64_t a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {",
            "\t\tif (a % n == 0)",
            "\t\t\treturn true;",
            "\t\tuint64_t t = d;",
            "\t\tuint64_t y = mod_power(a, t, n);",
            "\t\twhile (t != n - 1 && y != 1 && y != n - 1) {",
            "\t\t\ty = (uint64_t)((__uint128_t)(1) * y * y % n);",
            "\t\t\tt <<= 1;",
            "\t\t}",
            "\t\tif (y != n - 1 && t % 2 == 0) {",
            "\t\t\treturn false;",
            "\t\t}",
            "\t}",
            "\treturn true;",
            "}"
        ]
    },
    "spf_and_primes": {
        "prefix": "spf_and_primes",
        "body": [
            "inline std::vector<int> get_spf_table(int n) {",
            "\t\tstd::vector<int> table(n + 1, -1);",
            "\t\tstd::vector<int> primes;",
            "\t\tfor (int d = 2; d <= n; d++) {",
            "\t\t\tif (table[d] == -1) {",
            "\t\t\t\tprimes.push_back(d);",
            "\t\t\t\ttable[d] = d;",
            "\t\t\t}",
            "\t\t\tfor (int p : primes) {",
            "\t\t\t\tif (p * d > n || p > table[d])",
            "\t\t\t\t\tbreak;",
            "\t\t\t\ttable[p * d] = p;",
            "\t\t\t}",
            "\t\t}",
            "\t\treturn table;",
            "\t}",
            "",
            "\tinline std::vector<int> get_prime_table(int n) {",
            "\t\tstd::vector<int> table = get_spf_table(n);",
            "\t\tstd::vector<int> p;",
            "\t\tfor (int i = 2; i <= n; i++) {",
            "\t\t\tif (table[i] == i)",
            "\t\t\t\tp.push_back(i);",
            "\t\t}",
            "\t\treturn p;",
            "\t}"
        ]
    },
    "scpp": {
        "prefix": [
            "scpp",
            "single"
        ],
        "body": [
            "#include <bits/extc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using xll = __int128_t;",
            "using xull = __uint128_t;",
            "",
            "#if defined(LOCAL)",
            "#include \"__debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif",
            "",
            "void solve() {",
            "\t$0",
            "}",
            "",
            "int main() {",
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif",
            "\tint tc = 1;",
            "\t// cin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}"
        ]
    },
}