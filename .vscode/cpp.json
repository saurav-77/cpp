{
    "simple_segment_tree_myself": {
        "prefix": "simple_segment_tree_myself",
        "body": [
            "template <typename tree_type, typename F>",
            "class seg_tree {",
            "\tvector<tree_type> tree;",
            "\tF op;",
            "\ttree_type identity;",
            "\tint n;",
            "\ttemplate <typename given_type>",
            "\tvoid build(int id, int l, int r, vector<given_type> &given) {",
            "\t\tif (l == r) {",
            "\t\t\ttree[id] = given[l];",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tbuild(lc, l, mid, given);",
            "\t\tbuild(rc, mid + 1, r, given);",
            "\t\ttree[id] = op(tree[lc], tree[rc]);",
            "\t}",
            "\ttree_type query(int id, int l, int r, int ql, int qr) {",
            "\t\tif (l > qr || r < ql) {",
            "\t\t\treturn identity;",
            "\t\t}",
            "\t\tif (l >= ql && r <= qr) {",
            "\t\t\treturn tree[id];",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\ttree_type lhs = query(lc, l, mid, ql, qr);",
            "\t\ttree_type rhs = query(rc, mid + 1, r, ql, qr);",
            "\t\treturn op(lhs, rhs);",
            "\t}",
            "\tvoid set(int id, int l, int r, int ind, tree_type value) {",
            "\t\tif (l == r && l == ind) {",
            "\t\t\ttree[id] = value;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tif (ind <= mid)",
            "\t\t\tset(lc, l, mid, ind, value);",
            "\t\telse",
            "\t\t\tset(rc, mid + 1, r, ind, value);",
            "\t\ttree[id] = op(tree[lc], tree[rc]);",
            "\t}",
            "",
            "\tvoid add(int id, int l, int r, int ind, tree_type value) {",
            "\t\tif (l == r && l == ind) {",
            "\t\t\ttree[id] += value;",
            "\t\t\treturn;",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tif (ind <= mid)",
            "\t\t\tadd(lc, l, mid, ind, value);",
            "\t\telse",
            "\t\t\tadd(rc, mid + 1, r, ind, value);",
            "\t\ttree[id] = op(tree[lc], tree[rc]);",
            "\t}",
            "",
            "\ttree_type get(int id, int l, int r, int ind) {",
            "\t\tif (l == r && l == ind) {",
            "\t\t\treturn tree[id];",
            "\t\t}",
            "\t\tint mid = midpoint(l, r);",
            "\t\tint lc = id << 1;",
            "\t\tint rc = (id << 1) | 1;",
            "\t\tif (ind <= mid) {",
            "\t\t\treturn get(lc, l, mid, ind);",
            "\t\t}",
            "\t\treturn get(rc, mid + 1, r, ind);",
            "\t}",
            "",
            "   public:",
            "\ttemplate <typename given_type>",
            "\tseg_tree(vector<given_type> &g, F operation, tree_type identity_element) : op(operation), identity(identity_element) {",
            "\t\tthis->n = g.size();",
            "\t\ttree.resize(4 * n);",
            "\t\tbuild(1, 0, n - 1, g);",
            "\t}",
            "\t// [l, r] 0-indexed",
            "\ttree_type query(int ql, int qr) {",
            "\t\tassert(ql >= 0 && qr <= n - 1 && ql <= qr);",
            "\t\treturn query(1, 0, n - 1, ql, qr);",
            "\t}",
            "\tvoid add(int ind, tree_type delta) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\tadd(1, 0, n - 1, ind, delta);",
            "\t}",
            "\tvoid set(int ind, tree_type val) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\tset(1, 0, n - 1, ind, val);",
            "\t}",
            "\ttree_type get(int ind) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\treturn get(1, 0, n - 1, ind);",
            "\t}",
            "\ttree_type prefix_query(int r) { return query(0, r); }",
            "\ttree_type suffix_query(int l) { return query(l, n - 1); }",
            "\ttree_type operator[](int ind) {",
            "\t\tassert(ind >= 0 && ind <= n - 1);",
            "\t\treturn get(ind);",
            "\t}",
            "\ttree_type query_all() { return tree[1]; }",
            "};"
        ]
    },
    "io_xll": {
        "prefix": "io_xll",
        "body": [
            "ostream& operator<<(ostream& os, __uint128_t x) {",
            "\tchar buffer[41], *d = std::end(buffer);",
            "\tdo *--d = '0' + (x % 10), x /= 10;",
            "\twhile (x);",
            "\tos.rdbuf()->sputn(d, std::end(buffer) - d);",
            "\treturn os;",
            "}",
            "ostream& operator<<(ostream& os, __int128_t x) {",
            "\tif (x < 0) os << '-';",
            "\treturn os << (__uint128_t(x < 0 ? -x : x));",
            "}"
        ]
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "struct Timer {",
            "\tTimer() { reset(); }",
            "",
            "\tvoid reset() { bgn = std::chrono::high_resolution_clock::now(); }",
            "",
            "\ttemplate <typename PeriodType = std::chrono::milliseconds>",
            "\tlong long elapsed() const {",
            "\t\tconst std::chrono::high_resolution_clock::time_point end = std::chrono::high_resolution_clock::now();",
            "\t\treturn std::chrono::duration_cast<PeriodType>(end - bgn).count();",
            "\t}",
            "",
            "\tvoid display_time_elapsed() { cerr   << \"[Time Elapsed = \" << elapsed() << \"ms]\" << endl; }",
            "",
            "   private:",
            "\tstd::chrono::high_resolution_clock::time_point bgn;",
            "};"
        ]
    },
    "type_alias": {
        "prefix": "type_alias",
        "body": [
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using llx = __int128_t;",
            "using ullx = __uint128_t;"
        ]
    },
    "inc_debug": {
        "prefix": "inc_debug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"_debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "incdebug": {
        "prefix": "incdebug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "fileio": {
        "prefix": "fileio",
        "body": [
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif"
        ]
    },
    "valid": {
        "prefix": "valid",
        "body": [
            "auto valid = [&](int x, int y) -> bool { return x >= 0 && y >= 0 && x < n && y < m; };"
        ]
    },
    "inc__debug": {
        "prefix": "inc__debug",
        "body": [
            "#if defined(LOCAL)",
            "#include \"__debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif"
        ]
    },
    "fastio": {
        "prefix": "fastio",
        "body": [
            "ios::sync_with_stdio(0);",
            "\tcin.tie(0);"
        ]
    },
    "trim": {
        "prefix": "trim",
        "body": [
            "void trimleft(string &input) {",
            "\tinput.erase(input.begin(), find_if(input.begin(), input.end(), [](int ch) { return !isspace(ch); }));",
            "}",
            "void trimright(string &input) {",
            "\tinput.erase(find_if(input.rbegin(), input.rend(), [](int ch) { return !isspace(ch); }).base(), input.end());",
            "}",
            "",
            "void trim(string &input) {",
            "\ttrimleft(input);",
            "\ttrimright(input);",
            "}"
        ]
    },
    "main": {
        "prefix": [
            "main",
            "multi"
        ],
        "body": [
            "#include <bits/extc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using llx = __int128_t;",
            "using ullx = __uint128_t;",
            "",
            "#if defined(LOCAL)",
            "#include \"__debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif",
            "",
            "void solve() {",
            "\t$0",
            "}",
            "",
            "int32_t main() {",
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif",
            "\tios::sync_with_stdio(0);",
            "\tcin.tie(0);",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}"
        ]
    },
    "inf": {
        "prefix": "inf",
        "body": [
            "#define pinf(type) (numeric_limits<type>::max())",
            "#define ninf(type) (numeric_limits<type>::min())"
        ]
    },
    "time": {
        "prefix": "time",
        "body": [
            "#define start\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\",
            "\tusing namespace chrono;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \\",
            "\tauto start_time = high_resolution_clock::now();",
            "",
            "#define stop\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\",
            "\tauto stop_time = high_resolution_clock::now();\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \\",
            "\tauto duration = duration_cast<milliseconds>(stop_time - start_time);\t\t\t\t\t\t\t\t\t \\",
            "\tcerr << \"[Time Taken\" << \" = \" << duration << \"]\" << endl << endl;",
            ""
        ]
    },
    "cpp": {
        "prefix": "cpp",
        "body": [
            "#pragma GCC optimize(\"Ofast,unroll-loops,no-stack-protector,fast-math,inline\")",
            "#include <bits/extc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using llx = __int128_t;",
            "using ullx = __uint128_t;",
            "",
            "const ll MOD = 1e9 + 7;",
            "const ll OMOD = 998'244'353;",
            "",
            "#if defined(LOCAL)",
            "#include \"__debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif",
            "",
            "void solve() {",
            "\t$0",
            "}",
            "",
            "int32_t main() {",
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif",
            "\tios::sync_with_stdio(0);",
            "\tcin.tie(0);",
            "\tint tc = 1;",
            "\tcin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}"
        ]
    },
    "leet": {
        "prefix": "leet",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using llx = __int128_t;",
            "using ullx = __uint128_t;",
            "",
            "const ll MOD = 1e9 + 7;",
            "const ll OMOD = 998244353;",
            "",
            "#define pinf(type) (numeric_limits<type>::max())",
            "#define ninf(type) (numeric_limits<type>::min())",
            "",
            "inline namespace IO {",
            "#define SFINAE(x, ...)\t\t\t \\",
            "\ttemplate <class, class = void> \\",
            "\tstruct x : std::false_type {}; \\",
            "\ttemplate <class T>\t\t\t \\",
            "\tstruct x<T, std::void_t<__VA_ARGS__>> : std::true_type {}",
            "",
            "\tostream &operator<<(ostream &os, __uint128_t x) {",
            "\t\tchar buffer[41], *d = std::end(buffer);",
            "\t\tdo *--d = '0' + (x % 10), x /= 10;",
            "\t\twhile (x);",
            "\t\tos.rdbuf()->sputn(d, std::end(buffer) - d);",
            "\t\treturn os;",
            "\t}",
            "\tostream &operator<<(ostream &os, __int128_t x) {",
            "\t\tif (x < 0) os << '-';",
            "\t\treturn os << (__uint128_t(x < 0 ? -x : x));",
            "\t}",
            "",
            "\tSFINAE(DefaultO, decltype(std::cout << std::declval<T &>()));",
            "\tSFINAE(IsTuple, typename std::tuple_size<T>::type);",
            "\tSFINAE(Iterable, decltype(std::begin(std::declval<T>())));",
            "",
            "\ttemplate <auto &os>",
            "\tstruct Writer {",
            "\t\ttemplate <class T>",
            "\t\tvoid Impl(T const &t) const {",
            "\t\t\tif constexpr (DefaultO<T>::value)",
            "\t\t\t\tos << t;",
            "\t\t\telse if constexpr (Iterable<T>::value) {",
            "\t\t\t\tos << '{';",
            "\t\t\t\tint i = 0;",
            "\t\t\t\tfor (auto &&x : t) ((i++) ? (os << ',' << ' ', Impl(x)) : Impl(x));",
            "\t\t\t\tos << '}';",
            "\t\t\t} else if constexpr (IsTuple<T>::value) {",
            "\t\t\t\tos << '(';",
            "\t\t\t\tstd::apply(",
            "\t\t\t\t\t[this](auto const &...args) {",
            "\t\t\t\t\t\tint i = 0;",
            "\t\t\t\t\t\t(((i++) ? (os << ',' << \" \", Impl(args)) : Impl(args)), ...);",
            "\t\t\t\t\t},",
            "\t\t\t\t\tt);",
            "\t\t\t\tos << ')';",
            "\t\t\t} else",
            "\t\t\t\tstatic_assert(IsTuple<T>::value, \"No matching type for print\");",
            "\t\t}",
            "\t\ttemplate <class T>",
            "\t\tvoid ImplWrapper(T const &t) const {",
            "\t\t\tImpl(t);",
            "\t\t}",
            "\t\ttemplate <class... Ts>",
            "\t\tvoid print(Ts const &...ts) const {",
            "\t\t\t((Impl(ts)), ...);",
            "\t\t}",
            "\t\ttemplate <class F, class... Ts>",
            "\t\tvoid print_with_sep(const std::string &sep, F const &f, Ts const &...ts) const {",
            "\t\t\tImplWrapper(f), ((os << sep, ImplWrapper(ts)), ...), os << '\\n';",
            "\t\t}",
            "\t\tvoid print_with_sep(const std::string &) const { os << '\\n'; }",
            "\t};",
            "}  // namespace IO",
            "",
            "inline namespace Debug {",
            "\ttemplate <typename... Args>",
            "\tvoid err(Args... args) {",
            "\t\tWriter<cout>{}.print_with_sep(\" | \", args...);",
            "\t}",
            "",
            "\tvoid err_prefix(string func, int line, string args) {",
            "\t\tcout << \"DEBUG\"",
            "\t\t\t << \" | \" << func << \":\" << line << \": \"",
            "\t\t\t << \"[\" << args << \"] = \";",
            "\t}",
            "}  // namespace Debug",
            "",
            "#define clg(args...) err_prefix(__FUNCTION__, __LINE__, #args), err(args)",
            ""
        ]
    },
    "dir4": {
        "prefix": "dir4",
        "body": [
            "constexpr int dx[4] = {1, 0, -1, 0};",
            "constexpr int dy[4] = {0, 1, 0, -1};"
        ]
    },
    "dir8": {
        "prefix": "dir8",
        "body": [
            "constexpr int dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};",
            "constexpr int dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};"
        ]
    },
    "scpp": {
        "prefix": [
            "scpp",
            "single"
        ],
        "body": [
            "#include <bits/extc++.h>",
            "using namespace std;",
            "",
            "using ll = int64_t;",
            "using ull = uint64_t;",
            "using llx = __int128_t;",
            "using ullx = __uint128_t;",
            "",
            "#if defined(LOCAL)",
            "#include \"__debug.h\"",
            "#else",
            "#define clg(...)",
            "#endif",
            "",
            "void solve() {",
            "\t$0",
            "}",
            "",
            "int main() {",
            "#ifdef CDEBUG",
            "\tfreopen(\"input.txt\", \"r\", stdin);",
            "\tfreopen(\"output.txt\", \"w\", stdout);",
            "\t// freopen(\"error.txt\", \"w\", stderr);",
            "#endif",
            "\tint tc = 1;",
            "\t// cin >> tc;",
            "\tfor (int i = 1; i <= tc; ++i) {",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}"
        ]
    }
}